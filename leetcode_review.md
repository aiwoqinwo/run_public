
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

- [Greedy](#greedy)
  - [621\. Task Scheduler](#621-task-schedulerhttpsleetcodecomproblemstask-scheduler)
    - [Solution](#solution)
  - [767\. Reorganize String](#767-reorganize-stringhttpsleetcodecomproblemsreorganize-string)
    - [Solution](#solution-1)
  - [277\. Find the Celebrity](#277-find-the-celebrityhttpsleetcodecomproblemsfind-the-celebrity)
    - [Solution](#solution-2)
  - [452\. Minimum Number of Arrows to Burst Balloons](#452-minimum-number-of-arrows-to-burst-balloonshttpsleetcodecomproblemsminimum-number-of-arrows-to-burst-balloons)
    - [Solution](#solution-3)
  - [334\. Increasing Triplet Subsequence](#334-increasing-triplet-subsequencehttpsleetcodecomproblemsincreasing-triplet-subsequence)
    - [Solution](#solution-4)
  - [122\. Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-iihttpsleetcodecomproblemsbest-time-to-buy-and-sell-stock-ii)
    - [Solution](#solution-5)
  - [435\. Non-overlapping Intervals](#435-non-overlapping-intervalshttpsleetcodecomproblemsnon-overlapping-intervals)
    - [Solution](#solution-6)
  - [135\. Candy](#135-candyhttpsleetcodecomproblemscandy)
    - [Solution](#solution-7)
  - [881\. Boats to Save People](#881-boats-to-save-peoplehttpsleetcodecomproblemsboats-to-save-people)
    - [Solution](#solution-8)
  - [1792\. Maximum Average Pass Ratio](#1792-maximum-average-pass-ratiohttpsleetcodecomproblemsmaximum-average-pass-ratio)
    - [Solution](#solution-9)
  - [55\. Jump Game :rainbow:](#55-jump-game-rainbowhttpsleetcodecomproblemsjump-game)
    - [Solution](#solution-10)
  - [45\. Jump Game II :rainbow:](#45-jump-game-ii-rainbowhttpsleetcodecomproblemsjump-game-ii)
    - [Solution](#solution-11)
- [Two Pointers](#two-pointers)
  - [125\. Valid Palindrome](#125-valid-palindromehttpsleetcodecomproblemsvalid-palindrome)
    - [Solution](#solution-12)
  - [986\. Interval List Intersections](#986-interval-list-intersectionshttpsleetcodecomproblemsinterval-list-intersections)
    - [Solution](#solution-13)
  - [88\. Merge Sorted Array](#88-merge-sorted-arrayhttpsleetcodecomproblemsmerge-sorted-array)
    - [Solution](#solution-14)
  - [15\. 3Sum](#15-3sumhttpsleetcodecomproblems3sum)
    - [Solution](#solution-15)
  - [283\. Move Zeroes](#283-move-zeroeshttpsleetcodecomproblemsmove-zeroes)
    - [Solution](#solution-16)
  - [408\. Valid Word Abbreviation](#408-valid-word-abbreviationhttpsleetcodecomproblemsvalid-word-abbreviation)
    - [Solution](#solution-17)
  - [977\. Squares of a Sorted Array](#977-squares-of-a-sorted-arrayhttpsleetcodecomproblemssquares-of-a-sorted-array)
    - [Solution](#solution-18)
  - [75\. Sort Colors :rainbow:](#75-sort-colors-rainbowhttpsleetcodecomproblemssort-colors)
    - [Solution](#solution-19)
  - [611\. Valid Triangle Number](#611-valid-triangle-numberhttpsleetcodecomproblemsvalid-triangle-number)
    - [Solution](#solution-20)
  - [243\. Shortest Word Distance](#243-shortest-word-distancehttpsleetcodecomproblemsshortest-word-distance)
    - [Solution](#solution-21)
  - [244\. Shortest Word Distance II](#244-shortest-word-distance-iihttpsleetcodecomproblemsshortest-word-distance-ii)
    - [Solution](#solution-22)
  - [245\. Shortest Word Distance III](#245-shortest-word-distance-iiihttpsleetcodecomproblemsshortest-word-distance-iii)
    - [Solution](#solution-23)
  - [1861\. Rotating the Box](#1861-rotating-the-boxhttpsleetcodecomproblemsrotating-the-box)
    - [Solution](#solution-24)
  - [443\. String Compression](#443-string-compressionhttpsleetcodecomproblemsstring-compression)
    - [Solution](#solution-25)
  - [1465\. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](#1465-maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cutshttpsleetcodecomproblemsmaximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts)
    - [Solution](#solution-26)
  - [532\. K-diff Pairs in an Array](#532-k-diff-pairs-in-an-arrayhttpsleetcodecomproblemsk-diff-pairs-in-an-array)
    - [Solution](#solution-27)
  - [1868\. Product of Two Run-Length Encoded Arrays :rainbow:](#1868-product-of-two-run-length-encoded-arrays-rainbowhttpsleetcodecomproblemsproduct-of-two-run-length-encoded-arrays)
    - [Solution](#solution-28)
  - [360\. Sort Transformed Array](#360-sort-transformed-arrayhttpsleetcodecomproblemssort-transformed-array)
    - [Solution](#solution-29)
  - [11\. Container With Most Water](#11-container-with-most-waterhttpsleetcodecomproblemscontainer-with-most-water)
    - [Solution](#solution-30)
  - [809\. Expressive Words](#809-expressive-wordshttpsleetcodecomproblemsexpressive-words)
    - [Solution](#solution-31)
  - [134\. Gas Station](#134-gas-stationhttpsleetcodecomproblemsgas-station)
    - [Solution](#solution-32)
  - [763\. Partition Labels :rainbow:](#763-partition-labels-rainbowhttpsleetcodecomproblemspartition-labels)
    - [Solution](#solution-33)
- [Binary Search](#binary-search)
  - [278\. First Bad Version](#278-first-bad-versionhttpsleetcodecomproblemsfirst-bad-version)
    - [Solution](#solution-34)
  - [34\. Find First and Last Position of Element in Sorted Array :rainbow:](#34-find-first-and-last-position-of-element-in-sorted-array-rainbowhttpsleetcodecomproblemsfind-first-and-last-position-of-element-in-sorted-array)
    - [Solution](#solution-35)
  - [50\. Pow(x, n)](#50-powx-nhttpsleetcodecomproblemspowx-n)
    - [Solution](#solution-36)
  - [528\. Random Pick with Weight](#528-random-pick-with-weighthttpsleetcodecomproblemsrandom-pick-with-weight)
    - [Solution](#solution-37)
  - [33\. Search in Rotated Sorted Array :rainbow:](#33-search-in-rotated-sorted-array-rainbowhttpsleetcodecomproblemssearch-in-rotated-sorted-array)
    - [Solution](#solution-38)
  - [1060\. Missing Element in Sorted Array :fire:](#1060-missing-element-in-sorted-array-firehttpsleetcodecomproblemsmissing-element-in-sorted-array)
    - [Solution](#solution-39)
  - [162\. Find Peak Element](#162-find-peak-elementhttpsleetcodecomproblemsfind-peak-element)
    - [Solution](#solution-40)
  - [658\. Find K Closest Elements :rainbow:](#658-find-k-closest-elements-rainbowhttpsleetcodecomproblemsfind-k-closest-elements)
    - [Solution](#solution-41)
  - [240\. Search a 2D Matrix II](#240-search-a-2d-matrix-iihttpsleetcodecomproblemssearch-a-2d-matrix-ii)
    - [Solution](#solution-42)
  - [230\. Kth Smallest Element in a BST :rainbow:](#230-kth-smallest-element-in-a-bst-rainbowhttpsleetcodecomproblemskth-smallest-element-in-a-bst)
    - [Solution](#solution-43)
  - [300\. Longest Increasing Subsequence :fire:](#300-longest-increasing-subsequence-firehttpsleetcodecomproblemslongest-increasing-subsequence)
    - [Solution](#solution-44)
  - [852\. Peak Index in a Mountain Array](#852-peak-index-in-a-mountain-arrayhttpsleetcodecomproblemspeak-index-in-a-mountain-array)
    - [Solution](#solution-45)
  - [69\. Sqrt(x)](#69-sqrtxhttpsleetcodecomproblemssqrtx)
    - [Solution](#solution-46)
  - [367\. Valid Perfect Square](#367-valid-perfect-squarehttpsleetcodecomproblemsvalid-perfect-square)
    - [Solution](#solution-47)
  - [81\. Search in Rotated Sorted Array II](#81-search-in-rotated-sorted-array-iihttpsleetcodecomproblemssearch-in-rotated-sorted-array-ii)
    - [Solution](#solution-48)
  - [744\. Find Smallest Letter Greater Than Target](#744-find-smallest-letter-greater-than-targethttpsleetcodecomproblemsfind-smallest-letter-greater-than-target)
    - [Solution](#solution-49)
  - [981\. Time Based Key-Value Store](#981-time-based-key-value-storehttpsleetcodecomproblemstime-based-key-value-store)
    - [Solution](#solution-50)
  - [1235\. Maximum Profit in Job Scheduling :fire:](#1235-maximum-profit-in-job-scheduling-firehttpsleetcodecomproblemsmaximum-profit-in-job-scheduling)
    - [Solution](#solution-51)
  - [1482\. Minimum Number of Days to Make m Bouquets :rainbow:](#1482-minimum-number-of-days-to-make-m-bouquets-rainbowhttpsleetcodecomproblemsminimum-number-of-days-to-make-m-bouquets)
    - [Solution](#solution-52)
  - [1011\. Capacity To Ship Packages Within D Days :rainbow:](#1011-capacity-to-ship-packages-within-d-days-rainbowhttpsleetcodecomproblemscapacity-to-ship-packages-within-d-days)
    - [Solution](#solution-53)
  - [268\. Missing Number](#268-missing-numberhttpsleetcodecomproblemsmissing-number)
    - [Solution](#solution-54)
  - [633\. Sum of Square Numbers](#633-sum-of-square-numbershttpsleetcodecomproblemssum-of-square-numbers)
    - [Solution](#solution-55)
  - [702\. Search in a Sorted Array of Unknown Size](#702-search-in-a-sorted-array-of-unknown-sizehttpsleetcodecomproblemssearch-in-a-sorted-array-of-unknown-size)
    - [Solution](#solution-56)
  - [1891\. Cutting Ribbons](#1891-cutting-ribbonshttpsleetcodecomproblemscutting-ribbons)
    - [Solution](#solution-57)
  - [1539\. Kth Missing Positive Number :rainbow:](#1539-kth-missing-positive-number-rainbowhttpsleetcodecomproblemskth-missing-positive-number)
    - [Solution](#solution-58)
  - [275\. H-Index II](#275-h-index-iihttpsleetcodecomproblemsh-index-ii)
    - [Solution](#solution-59)
  - [1351\. Count Negative Numbers in a Sorted Matrix](#1351-count-negative-numbers-in-a-sorted-matrixhttpsleetcodecomproblemscount-negative-numbers-in-a-sorted-matrix)
    - [Solution](#solution-60)
  - [14\. Longest Common Prefix](#14-longest-common-prefixhttpsleetcodecomproblemslongest-common-prefix)
    - [Solution](#solution-61)
  - [1348\. Tweet Counts Per Frequency :rainbow:](#1348-tweet-counts-per-frequency-rainbowhttpsleetcodecomproblemstweet-counts-per-frequency)
    - [Solution](#solution-62)
  - [4\. Median of Two Sorted Arrays](#4-median-of-two-sorted-arrayshttpsleetcodecomproblemsmedian-of-two-sorted-arrays)
    - [Solution](#solution-63)
  - [875\. Koko Eating Bananas](#875-koko-eating-bananashttpsleetcodecomproblemskoko-eating-bananas)
    - [Solution](#solution-64)
- [Sort](#sort)
  - [215\. Kth Largest Element in an Array :fire:](#215-kth-largest-element-in-an-array-firehttpsleetcodecomproblemskth-largest-element-in-an-array)
    - [Solution](#solution-65)
  - [791\. Custom Sort String](#791-custom-sort-stringhttpsleetcodecomproblemscustom-sort-string)
    - [Solution](#solution-66)
  - [57\. Insert Interval](#57-insert-intervalhttpsleetcodecomproblemsinsert-interval)
    - [Solution](#solution-67)
  - [296\. Best Meeting Point](#296-best-meeting-pointhttpsleetcodecomproblemsbest-meeting-point)
    - [Solution](#solution-68)
  - [252\. Meeting Rooms](#252-meeting-roomshttpsleetcodecomproblemsmeeting-rooms)
    - [Solution](#solution-69)
  - [1366\. Rank Teams by Votes :fire:](#1366-rank-teams-by-votes-firehttpsleetcodecomproblemsrank-teams-by-votes)
    - [Solution](#solution-70)
  - [274\. H-Index :rainbow:](#274-h-index-rainbowhttpsleetcodecomproblemsh-index)
    - [Solution](#solution-71)
  - [646\. Maximum Length of Pair Chain](#646-maximum-length-of-pair-chainhttpsleetcodecomproblemsmaximum-length-of-pair-chain)
    - [Solution](#solution-72)
  - [280\. Wiggle Sort](#280-wiggle-sorthttpsleetcodecomproblemswiggle-sort)
    - [Solution](#solution-73)
  - [324\. Wiggle Sort II](#324-wiggle-sort-iihttpsleetcodecomproblemswiggle-sort-ii)
    - [Solution](#solution-74)
  - [1710\. Maximum Units on a Truck](#1710-maximum-units-on-a-truckhttpsleetcodecomproblemsmaximum-units-on-a-truck)
    - [Solution](#solution-75)
  - [1498\. Number of Subsequences That Satisfy the Given Sum Condition](#1498-number-of-subsequences-that-satisfy-the-given-sum-conditionhttpsleetcodecomproblemsnumber-of-subsequences-that-satisfy-the-given-sum-condition)
    - [Solution](#solution-76)
- [Breadth-first Search](#breadth-first-search)
  - [199\. Binary Tree Right Side View](#199-binary-tree-right-side-viewhttpsleetcodecomproblemsbinary-tree-right-side-view)
    - [Solution](#solution-77)
  - [314\. Binary Tree Vertical Order Traversal](#314-binary-tree-vertical-order-traversalhttpsleetcodecomproblemsbinary-tree-vertical-order-traversal)
    - [Solution](#solution-78)
  - [987\. Vertical Order Traversal of a Binary Tree](#987-vertical-order-traversal-of-a-binary-treehttpsleetcodecomproblemsvertical-order-traversal-of-a-binary-tree)
    - [Solution](#solution-79)
  - [317\. Shortest Distance from All Buildings :fire:](#317-shortest-distance-from-all-buildings-firehttpsleetcodecomproblemsshortest-distance-from-all-buildings)
    - [Solution](#solution-80)
  - [286\. Walls and Gates](#286-walls-and-gateshttpsleetcodecomproblemswalls-and-gates)
    - [Solution](#solution-81)
  - [339\. Nested List Weight Sum](#339-nested-list-weight-sumhttpsleetcodecomproblemsnested-list-weight-sum)
    - [Solution](#solution-82)
  - [1197\. Minimum Knight Moves](#1197-minimum-knight-moveshttpsleetcodecomproblemsminimum-knight-moves)
    - [Solution](#solution-83)
  - [126\. Word Ladder II :fire:](#126-word-ladder-ii-firehttpsleetcodecomproblemsword-ladder-ii)
    - [Solution](#solution-84)
  - [127\. Word Ladder](#127-word-ladderhttpsleetcodecomproblemsword-ladder)
    - [Solution](#solution-85)
  - [102\. Binary Tree Level Order Traversal](#102-binary-tree-level-order-traversalhttpsleetcodecomproblemsbinary-tree-level-order-traversal)
    - [Solution](#solution-86)
  - [815\. Bus Routes :fire:](#815-bus-routes-firehttpsleetcodecomproblemsbus-routes)
    - [Solution](#solution-87)
  - [1376\. Time Needed to Inform All Employees :rainbow:](#1376-time-needed-to-inform-all-employees-rainbowhttpsleetcodecomproblemstime-needed-to-inform-all-employees)
    - [Solution](#solution-88)
  - [1293\. Shortest Path in a Grid with Obstacles Elimination](#1293-shortest-path-in-a-grid-with-obstacles-eliminationhttpsleetcodecomproblemsshortest-path-in-a-grid-with-obstacles-elimination)
    - [Solution](#solution-89)
  - [864\. Shortest Path to Get All Keys](#864-shortest-path-to-get-all-keyshttpsleetcodecomproblemsshortest-path-to-get-all-keys)
    - [Solution](#solution-90)
  - [515\. Find Largest Value in Each Tree Row](#515-find-largest-value-in-each-tree-rowhttpsleetcodecomproblemsfind-largest-value-in-each-tree-row)
    - [Solution](#solution-91)
  - [1091\. Shortest Path in Binary Matrix](#1091-shortest-path-in-binary-matrixhttpsleetcodecomproblemsshortest-path-in-binary-matrix)
    - [Solution](#solution-92)
  - [797\. All Paths From Source to Target](#797-all-paths-from-source-to-targethttpsleetcodecomproblemsall-paths-from-source-to-target)
    - [Solution](#solution-93)
  - [490\. The Maze](#490-the-mazehttpsleetcodecomproblemsthe-maze)
    - [Solution](#solution-94)
  - [909\. Snakes and Ladders](#909-snakes-and-laddershttpsleetcodecomproblemssnakes-and-ladders)
    - [Solution](#solution-95)
- [Depth-first Search](#depth-first-search)
  - [301\. Remove Invalid Parentheses :fire:](#301-remove-invalid-parentheses-firehttpsleetcodecomproblemsremove-invalid-parentheses)
    - [Solution](#solution-96)
  - [938\. Range Sum of BST](#938-range-sum-of-bsthttpsleetcodecomproblemsrange-sum-of-bst)
    - [Solution](#solution-97)
  - [140\. Word Break II](#140-word-break-iihttpsleetcodecomproblemsword-break-ii)
    - [Solution](#solution-98)
  - [257\. Binary Tree Paths](#257-binary-tree-pathshttpsleetcodecomproblemsbinary-tree-paths)
    - [Solution](#solution-99)
  - [529\. Minesweeper](#529-minesweeperhttpsleetcodecomproblemsminesweeper)
    - [Solution](#solution-100)
  - [695\. Max Area of Island](#695-max-area-of-islandhttpsleetcodecomproblemsmax-area-of-island)
    - [Solution](#solution-101)
  - [129\. Sum Root to Leaf Numbers](#129-sum-root-to-leaf-numbershttpsleetcodecomproblemssum-root-to-leaf-numbers)
    - [Solution](#solution-102)
  - [111\. Minimum Depth of Binary Tree](#111-minimum-depth-of-binary-treehttpsleetcodecomproblemsminimum-depth-of-binary-tree)
    - [Solution](#solution-103)
  - [130\. Surrounded Regions :rainbow:](#130-surrounded-regions-rainbowhttpsleetcodecomproblemssurrounded-regions)
    - [Solution](#solution-104)
- [Backtracking](#backtracking)
  - [78\. Subsets](#78-subsetshttpsleetcodecomproblemssubsets)
    - [Solution](#solution-105)
  - [90\. Subsets II :fire:](#90-subsets-ii-firehttpsleetcodecomproblemssubsets-ii)
    - [Solution](#solution-106)
  - [22\. Generate Parentheses](#22-generate-parentheseshttpsleetcodecomproblemsgenerate-parentheses)
    - [Solution](#solution-107)
  - [79\. Word Search](#79-word-searchhttpsleetcodecomproblemsword-search)
    - [Solution](#solution-108)
  - [93\. Restore IP Addresses](#93-restore-ip-addresseshttpsleetcodecomproblemsrestore-ip-addresses)
    - [Solution](#solution-109)
  - [46\. Permutations](#46-permutationshttpsleetcodecomproblemspermutations)
    - [Solution](#solution-110)
  - [47\. Permutations II :fire:](#47-permutations-ii-firehttpsleetcodecomproblemspermutations-ii)
    - [Solution](#solution-111)
  - [17\. Letter Combinations of a Phone Number](#17-letter-combinations-of-a-phone-numberhttpsleetcodecomproblemsletter-combinations-of-a-phone-number)
    - [Solution](#solution-112)
  - [39\. Combination Sum](#39-combination-sumhttpsleetcodecomproblemscombination-sum)
    - [Solution](#solution-113)
  - [40\. Combination Sum II](#40-combination-sum-iihttpsleetcodecomproblemscombination-sum-ii)
    - [Solution](#solution-114)
  - [254\. Factor Combinations](#254-factor-combinationshttpsleetcodecomproblemsfactor-combinations)
    - [Solution](#solution-115)
  - [37\. Sudoku Solver :fire:](#37-sudoku-solver-firehttpsleetcodecomproblemssudoku-solver)
    - [Solution](#solution-116)
  - [1774\. Closest Dessert Cost](#1774-closest-dessert-costhttpsleetcodecomproblemsclosest-dessert-cost)
    - [Solution](#solution-117)
  - [131\. Palindrome Partitioning](#131-palindrome-partitioninghttpsleetcodecomproblemspalindrome-partitioning)
    - [Solution](#solution-118)
  - [1849\. Splitting a String Into Descending Consecutive Values](#1849-splitting-a-string-into-descending-consecutive-valueshttpsleetcodecomproblemssplitting-a-string-into-descending-consecutive-values)
    - [Solution](#solution-119)
  - [698\. Partition to K Equal Sum Subsets :fire:](#698-partition-to-k-equal-sum-subsets-firehttpsleetcodecomproblemspartition-to-k-equal-sum-subsets)
    - [Solution](#solution-120)
  - [332\. Reconstruct Itinerary :rainbow:](#332-reconstruct-itinerary-rainbowhttpsleetcodecomproblemsreconstruct-itinerary)
    - [Solution](#solution-121)
  - [1239\. Maximum Length of a Concatenated String with Unique Characters](#1239-maximum-length-of-a-concatenated-string-with-unique-charactershttpsleetcodecomproblemsmaximum-length-of-a-concatenated-string-with-unique-characters)
    - [Solution](#solution-122)
  - [77\. Combinations](#77-combinationshttpsleetcodecomproblemscombinations)
    - [Solution](#solution-123)
  - [51\. N-Queens :fire:](#51-n-queens-firehttpsleetcodecomproblemsn-queens)
    - [Solution](#solution-124)
- [Dynamic Programming](#dynamic-programming)
  - [139\. Word Break](#139-word-breakhttpsleetcodecomproblemsword-break)
    - [Solution](#solution-125)
  - [10\. Regular Expression Matching](#10-regular-expression-matchinghttpsleetcodecomproblemsregular-expression-matching)
    - [Solution](#solution-126)
  - [121\. Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stockhttpsleetcodecomproblemsbest-time-to-buy-and-sell-stock)
    - [Solution](#solution-127)
  - [188\. Best Time to Buy and Sell Stock IV :fire:](#188-best-time-to-buy-and-sell-stock-iv-firehttpsleetcodecomproblemsbest-time-to-buy-and-sell-stock-iv)
    - [Solution](#solution-128)
  - [91\. Decode Ways :rainbow:](#91-decode-ways-rainbowhttpsleetcodecomproblemsdecode-ways)
    - [Solution](#solution-129)
  - [1027\. Longest Arithmetic Subsequence :fire:](#1027-longest-arithmetic-subsequence-firehttpsleetcodecomproblemslongest-arithmetic-subsequence)
    - [Solution](#solution-130)
  - [647\. Palindromic Substrings :fire:](#647-palindromic-substrings-firehttpsleetcodecomproblemspalindromic-substrings)
    - [Solution](#solution-131)
  - [416\. Partition Equal Subset Sum](#416-partition-equal-subset-sumhttpsleetcodecomproblemspartition-equal-subset-sum)
    - [Solution](#solution-132)
  - [53\. Maximum Subarray](#53-maximum-subarrayhttpsleetcodecomproblemsmaximum-subarray)
    - [Solution](#solution-133)
  - [5\. Longest Palindromic Substring :rainbow:](#5-longest-palindromic-substring-rainbowhttpsleetcodecomproblemslongest-palindromic-substring)
    - [Solution](#solution-134)
  - [44\. Wildcard Matching :rainbow:](#44-wildcard-matching-rainbowhttpsleetcodecomproblemswildcard-matching)
    - [Solution](#solution-135)
  - [72\. Edit Distance :rainbow:](#72-edit-distance-rainbowhttpsleetcodecomproblemsedit-distance)
    - [Solution](#solution-136)
  - [70\. Climbing Stairs](#70-climbing-stairshttpsleetcodecomproblemsclimbing-stairs)
    - [Solution](#solution-137)
  - [746\. Min Cost Climbing Stairs](#746-min-cost-climbing-stairshttpsleetcodecomproblemsmin-cost-climbing-stairs)
    - [Solution](#solution-138)
  - [256\. Paint House](#256-paint-househttpsleetcodecomproblemspaint-house)
    - [Solution](#solution-139)
  - [265\. Paint House II](#265-paint-house-iihttpsleetcodecomproblemspaint-house-ii)
    - [Solution](#solution-140)
  - [516\. Longest Palindromic Subsequence :rainbow:](#516-longest-palindromic-subsequence-rainbowhttpsleetcodecomproblemslongest-palindromic-subsequence)
    - [Solution](#solution-141)
  - [322\. Coin Change :fire:](#322-coin-change-firehttpsleetcodecomproblemscoin-change)
    - [Solution](#solution-142)
  - [518\. Coin Change 2 :fire:](#518-coin-change-2-firehttpsleetcodecomproblemscoin-change-2)
    - [Solution](#solution-143)
  - [377\. Combination Sum IV](#377-combination-sum-ivhttpsleetcodecomproblemscombination-sum-iv)
    - [Solution](#solution-144)
  - [718\. Maximum Length of Repeated Subarray](#718-maximum-length-of-repeated-subarrayhttpsleetcodecomproblemsmaximum-length-of-repeated-subarray)
    - [Solution](#solution-145)
  - [1143\. Longest Common Subsequence :rainbow:](#1143-longest-common-subsequence-rainbowhttpsleetcodecomproblemslongest-common-subsequence)
    - [Solution](#solution-146)
  - [983\. Minimum Cost For Tickets :rainbow:](#983-minimum-cost-for-tickets-rainbowhttpsleetcodecomproblemsminimum-cost-for-tickets)
    - [Solution](#solution-147)
  - [213\. House Robber II](#213-house-robber-iihttpsleetcodecomproblemshouse-robber-ii)
    - [Solution](#solution-148)
  - [96\. Unique Binary Search Trees :fire:](#96-unique-binary-search-trees-firehttpsleetcodecomproblemsunique-binary-search-trees)
    - [Solution](#solution-149)
  - [740\. Delete and Earn](#740-delete-and-earnhttpsleetcodecomproblemsdelete-and-earn)
    - [Solution](#solution-150)
  - [343\. Integer Break](#343-integer-breakhttpsleetcodecomproblemsinteger-break)
    - [Solution](#solution-151)
  - [673\. Number of Longest Increasing Subsequence :fire:](#673-number-of-longest-increasing-subsequence-firehttpsleetcodecomproblemsnumber-of-longest-increasing-subsequence)
    - [Solution](#solution-152)
  - [97\. Interleaving String :rainbow:](#97-interleaving-string-rainbowhttpsleetcodecomproblemsinterleaving-string)
    - [Solution](#solution-153)
  - [115\. Distinct Subsequences :rainbow:](#115-distinct-subsequences-rainbowhttpsleetcodecomproblemsdistinct-subsequences)
    - [Solution](#solution-154)
  - [312\. Burst Balloons :fire:](#312-burst-balloons-firehttpsleetcodecomproblemsburst-balloons)
    - [Solution](#solution-155)
  - [894\. All Possible Full Binary Trees :rainbow:](#894-all-possible-full-binary-trees-rainbowhttpsleetcodecomproblemsall-possible-full-binary-trees)
    - [Solution](#solution-156)
  - [935\. Knight Dialer :fire:](#935-knight-dialer-firehttpsleetcodecomproblemsknight-dialer)
    - [Solution](#solution-157)
- [Divide and Conquer](#divide-and-conquer)
  - [282\. Expression Add Operators](#282-expression-add-operatorshttpsleetcodecomproblemsexpression-add-operators)
    - [Solution](#solution-158)
  - [4\. Median of Two Sorted Arrays](#4-median-of-two-sorted-arrayshttpsleetcodecomproblemsmedian-of-two-sorted-arrays-1)
    - [Solution](#solution-159)
- [Recursion](#recursion)
  - [247\. Strobogrammatic Number II](#247-strobogrammatic-number-iihttpsleetcodecomproblemsstrobogrammatic-number-ii)
    - [Solution](#solution-160)
  - [341\. Flatten Nested List Iterator](#341-flatten-nested-list-iteratorhttpsleetcodecomproblemsflatten-nested-list-iterator)
    - [Solution](#solution-161)
  - [50\. Pow(x, n)](#50-powx-nhttpsleetcodecomproblemspowx-n-1)
    - [Solution](#solution-162)
  - [486\. Predict the Winner :rainbow:](#486-predict-the-winner-rainbowhttpsleetcodecomproblemspredict-the-winner)
    - [Solution](#solution-163)
  - [18\. 4Sum :fire:](#18-4sum-firehttpsleetcodecomproblems4sum)
    - [Solution](#solution-164)
- [Memoization](#memoization)
  - [494\. Target Sum :rainbow:](#494-target-sum-rainbowhttpsleetcodecomproblemstarget-sum)
    - [Solution](#solution-165)
  - [464\. Can I Win](#464-can-i-winhttpsleetcodecomproblemscan-i-win)
    - [Solution](#solution-166)
  - [688\. Knight Probability in Chessboard](#688-knight-probability-in-chessboardhttpsleetcodecomproblemsknight-probability-in-chessboard)
    - [Solution](#solution-167)
  - [329\. Longest Increasing Path in a Matrix :rainbow:](#329-longest-increasing-path-in-a-matrix-rainbowhttpsleetcodecomproblemslongest-increasing-path-in-a-matrix)
    - [Solution](#solution-168)
  - [1463\. Cherry Pickup II](#1463-cherry-pickup-iihttpsleetcodecomproblemscherry-pickup-ii)
    - [Solution](#solution-169)
  - [1770\. Maximum Score from Performing Multiplication Operations](#1770-maximum-score-from-performing-multiplication-operationshttpsleetcodecomproblemsmaximum-score-from-performing-multiplication-operations)
    - [Solution](#solution-170)
  - [120\. Triangle](#120-trianglehttpsleetcodecomproblemstriangle)
    - [Solution](#solution-171)
  - [309\. Best Time to Buy and Sell Stock with Cooldown :rainbow:](#309-best-time-to-buy-and-sell-stock-with-cooldown-rainbowhttpsleetcodecomproblemsbest-time-to-buy-and-sell-stock-with-cooldown)
    - [Solution](#solution-172)
  - [1911\. Maximum Alternating Subsequence Sum](#1911-maximum-alternating-subsequence-sumhttpsleetcodecomproblemsmaximum-alternating-subsequence-sum)
    - [Solution](#solution-173)
  - [1553\. Minimum Number of Days to Eat N Oranges](#1553-minimum-number-of-days-to-eat-n-orangeshttpsleetcodecomproblemsminimum-number-of-days-to-eat-n-oranges)
    - [Solution](#solution-174)
- [Math](#math)
  - [273\. Integer to English Words :rainbow:](#273-integer-to-english-words-rainbowhttpsleetcodecomproblemsinteger-to-english-words)
    - [Solution](#solution-175)
  - [67\. Add Binary](#67-add-binaryhttpsleetcodecomproblemsadd-binary)
    - [Solution](#solution-176)
  - [65\. Valid Number](#65-valid-numberhttpsleetcodecomproblemsvalid-number)
    - [Solution](#solution-177)
  - [398\. Random Pick Index](#398-random-pick-indexhttpsleetcodecomproblemsrandom-pick-index)
    - [Solution](#solution-178)
  - [43\. Multiply Strings](#43-multiply-stringshttpsleetcodecomproblemsmultiply-strings)
    - [Solution](#solution-179)
  - [319\. Bulb Switcher](#319-bulb-switcherhttpsleetcodecomproblemsbulb-switcher)
    - [Solution](#solution-180)
  - [470\. Implement Rand10() Using Rand7()](#470-implement-rand10-using-rand7httpsleetcodecomproblemsimplement-rand10-using-rand7)
    - [Solution](#solution-181)
  - [149\. Max Points on a Line](#149-max-points-on-a-linehttpsleetcodecomproblemsmax-points-on-a-line)
    - [Solution](#solution-182)
  - [7\. Reverse Integer](#7-reverse-integerhttpsleetcodecomproblemsreverse-integer)
    - [Solution](#solution-183)
  - [1344\. Angle Between Hands of a Clock](#1344-angle-between-hands-of-a-clockhttpsleetcodecomproblemsangle-between-hands-of-a-clock)
    - [Solution](#solution-184)
  - [12\. Integer to Roman](#12-integer-to-romanhttpsleetcodecomproblemsinteger-to-roman)
    - [Solution](#solution-185)
  - [13\. Roman to Integer](#13-roman-to-integerhttpsleetcodecomproblemsroman-to-integer)
    - [Solution](#solution-186)
  - [231\. Power of Two](#231-power-of-twohttpsleetcodecomproblemspower-of-two)
    - [Solution](#solution-187)
  - [1041\. Robot Bounded In Circle](#1041-robot-bounded-in-circlehttpsleetcodecomproblemsrobot-bounded-in-circle)
    - [Solution](#solution-188)
  - [2013\. Detect Squares :rainbow:](#2013-detect-squares-rainbowhttpsleetcodecomproblemsdetect-squares)
    - [Solution](#solution-189)
  - [939\. Minimum Area Rectangle](#939-minimum-area-rectanglehttpsleetcodecomproblemsminimum-area-rectangle)
    - [Solution](#solution-190)
- [Bit Manipulation](#bit-manipulation)
  - [136\. Single Number](#136-single-numberhttpsleetcodecomproblemssingle-number)
    - [Solution](#solution-191)
  - [2002\. Maximum Product of the Length of Two Palindromic Subsequences :fire:](#2002-maximum-product-of-the-length-of-two-palindromic-subsequences-firehttpsleetcodecomproblemsmaximum-product-of-the-length-of-two-palindromic-subsequences)
    - [Solution](#solution-192)
- [Array](#array)
  - [238\. Product of Array Except Self](#238-product-of-array-except-selfhttpsleetcodecomproblemsproduct-of-array-except-self)
    - [Solution](#solution-193)
  - [31\. Next Permutation](#31-next-permutationhttpsleetcodecomproblemsnext-permutation)
    - [Solution](#solution-194)
  - [56\. Merge Intervals](#56-merge-intervalshttpsleetcodecomproblemsmerge-intervals)
    - [Solution](#solution-195)
  - [304\. Range Sum Query 2D - Immutable](#304-range-sum-query-2d-immutablehttpsleetcodecomproblemsrange-sum-query-2d-immutable)
    - [Solution](#solution-196)
  - [1428\. Leftmost Column with at Least a One](#1428-leftmost-column-with-at-least-a-onehttpsleetcodecomproblemsleftmost-column-with-at-least-a-one)
    - [Solution](#solution-197)
  - [896\. Monotonic Array](#896-monotonic-arrayhttpsleetcodecomproblemsmonotonic-array)
    - [Solution](#solution-198)
  - [42\. Trapping Rain Water](#42-trapping-rain-waterhttpsleetcodecomproblemstrapping-rain-water)
    - [Solution](#solution-199)
  - [670\. Maximum Swap :rainbow:](#670-maximum-swap-rainbowhttpsleetcodecomproblemsmaximum-swap)
    - [Solution](#solution-200)
  - [348\. Design Tic-Tac-Toe :rainbow:](#348-design-tic-tac-toe-rainbowhttpsleetcodecomproblemsdesign-tic-tac-toe)
    - [Solution](#solution-201)
  - [419\. Battleships in a Board](#419-battleships-in-a-boardhttpsleetcodecomproblemsbattleships-in-a-board)
    - [Solution](#solution-202)
  - [498\. Diagonal Traverse](#498-diagonal-traversehttpsleetcodecomproblemsdiagonal-traverse)
    - [Solution](#solution-203)
  - [766\. Toeplitz Matrix](#766-toeplitz-matrixhttpsleetcodecomproblemstoeplitz-matrix)
    - [Solution](#solution-204)
  - [674\. Longest Continuous Increasing Subsequence](#674-longest-continuous-increasing-subsequencehttpsleetcodecomproblemslongest-continuous-increasing-subsequence)
    - [Solution](#solution-205)
  - [73\. Set Matrix Zeroes](#73-set-matrix-zeroeshttpsleetcodecomproblemsset-matrix-zeroes)
    - [Solution](#solution-206)
  - [152\. Maximum Product Subarray](#152-maximum-product-subarrayhttpsleetcodecomproblemsmaximum-product-subarray)
    - [Solution](#solution-207)
  - [605\. Can Place Flowers](#605-can-place-flowershttpsleetcodecomproblemscan-place-flowers)
    - [Solution](#solution-208)
  - [361\. Bomb Enemy :fire:](#361-bomb-enemy-firehttpsleetcodecomproblemsbomb-enemy)
    - [Solution](#solution-209)
  - [289\. Game of Life :fire:](#289-game-of-life-firehttpsleetcodecomproblemsgame-of-life)
    - [Solution](#solution-210)
  - [54\. Spiral Matrix](#54-spiral-matrixhttpsleetcodecomproblemsspiral-matrix)
    - [Solution](#solution-211)
  - [36\. Valid Sudoku](#36-valid-sudokuhttpsleetcodecomproblemsvalid-sudoku)
    - [Solution](#solution-212)
  - [228\. Summary Ranges](#228-summary-rangeshttpsleetcodecomproblemssummary-ranges)
    - [Solution](#solution-213)
  - [2006\. Count Number of Pairs With Absolute Difference K](#2006-count-number-of-pairs-with-absolute-difference-khttpsleetcodecomproblemscount-number-of-pairs-with-absolute-difference-k)
    - [Solution](#solution-214)
  - [2017\. Grid Game](#2017-grid-gamehttpsleetcodecomproblemsgrid-game)
    - [Solution](#solution-215)
- [Queue](#queue)
  - [239\. Sliding Window Maximum :rainbow:](#239-sliding-window-maximum-rainbowhttpsleetcodecomproblemssliding-window-maximum)
    - [Solution](#solution-216)
  - [1696\. Jump Game VI :fire:](#1696-jump-game-vi-firehttpsleetcodecomproblemsjump-game-vi)
    - [Solution](#solution-217)
  - [362\. Design Hit Counter :rainbow:](#362-design-hit-counter-rainbowhttpsleetcodecomproblemsdesign-hit-counter)
    - [Solution](#solution-218)
  - [379\. Design Phone Directory :rainbow:](#379-design-phone-directory-rainbowhttpsleetcodecomproblemsdesign-phone-directory)
    - [Solution](#solution-219)
- [Stack](#stack)
  - [1249\. Minimum Remove to Make Valid Parentheses](#1249-minimum-remove-to-make-valid-parentheseshttpsleetcodecomproblemsminimum-remove-to-make-valid-parentheses)
    - [Solution](#solution-220)
  - [636\. Exclusive Time of Functions](#636-exclusive-time-of-functionshttpsleetcodecomproblemsexclusive-time-of-functions)
    - [Solution](#solution-221)
  - [71\. Simplify Path](#71-simplify-pathhttpsleetcodecomproblemssimplify-path)
    - [Solution](#solution-222)
  - [227\. Basic Calculator II](#227-basic-calculator-iihttpsleetcodecomproblemsbasic-calculator-ii)
    - [Solution](#solution-223)
  - [20\. Valid Parentheses](#20-valid-parentheseshttpsleetcodecomproblemsvalid-parentheses)
    - [Solution](#solution-224)
  - [921\. Minimum Add to Make Parentheses Valid](#921-minimum-add-to-make-parentheses-validhttpsleetcodecomproblemsminimum-add-to-make-parentheses-valid)
    - [Solution](#solution-225)
  - [32\. Longest Valid Parentheses](#32-longest-valid-parentheseshttpsleetcodecomproblemslongest-valid-parentheses)
    - [Solution](#solution-226)
  - [224\. Basic Calculator :fire:](#224-basic-calculator-firehttpsleetcodecomproblemsbasic-calculator)
    - [Solution](#solution-227)
  - [394\. Decode String](#394-decode-stringhttpsleetcodecomproblemsdecode-string)
    - [Solution](#solution-228)
  - [155\. Min Stack](#155-min-stackhttpsleetcodecomproblemsmin-stack)
    - [Solution](#solution-229)
  - [716\. Max Stack](#716-max-stackhttpsleetcodecomproblemsmax-stack)
    - [Solution](#solution-230)
  - [388\. Longest Absolute File Path :rainbow:](#388-longest-absolute-file-path-rainbowhttpsleetcodecomproblemslongest-absolute-file-path)
    - [Solution](#solution-231)
  - [84\. Largest Rectangle in Histogram :fire:](#84-largest-rectangle-in-histogram-firehttpsleetcodecomproblemslargest-rectangle-in-histogram)
    - [Solution](#solution-232)
  - [85\. Maximal Rectangle :rainbow:](#85-maximal-rectangle-rainbowhttpsleetcodecomproblemsmaximal-rectangle)
    - [Solution](#solution-233)
  - [1472\. Design Browser History](#1472-design-browser-historyhttpsleetcodecomproblemsdesign-browser-history)
    - [Solution](#solution-234)
  - [1209\. Remove All Adjacent Duplicates in String II](#1209-remove-all-adjacent-duplicates-in-string-iihttpsleetcodecomproblemsremove-all-adjacent-duplicates-in-string-ii)
    - [Solution](#solution-235)
  - [1047\. Remove All Adjacent Duplicates In String](#1047-remove-all-adjacent-duplicates-in-stringhttpsleetcodecomproblemsremove-all-adjacent-duplicates-in-string)
    - [Solution](#solution-236)
  - [150\. Evaluate Reverse Polish Notation](#150-evaluate-reverse-polish-notationhttpsleetcodecomproblemsevaluate-reverse-polish-notation)
    - [Solution](#solution-237)
  - [1475\. Final Prices With a Special Discount in a Shop](#1475-final-prices-with-a-special-discount-in-a-shophttpsleetcodecomproblemsfinal-prices-with-a-special-discount-in-a-shop)
    - [Solution](#solution-238)
  - [735\. Asteroid Collision :rainbow:](#735-asteroid-collision-rainbowhttpsleetcodecomproblemsasteroid-collision)
    - [Solution](#solution-239)
  - [739\. Daily Temperatures](#739-daily-temperatureshttpsleetcodecomproblemsdaily-temperatures)
    - [Solution](#solution-240)
  - [853\. Car Fleet :rainbow:](#853-car-fleet-rainbowhttpsleetcodecomproblemscar-fleet)
    - [Solution](#solution-241)
- [Heap](#heap)
  - [973\. K Closest Points to Origin](#973-k-closest-points-to-originhttpsleetcodecomproblemsk-closest-points-to-origin)
    - [Solution](#solution-242)
  - [253\. Meeting Rooms II](#253-meeting-rooms-iihttpsleetcodecomproblemsmeeting-rooms-ii)
    - [Solution](#solution-243)
  - [347\. Top K Frequent Elements :fire:](#347-top-k-frequent-elements-firehttpsleetcodecomproblemstop-k-frequent-elements)
    - [Solution](#solution-244)
  - [378\. Kth Smallest Element in a Sorted Matrix :fire:](#378-kth-smallest-element-in-a-sorted-matrix-firehttpsleetcodecomproblemskth-smallest-element-in-a-sorted-matrix)
    - [Solution](#solution-245)
  - [692\. Top K Frequent Words](#692-top-k-frequent-wordshttpsleetcodecomproblemstop-k-frequent-words)
    - [Solution](#solution-246)
  - [295\. Find Median from Data Stream](#295-find-median-from-data-streamhttpsleetcodecomproblemsfind-median-from-data-stream)
    - [Solution](#solution-247)
  - [373\. Find K Pairs with Smallest Sums](#373-find-k-pairs-with-smallest-sumshttpsleetcodecomproblemsfind-k-pairs-with-smallest-sums)
    - [Solution](#solution-248)
  - [407\. Trapping Rain Water II :fire:](#407-trapping-rain-water-ii-firehttpsleetcodecomproblemstrapping-rain-water-ii)
    - [Solution](#solution-249)
  - [759\. Employee Free Time :fire:](#759-employee-free-time-firehttpsleetcodecomproblemsemployee-free-timedescription)
    - [Solution](#solution-250)
  - [1845\. Seat Reservation Manager](#1845-seat-reservation-managerhttpsleetcodecomproblemsseat-reservation-manager)
    - [Solution](#solution-251)
  - [703\. Kth Largest Element in a Stream](#703-kth-largest-element-in-a-streamhttpsleetcodecomproblemskth-largest-element-in-a-stream)
    - [Solution](#solution-252)
  - [846\. Hand of Straights :fire:](#846-hand-of-straights-firehttpsleetcodecomproblemshand-of-straights)
    - [Solution](#solution-253)
  - [1882\. Process Tasks Using Servers :rainbow:](#1882-process-tasks-using-servers-rainbowhttpsleetcodecomproblemsprocess-tasks-using-servers)
    - [Solution](#solution-254)
- [Hash Table](#hash-table)
  - [953\. Verifying an Alien Dictionary](#953-verifying-an-alien-dictionaryhttpsleetcodecomproblemsverifying-an-alien-dictionary)
    - [Solution](#solution-255)
  - [560\. Subarray Sum Equals K :rainbow:](#560-subarray-sum-equals-k-rainbowhttpsleetcodecomproblemssubarray-sum-equals-k)
    - [Solution](#solution-256)
  - [523\. Continuous Subarray Sum](#523-continuous-subarray-sumhttpsleetcodecomproblemscontinuous-subarray-sum)
    - [Solution](#solution-257)
  - [349\. Intersection of Two Arrays](#349-intersection-of-two-arrayshttpsleetcodecomproblemsintersection-of-two-arrays)
    - [Solution](#solution-258)
  - [311\. Sparse Matrix Multiplication](#311-sparse-matrix-multiplicationhttpsleetcodecomproblemssparse-matrix-multiplication)
    - [Solution](#solution-259)
  - [380\. Insert Delete GetRandom O(1)](#380-insert-delete-getrandom-o1httpsleetcodecomproblemsinsert-delete-getrandom-o1)
    - [Solution](#solution-260)
  - [381\. Insert Delete GetRandom O(1) - Duplicates allowed](#381-insert-delete-getrandom-o1-duplicates-allowedhttpsleetcodecomproblemsinsert-delete-getrandom-o1-duplicates-allowed)
    - [Solution](#solution-261)
  - [249\. Group Shifted Strings](#249-group-shifted-stringshttpsleetcodecomproblemsgroup-shifted-strings)
    - [Solution](#solution-262)
  - [246\. Strobogrammatic Number](#246-strobogrammatic-numberhttpsleetcodecomproblemsstrobogrammatic-number)
    - [Solution](#solution-263)
  - [350\. Intersection of Two Arrays II](#350-intersection-of-two-arrays-iihttpsleetcodecomproblemsintersection-of-two-arrays-ii)
    - [Solution](#solution-264)
  - [1\. Two Sum](#1-two-sumhttpsleetcodecomproblemstwo-sum)
    - [Solution](#solution-265)
  - [325\. Maximum Size Subarray Sum Equals k](#325-maximum-size-subarray-sum-equals-khttpsleetcodecomproblemsmaximum-size-subarray-sum-equals-k)
    - [Solution](#solution-266)
  - [1570\. Dot Product of Two Sparse Vectors](#1570-dot-product-of-two-sparse-vectorshttpsleetcodecomproblemsdot-product-of-two-sparse-vectors)
    - [Solution](#solution-267)
  - [49\. Group Anagrams](#49-group-anagramshttpsleetcodecomproblemsgroup-anagrams)
    - [Solution](#solution-268)
  - [187\. Repeated DNA Sequences](#187-repeated-dna-sequenceshttpsleetcodecomproblemsrepeated-dna-sequences)
    - [Solution](#solution-269)
  - [205\. Isomorphic Strings](#205-isomorphic-stringshttpsleetcodecomproblemsisomorphic-strings)
    - [Solution](#solution-270)
  - [609\. Find Duplicate File in System](#609-find-duplicate-file-in-systemhttpsleetcodecomproblemsfind-duplicate-file-in-system)
    - [Solution](#solution-271)
  - [423\. Reconstruct Original Digits from English](#423-reconstruct-original-digits-from-englishhttpsleetcodecomproblemsreconstruct-original-digits-from-english)
    - [Solution](#solution-272)
  - [1807\. Evaluate the Bracket Pairs of a String](#1807-evaluate-the-bracket-pairs-of-a-stringhttpsleetcodecomproblemsevaluate-the-bracket-pairs-of-a-string)
    - [Solution](#solution-273)
  - [1248\. Count Number of Nice Subarrays :fire:](#1248-count-number-of-nice-subarrays-firehttpsleetcodecomproblemscount-number-of-nice-subarrays)
    - [Solution](#solution-274)
  - [554\. Brick Wall](#554-brick-wallhttpsleetcodecomproblemsbrick-wall)
    - [Solution](#solution-275)
  - [1189\. Maximum Number of Balloons :rainbow:](#1189-maximum-number-of-balloons-rainbowhttpsleetcodecomproblemsmaximum-number-of-balloons)
    - [Solution](#solution-276)
  - [1930\. Unique Length-3 Palindromic Subsequences :fire:](#1930-unique-length-3-palindromic-subsequences-firehttpsleetcodecomproblemsunique-length-3-palindromic-subsequences)
    - [Solution](#solution-277)
- [Sliding Window](#sliding-window)
  - [438\. Find All Anagrams in a String](#438-find-all-anagrams-in-a-stringhttpsleetcodecomproblemsfind-all-anagrams-in-a-string)
    - [Solution](#solution-278)
  - [76\. Minimum Window Substring :rainbow:](#76-minimum-window-substring-rainbowhttpsleetcodecomproblemsminimum-window-substring)
    - [Solution](#solution-279)
  - [340\. Longest Substring with At Most K Distinct Characters](#340-longest-substring-with-at-most-k-distinct-charactershttpsleetcodecomproblemslongest-substring-with-at-most-k-distinct-characters)
    - [Solution](#solution-280)
  - [1004\. Max Consecutive Ones III](#1004-max-consecutive-ones-iiihttpsleetcodecomproblemsmax-consecutive-ones-iii)
    - [Solution](#solution-281)
  - [3\. Longest Substring Without Repeating Characters :rainbow:](#3-longest-substring-without-repeating-characters-rainbowhttpsleetcodecomproblemslongest-substring-without-repeating-characters)
    - [Solution](#solution-282)
  - [567\. Permutation in String](#567-permutation-in-stringhttpsleetcodecomproblemspermutation-in-string)
    - [Solution](#solution-283)
  - [209\. Minimum Size Subarray Sum](#209-minimum-size-subarray-sumhttpsleetcodecomproblemsminimum-size-subarray-sum)
    - [Solution](#solution-284)
  - [424\. Longest Repeating Character Replacement](#424-longest-repeating-character-replacementhttpsleetcodecomproblemslongest-repeating-character-replacement)
    - [Solution](#solution-285)
  - [713\. Subarray Product Less Than K](#713-subarray-product-less-than-khttpsleetcodecomproblemssubarray-product-less-than-k)
    - [Solution](#solution-286)
  - [1838\. Frequency of the Most Frequent Element :fire:](#1838-frequency-of-the-most-frequent-element-firehttpsleetcodecomproblemsfrequency-of-the-most-frequent-element)
    - [Solution](#solution-287)
  - [1423\. Maximum Points You Can Obtain from Cards :rainbow:](#1423-maximum-points-you-can-obtain-from-cards-rainbowhttpsleetcodecomproblemsmaximum-points-you-can-obtain-from-cards)
    - [Solution](#solution-288)
- [String](#string)
  - [680\. Valid Palindrome II :rainbow:](#680-valid-palindrome-ii-rainbowhttpsleetcodecomproblemsvalid-palindrome-ii)
    - [Solution](#solution-289)
  - [157\. Read N Characters Given Read4](#157-read-n-characters-given-read4httpsleetcodecomproblemsread-n-characters-given-read4)
    - [Solution](#solution-290)
  - [158\. Read N Characters Given read4 II - Call Multiple Times](#158-read-n-characters-given-read4-ii-call-multiple-timeshttpsleetcodecomproblemsread-n-characters-given-read4-ii-call-multiple-times)
    - [Solution](#solution-291)
  - [415\. Add Strings](#415-add-stringshttpsleetcodecomproblemsadd-strings)
    - [Solution](#solution-292)
  - [161\. One Edit Distance](#161-one-edit-distancehttpsleetcodecomproblemsone-edit-distance)
    - [Solution](#solution-293)
  - [8\. String to Integer (atoi)](#8-string-to-integer-atoihttpsleetcodecomproblemsstring-to-integer-atoi)
    - [Solution](#solution-294)
  - [678\. Valid Parenthesis String](#678-valid-parenthesis-stringhttpsleetcodecomproblemsvalid-parenthesis-string)
    - [Solution](#solution-295)
  - [468\. Validate IP Address](#468-validate-ip-addresshttpsleetcodecomproblemsvalidate-ip-address)
    - [Solution](#solution-296)
  - [151\. Reverse Words in a String](#151-reverse-words-in-a-stringhttpsleetcodecomproblemsreverse-words-in-a-string)
    - [Solution](#solution-297)
  - [38\. Count and Say](#38-count-and-sayhttpsleetcodecomproblemscount-and-say)
    - [Solution](#solution-298)
  - [68\. Text Justification :rainbow:](#68-text-justification-rainbowhttpsleetcodecomproblemstext-justification)
    - [Solution](#solution-299)
  - [1541\. Minimum Insertions to Balance a Parentheses String](#1541-minimum-insertions-to-balance-a-parentheses-stringhttpsleetcodecomproblemsminimum-insertions-to-balance-a-parentheses-string)
    - [Solution](#solution-300)
  - [418\. Sentence Screen Fitting :fire:](#418-sentence-screen-fitting-firehttpsleetcodecomproblemssentence-screen-fitting)
    - [Solution](#solution-301)
  - [833\. Find And Replace in String](#833-find-and-replace-in-stringhttpsleetcodecomproblemsfind-and-replace-in-string)
    - [Solution](#solution-302)
  - [271\. Encode and Decode Strings](#271-encode-and-decode-stringshttpsleetcodecomproblemsencode-and-decode-strings)
    - [Solution](#solution-303)
  - [811\. Subdomain Visit Count](#811-subdomain-visit-counthttpsleetcodecomproblemssubdomain-visit-count)
    - [Solution](#solution-304)
  - [635\. Design Log Storage System :rainbow:](#635-design-log-storage-system-rainbowhttpsleetcodecomproblemsdesign-log-storage-system)
    - [Solution](#solution-305)
- [Linked List](#linked-list)
  - [23\. Merge k Sorted Lists :rainbow:](#23-merge-k-sorted-lists-rainbowhttpsleetcodecomproblemsmerge-k-sorted-lists)
    - [Solution](#solution-306)
  - [143\. Reorder List :fire:](#143-reorder-list-firehttpsleetcodecomproblemsreorder-list)
    - [Solution](#solution-307)
  - [146\. LRU Cache :fire:](#146-lru-cache-firehttpsleetcodecomproblemslru-cache)
    - [Solution](#solution-308)
  - [138\. Copy List with Random Pointer](#138-copy-list-with-random-pointerhttpsleetcodecomproblemscopy-list-with-random-pointer)
    - [Solution](#solution-309)
  - [114\. Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-listhttpsleetcodecomproblemsflatten-binary-tree-to-linked-list)
    - [Solution](#solution-310)
  - [206\. Reverse Linked List](#206-reverse-linked-listhttpsleetcodecomproblemsreverse-linked-list)
    - [Solution](#solution-311)
  - [160\. Intersection of Two Linked Lists](#160-intersection-of-two-linked-listshttpsleetcodecomproblemsintersection-of-two-linked-lists)
    - [Solution](#solution-312)
  - [61\. Rotate List](#61-rotate-listhttpsleetcodecomproblemsrotate-list)
    - [Solution](#solution-313)
  - [706\. Design HashMap](#706-design-hashmaphttpsleetcodecomproblemsdesign-hashmap)
    - [Solution](#solution-314)
  - [21\. Merge Two Sorted Lists](#21-merge-two-sorted-listshttpsleetcodecomproblemsmerge-two-sorted-lists)
    - [Solution](#solution-315)
  - [237\. Delete Node in a Linked List](#237-delete-node-in-a-linked-listhttpsleetcodecomproblemsdelete-node-in-a-linked-list)
    - [Solution](#solution-316)
  - [141\. Linked List Cycle](#141-linked-list-cyclehttpsleetcodecomproblemslinked-list-cycle)
    - [Solution](#solution-317)
  - [445\. Add Two Numbers II](#445-add-two-numbers-iihttpsleetcodecomproblemsadd-two-numbers-ii)
    - [Solution](#solution-318)
- [Tree](#tree)
  - [297\. Serialize and Deserialize Binary Tree :rainbow:](#297-serialize-and-deserialize-binary-tree-rainbowhttpsleetcodecomproblemsserialize-and-deserialize-binary-tree)
    - [Solution](#solution-319)
  - [124\. Binary Tree Maximum Path Sum :fire:](#124-binary-tree-maximum-path-sum-firehttpsleetcodecomproblemsbinary-tree-maximum-path-sum)
    - [Solution](#solution-320)
  - [173\. Binary Search Tree Iterator](#173-binary-search-tree-iteratorhttpsleetcodecomproblemsbinary-search-tree-iterator)
    - [Solution](#solution-321)
  - [543\. Diameter of Binary Tree](#543-diameter-of-binary-treehttpsleetcodecomproblemsdiameter-of-binary-tree)
    - [Solution](#solution-322)
  - [235\. Lowest Common Ancestor of a Binary Search Tree](#235-lowest-common-ancestor-of-a-binary-search-treehttpsleetcodecomproblemslowest-common-ancestor-of-a-binary-search-tree)
    - [Solution](#solution-323)
  - [236\. Lowest Common Ancestor of a Binary Tree :rainbow:](#236-lowest-common-ancestor-of-a-binary-tree-rainbowhttpsleetcodecomproblemslowest-common-ancestor-of-a-binary-tree)
    - [Solution](#solution-324)
  - [1650\. Lowest Common Ancestor of a Binary Tree III](#1650-lowest-common-ancestor-of-a-binary-tree-iiihttpsleetcodecomproblemslowest-common-ancestor-of-a-binary-tree-iii)
    - [Solution](#solution-325)
  - [98\. Validate Binary Search Tree :rainbow:](#98-validate-binary-search-tree-rainbowhttpsleetcodecomproblemsvalidate-binary-search-tree)
    - [Solution](#solution-326)
  - [958\. Check Completeness of a Binary Tree](#958-check-completeness-of-a-binary-treehttpsleetcodecomproblemscheck-completeness-of-a-binary-tree)
    - [Solution](#solution-327)
  - [270\. Closest Binary Search Tree Value](#270-closest-binary-search-tree-valuehttpsleetcodecomproblemsclosest-binary-search-tree-value)
    - [Solution](#solution-328)
  - [1026\. Maximum Difference Between Node and Ancestor](#1026-maximum-difference-between-node-and-ancestorhttpsleetcodecomproblemsmaximum-difference-between-node-and-ancestor)
    - [Solution](#solution-329)
  - [449\. Serialize and Deserialize BST](#449-serialize-and-deserialize-bsthttpsleetcodecomproblemsserialize-and-deserialize-bst)
    - [Solution](#solution-330)
  - [105\. Construct Binary Tree from Preorder and Inorder Traversal](#105-construct-binary-tree-from-preorder-and-inorder-traversalhttpsleetcodecomproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal)
    - [Solution](#solution-331)
  - [100\. Same Tree](#100-same-treehttpsleetcodecomproblemssame-tree)
    - [Solution](#solution-332)
  - [671\. Second Minimum Node In a Binary Tree :rainbow:](#671-second-minimum-node-in-a-binary-tree-rainbowhttpsleetcodecomproblemssecond-minimum-node-in-a-binary-tree)
    - [Solution](#solution-333)
  - [366\. Find Leaves of Binary Tree :rainbow:](#366-find-leaves-of-binary-tree-rainbowhttpsleetcodecomproblemsfind-leaves-of-binary-tree)
    - [Solution](#solution-334)
  - [156\. Binary Tree Upside Down](#156-binary-tree-upside-downhttpsleetcodecomproblemsbinary-tree-upside-down)
    - [Solution](#solution-335)
  - [298\. Binary Tree Longest Consecutive Sequence](#298-binary-tree-longest-consecutive-sequencehttpsleetcodecomproblemsbinary-tree-longest-consecutive-sequence)
    - [Solution](#solution-336)
  - [101\. Symmetric Tree](#101-symmetric-treehttpsleetcodecomproblemssymmetric-tree)
    - [Solution](#solution-337)
  - [951\. Flip Equivalent Binary Trees](#951-flip-equivalent-binary-treeshttpsleetcodecomproblemsflip-equivalent-binary-trees)
    - [Solution](#solution-338)
  - [110\. Balanced Binary Tree](#110-balanced-binary-treehttpsleetcodecomproblemsbalanced-binary-tree)
    - [Solution](#solution-339)
  - [783\. Minimum Distance Between BST Nodes](#783-minimum-distance-between-bst-nodeshttpsleetcodecomproblemsminimum-distance-between-bst-nodes)
    - [Solution](#solution-340)
  - [450\. Delete Node in a BST :fire:](#450-delete-node-in-a-bst-firehttpsleetcodecomproblemsdelete-node-in-a-bst)
    - [Solution](#solution-341)
  - [701\. Insert into a Binary Search Tree](#701-insert-into-a-binary-search-treehttpsleetcodecomproblemsinsert-into-a-binary-search-tree)
    - [Solution](#solution-342)
  - [653\. Two Sum IV - Input is a BST](#653-two-sum-iv-input-is-a-bsthttpsleetcodecomproblemstwo-sum-iv-input-is-a-bst)
    - [Solution](#solution-343)
  - [337\. House Robber III :rainbow:](#337-house-robber-iii-rainbowhttpsleetcodecomproblemshouse-robber-iii)
    - [Solution](#solution-344)
  - [94\. Binary Tree Inorder Traversal :fire:](#94-binary-tree-inorder-traversal-firehttpsleetcodecomproblemsbinary-tree-inorder-traversal)
    - [Solution](#solution-345)
  - [95\. Unique Binary Search Trees II :fire:](#95-unique-binary-search-trees-ii-firehttpsleetcodecomproblemsunique-binary-search-trees-ii)
    - [Solution](#solution-346)
  - [144\. Binary Tree Preorder Traversal :fire:](#144-binary-tree-preorder-traversal-firehttpsleetcodecomproblemsbinary-tree-preorder-traversal)
    - [Solution](#solution-347)
  - [145\. Binary Tree Postorder Traversal :fire:](#145-binary-tree-postorder-traversal-firehttpsleetcodecomproblemsbinary-tree-postorder-traversal)
    - [Solution](#solution-348)
  - [1382\. Balance a Binary Search Tree :rainbow:](#1382-balance-a-binary-search-tree-rainbowhttpsleetcodecomproblemsbalance-a-binary-search-tree)
    - [Solution](#solution-349)
  - [104\. Maximum Depth of Binary Tree](#104-maximum-depth-of-binary-treehttpsleetcodecomproblemsmaximum-depth-of-binary-tree)
    - [Solution](#solution-350)
  - [572\. Subtree of Another Tree :rainbow:](#572-subtree-of-another-tree-rainbowhttpsleetcodecomproblemssubtree-of-another-tree)
    - [Solution](#solution-351)
  - [617\. Merge Two Binary Trees](#617-merge-two-binary-treeshttpsleetcodecomproblemsmerge-two-binary-trees)
    - [Solution](#solution-352)
  - [108\. Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-treehttpsleetcodecomproblemsconvert-sorted-array-to-binary-search-tree)
    - [Solution](#solution-353)
  - [669\. Trim a Binary Search Tree](#669-trim-a-binary-search-treehttpsleetcodecomproblemstrim-a-binary-search-tree)
    - [Solution](#solution-354)
  - [1448\. Count Good Nodes in Binary Tree](#1448-count-good-nodes-in-binary-treehttpsleetcodecomproblemscount-good-nodes-in-binary-tree)
    - [Solution](#solution-355)
- [Trie](#trie)
  - [211\. Design Add and Search Words Data Structure :rainbow:](#211-design-add-and-search-words-data-structure-rainbowhttpsleetcodecomproblemsdesign-add-and-search-words-data-structure)
    - [Solution](#solution-356)
  - [208\. Implement Trie (Prefix Tree)](#208-implement-trie-prefix-treehttpsleetcodecomproblemsimplement-trie-prefix-tree)
    - [Solution](#solution-357)
  - [212\. Word Search II :rainbow:](#212-word-search-ii-rainbowhttpsleetcodecomproblemsword-search-ii)
    - [Solution](#solution-358)
  - [336\. Palindrome Pairs :fire:](#336-palindrome-pairs-firehttpsleetcodecomproblemspalindrome-pairs)
    - [Solution](#solution-359)
  - [472\. Concatenated Words :rainbow:](#472-concatenated-words-rainbowhttpsleetcodecomproblemsconcatenated-words)
    - [Solution](#solution-360)
  - [1268\. Search Suggestions System :rainbow:](#1268-search-suggestions-system-rainbowhttpsleetcodecomproblemssearch-suggestions-system)
    - [Solution](#solution-361)
  - [642\. Design Search Autocomplete System :fire:](#642-design-search-autocomplete-system-firehttpsleetcodecomproblemsdesign-search-autocomplete-system)
    - [Solution](#solution-362)
- [Graph](#graph)
  - [323\. Number of Connected Components in an Undirected Graph :rainbow:](#323-number-of-connected-components-in-an-undirected-graph-rainbowhttpsleetcodecomproblemsnumber-of-connected-components-in-an-undirected-graph)
    - [Solution](#solution-363)
  - [399\. Evaluate Division](#399-evaluate-divisionhttpsleetcodecomproblemsevaluate-division)
    - [Solution](#solution-364)
  - [1514\. Path with Maximum Probability :rainbow:](#1514-path-with-maximum-probability-rainbowhttpsleetcodecomproblemspath-with-maximum-probability)
    - [Solution](#solution-365)
  - [631\. Design Excel Sum Formula](#631-design-excel-sum-formulahttpsleetcodecomproblemsdesign-excel-sum-formula)
    - [Solution](#solution-366)
  - [787\. Cheapest Flights Within K](#787-cheapest-flights-within-khttpsleetcodecomproblemscheapest-flights-within-k-stops)
    - [Solution](#solution-367)
  - [1466\. Reorder Routes to Make All Paths Lead to the City Zero](#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zerohttpsleetcodecomproblemsreorder-routes-to-make-all-paths-lead-to-the-city-zero)
    - [Solution](#solution-368)
  - [1786\. Number of Restricted Paths From First to Last Node](#1786-number-of-restricted-paths-from-first-to-last-nodehttpsleetcodecomproblemsnumber-of-restricted-paths-from-first-to-last-node)
    - [Solution](#solution-369)
  - [133\. Clone Graph](#133-clone-graphhttpsleetcodecomproblemsclone-graph)
    - [Solution](#solution-370)
  - [417\. Pacific Atlantic Water Flow :rainbow:](#417-pacific-atlantic-water-flow-rainbowhttpsleetcodecomproblemspacific-atlantic-water-flow)
    - [Solution](#solution-371)
  - [261\. Graph Valid Tree](#261-graph-valid-treehttpsleetcodecomproblemsgraph-valid-tree)
    - [Solution](#solution-372)
  - [463\. Island Perimeter :rainbow:](#463-island-perimeter-rainbowhttpsleetcodecomproblemsisland-perimeter)
    - [Solution](#solution-373)
  - [743\. Network Delay Time](#743-network-delay-timehttpsleetcodecomproblemsnetwork-delay-time)
    - [Solution](#solution-374)
  - [1905\. Count Sub Islands :rainbow:](#1905-count-sub-islands-rainbowhttpsleetcodecomproblemscount-sub-islands)
    - [Solution](#solution-375)
  - [778\. Swim in Rising Water](#778-swim-in-rising-waterhttpsleetcodecomproblemsswim-in-rising-water)
    - [Solution](#solution-376)
- [Topological Sort](#topological-sort)
  - [269\. Alien Dictionary :rainbow:](#269-alien-dictionary-rainbowhttpsleetcodecomproblemsalien-dictionary)
    - [Solution](#solution-377)
  - [207\. Course Schedule](#207-course-schedulehttpsleetcodecomproblemscourse-schedule)
    - [Solution](#solution-378)
  - [210\. Course Schedule II](#210-course-schedule-iihttpsleetcodecomproblemscourse-schedule-ii)
    - [Solution](#solution-379)
- [Union Find](#union-find)
  - [721\. Accounts Merge](#721-accounts-mergehttpsleetcodecomproblemsaccounts-merge)
    - [Solution](#solution-380)
  - [200\. Number of Islands :rainbow:](#200-number-of-islands-rainbowhttpsleetcodecomproblemsnumber-of-islands)
    - [Solution](#solution-381)
  - [128\. Longest Consecutive Sequence](#128-longest-consecutive-sequencehttpsleetcodecomproblemslongest-consecutive-sequence)
    - [Solution](#solution-382)
  - [305\. Number of Islands II :fire:](#305-number-of-islands-ii-firehttpsleetcodecomproblemsnumber-of-islands-ii)
    - [Solution](#solution-383)
  - [827\. Making A Large Island :fire:](#827-making-a-large-island-firehttpsleetcodecomproblemsmaking-a-large-island)
    - [Solution](#solution-384)
  - [1584\. Min Cost to Connect All Points :rainbow:](#1584-min-cost-to-connect-all-points-rainbowhttpsleetcodecomproblemsmin-cost-to-connect-all-points)
    - [Solution](#solution-385)
  - [547\. Number of Provinces](#547-number-of-provinceshttpsleetcodecomproblemsnumber-of-provinces)
    - [Solution](#solution-386)
  - [684\. Redundant Connection](#684-redundant-connectionhttpsleetcodecomproblemsredundant-connection)
    - [Solution](#solution-387)
- [Machine Learning Coding](#machine-learning-coding)
  - [Linear regression](#linear-regression)
  - [Logistic Regression](#logistic-regression)
  - [KNN](#knn)
  - [Kmeans](#kmeans)
    - [kmeans with loss](#kmeans-with-loss)
    - [Mapreduce](#mapreduce)
    - [](#)
    - [Stopping Condition for K-Means clustering:](#stopping-condition-for-k-means-clustering)
    - [Assumption of Kmeans](#assumption-of-kmeans)
    - [The optimal number of clusters can be defined as follow:](#the-optimal-number-of-clusters-can-be-defined-as-follow)
  - [Rejection Sampling](#rejection-sampling)
  - [Weighted Sampling](#weighted-sampling)
  - [Reservoir sampling](#reservoir-sampling)
  - [Biased Coin](#biased-coin)
  - [Decision Tree](#decision-tree)
  - [AUC](#auc)

<!-- /code_chunk_output -->


## Greedy
### [621\. Task Scheduler](https://leetcode.com/problems/task-scheduler/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Counting](https://leetcode.com/tag/counting/)


Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.

However, there is a non-negative integer `n` that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least `n` units of time between any two same tasks.

Return _the least number of units of times that the CPU will take to finish all the given tasks_.

**Example 1:**

```
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation:
A -> B -> idle -> A -> B -> idle -> A -> B
There is at least 2 units of time between any two same tasks.
```

**Example 2:**

```
Input: tasks = ["A","A","A","B","B","B"], n = 0
Output: 6
Explanation: On this case any permutation of size 6 would work since n = 0.
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
And so on.
```

**Example 3:**

```
Input: tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
Output: 16
Explanation:
One possible solution is
A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A
```

**Constraints:**

*   `1 <= task.length <= 10<sup>4</sup>`
*   `tasks[i]` is upper-case English letter.
*   The integer `n` is in the range `[0, 100]`.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/task-scheduler/solution/)
```Python
from collections import Counter

def leastInterval(tasks, n):
    hashmap = Counter(tasks)    
    _, most = hashmap.most_common(1)[0]
    num_most = [num for num, freq in hashmap.items() if freq == most]
    return max(len(tasks), (most - 1) * (n + 1) + len(num_most))

leastInterval(tasks = ["A","A","A","B","B","B"], n = 2)
leastInterval(tasks = ["A","A","A","B","B","B"], n = 0)
leastInterval(tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2)
```

:  idle time, .  `idle_time + len(tasks)`
```python
tasks = ["A","A","A","B","B","B"]; n = 2

def leastInterval(tasks, n):
    frequencies = [0] * 26
    for t in tasks:
        frequencies[ord(t) - ord('A')] += 1

    frequencies.sort()

    # max frequency
    f_max = frequencies.pop()
    idle_time = (f_max - 1) * n

    while frequencies and idle_time > 0:
        idle_time -= min(f_max - 1, frequencies.pop()) # f_max - 1 ,  focus idle time
    idle_time = max(0, idle_time)

    return idle_time + len(tasks)
```

### [767\. Reorganize String](https://leetcode.com/problems/reorganize-string/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Counting](https://leetcode.com/tag/counting/)


Given a string `s`, rearrange the characters of `s` so that any two adjacent characters are not the same.

Return _any possible rearrangement of_ `s` _or return_ `""` _if not possible_.

**Example 1:**

```
Input: s = "aab"
Output: "aba"
```

**Example 2:**

```
Input: s = "aaab"
Output: ""
```

**Constraints:**

*   `1 <= s.length <= 500`
*   `s` consists of lowercase English letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def reorganizeString(self, s):
        """
        :type s: str
        :rtype: str
        """
        counter = collections.Counter(s)
        heap = []
        for ch, freq in counter.iteritems():
            heapq.heappush(heap, [-freq, ch])

        n = len(s)
        res = [None] * n
        if -heap[0][0] > (n + 1) / 2:
            return ''

        dq = []
        while heap:
            freq, ch = heapq.heappop(heap)
            dq += [ch] * (-freq)
        dq = collections.deque(dq)

        for i in range(0, n, 2):
            res[i] = dq.popleft()

        for i in range(1, n, 2):
            res[i] = dq.popleft()

        return ''.join(res)
```

### [277\. Find the Celebrity](https://leetcode.com/problems/find-the-celebrity/)

Difficulty: **Medium**  

Related Topics: [Two Pointers](https://leetcode.com/tag/two-pointers/), [Greedy](https://leetcode.com/tag/greedy/), [Graph](https://leetcode.com/tag/graph/), [Interactive](https://leetcode.com/tag/interactive/)


Suppose you are at a party with `n` people (labeled from `0` to `n - 1`), and among them, there may exist one celebrity. The definition of a celebrity is that all the other `n - 1` people know him/her, but he/she does not know any of them.

Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).

You are given a helper function `bool knows(a, b)` which tells you whether A knows B. Implement a function `int findCelebrity(n)`. There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return `-1`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/02/277_example_1_bold.PNG)

```
Input: graph = [[1,1,0],[0,1,0],[1,1,1]]
Output: 1
Explanation: There are three persons labeled with 0, 1 and 2\. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/02/02/277_example_2.PNG)

```
Input: graph = [[1,0,1],[1,1,0],[0,1,1]]
Output: -1
Explanation: There is no celebrity.
```

**Constraints:**

*   `n == graph.length`
*   `n == graph[i].length`
*   `2 <= n <= 100`
*   `graph[i][j]` is `0` or `1`.
*   `graph[i][i] == 1`

**Follow up:** If the maximum number of allowed calls to the API `knows` is `3 * n`, could you find a solution without exceeding the maximum number of calls?

#### Solution

Language: **Python**

```python
# The knows API is already defined for you.
# @param a, person a
# @param b, person b
# @return a boolean, whether a knows b
# def knows(a, b):

class Solution(object):
    def findCelebrity(self, n):
        """
        :type n: int
        :rtype: int
        """
        candidate = 0
        # Find the candidate.
        for i in xrange(1, n):
            if knows(candidate, i):  # noqa
                candidate = i        # All candidates < i are not celebrity candidates.
        # Verify the candidate.
        for i in xrange(n):
            candidate_knows_i = knows(candidate, i) # noqa
            i_knows_candidate = knows(i, candidate) # noqa
            if i != candidate and (candidate_knows_i or
                                   not i_knows_candidate):
                return -1
        return candidate  
```

### [452\. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/)


There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array `points` where `points[i] = [x<sub style="display: inline;">start</sub>, x<sub style="display: inline;">end</sub>]` denotes a balloon whose **horizontal diameter** stretches between `x<sub style="display: inline;">start</sub>` and `x<sub style="display: inline;">end</sub>`. You do not know the exact y-coordinates of the balloons.

Arrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `x<sub style="display: inline;">start</sub>` and `x<sub style="display: inline;">end</sub>` is **burst** by an arrow shot at `x` if `x<sub style="display: inline;">start</sub> <= x <= x<sub style="display: inline;">end</sub>`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.

Given the array `points`, return _the **minimum** number of arrows that must be shot to burst all balloons_.

**Example 1:**

```
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].
```

**Example 2:**

```
Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.
```

**Example 3:**

```
Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].
```

**Constraints:**

*   `1 <= points.length <= 10<sup>5</sup>`
*   `points[i].length == 2`
*   `-2<sup>31</sup> <= x<sub style="display: inline;">start</sub> < x<sub style="display: inline;">end</sub> <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

```python
def findMinArrowShots(points):
    points = sorted(points, key = lambda x: x[1])
    count = 1
    right = points[0][1]
    for point in points[1: ]:
        if right < point[0]:
            right = point[1]
            count += 1
    return count

findMinArrowShots(points = [[10,16],[2,8],[1,6],[7,12]])
findMinArrowShots(points = [[1,2],[3,4],[5,6],[7,8]])
findMinArrowShots(points = [[1,2],[2,3],[3,4],[4,5]])
```

### [334\. Increasing Triplet Subsequence](https://leetcode.com/problems/increasing-triplet-subsequence/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/)


Given an integer array `nums`, return `true` _if there exists a triple of indices_ `(i, j, k)` _such that_ `i < j < k` _and_ `nums[i] < nums[j] < nums[k]`. If no such indices exists, return `false`.

**Example 1:**

```
Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.
```

**Example 2:**

```
Input: nums = [5,4,3,2,1]
Output: false
Explanation: No triplet exists.
```

**Example 3:**

```
Input: nums = [2,1,5,0,4,6]
Output: true
Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.
```

**Constraints:**

*   `1 <= nums.length <= 5 * 10<sup>5</sup>`
*   `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`

**Follow up:** Could you implement a solution that runs in `O(n)` time complexity and `O(1)` space complexity?

#### Solution

Language: **Python**

```python
# not ac
# sol-1: O(n^3)
def increasingTriplet(nums):
    for k in range(len(nums)):
        for j in range(k):
            for i in range(j):
                if nums[i] < nums[j] < nums[k]:
                    return True
    return False

increasingTriplet(nums = [1,2,3,4,5])
increasingTriplet(nums = [5,4,3,2,1])
increasingTriplet(nums = [2,1,5,0,4,6])

# sol-2: O(n)
def increasingTriplet(nums):
    smallest = float('inf')
    second_smallest = float('inf')
    for num in nums:
        if num < smallest:
            smallest = num
        elif num < second_smallest:
            second_smallest = num
        else:
            return True
        print smallest, second_smallest
    return False

increasingTriplet(nums = [1,2,3,4,5])
increasingTriplet(nums = [5,4,3,2,1])
increasingTriplet(nums = [2,1,5,0,4,6])
```

### [122\. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Greedy](https://leetcode.com/tag/greedy/)


You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `i<sup>th</sup>` day.

On each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.

Find and return _the **maximum** profit you can achieve_.

**Example 1:**

```
Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
```

**Example 2:**

```
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.
```

**Example 3:**

```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.
```

**Constraints:**

*   `1 <= prices.length <= 3 * 10<sup>4</sup>`
*   `0 <= prices[i] <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
def maxProfit(prices):
    res = 0
    for i in xrange(1, len(prices)):
        if prices[i] > prices[i - 1]:
            res += prices[i] - prices[i - 1]
    return res

if __name__ == "__main__":
    maxProfit([7,1,5,3,6,4])
```

### [435\. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/)


Given an array of intervals `intervals` where `intervals[i] = [start<sub style="display: inline;">i</sub>, end<sub style="display: inline;">i</sub>]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.

**Example 1:**

```
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
```

**Example 2:**

```
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
```

**Example 3:**

```
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
```

**Constraints:**

*   `1 <= intervals.length <= 10<sup>5</sup>`
*   `intervals[i].length == 2`
*   `-5 * 10<sup>4</sup> <= start<sub style="display: inline;">i</sub> < end<sub style="display: inline;">i</sub> <= 5 * 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
class Solution:
    def eraseOverlapIntervals(self, intervals):
       """
       :type intervals: List[List[int]]
       :rtype: int
       """
        if not intervals:
            return 0
        intervals.sort(key = lambda x : x[0])
        last = 0
        count = 0
        for i in range(1, len(intervals)):
            if intervals[last][1] > intervals[i][0]:
                if intervals[i][1] < intervals[last][1]:
                    last = i
                count += 1
            else:
                last = i
        return count
```

### [135\. Candy](https://leetcode.com/problems/candy/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/)


There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.

You are giving candies to these children subjected to the following requirements:

*   Each child must have at least one candy.
*   Children with a higher rating get more candies than their neighbors.

Return _the minimum number of candies you need to have to distribute the candies to the children_.

**Example 1:**

```
Input: ratings = [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.
```

**Example 2:**

```
Input: ratings = [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
The third child gets 1 candy because it satisfies the above two conditions.
```

**Constraints:**

*   `n == ratings.length`
*   `1 <= n <= 2 * 10<sup>4</sup>`
*   `0 <= ratings[i] <= 2 * 10<sup>4</sup>`


#### Solution

Language: **Python**

Go from left to right and while increase, give the the next person +1 candy from previous, if not, leave number of candies as it was. In this way when we make this pass we make sure that condition that person with bigger value gets more candies fulfilled for pairs of adjusent persons where left person is smaller than right. Now, go from right to left and do the same: now we cover pairs of adjacent persons where right is smaller than left. After these two passes all persons are happy.

Complexity
Overall time and space complexity is O(n). Remark: there is also O(1) space complexity solution using the idea of peaks and valleys.
```python
class Solution:
    def candy(self, R):
        n, ans = len(R), [1]*len(R)

        for i in range(n-1):
            if R[i] < R[i+1]:
                ans[i+1] = max(1 + ans[i], ans[i+1])

        for i in range(n-2, -1, -1):
            if R[i+1] < R[i]:
                ans[i] = max(1 + ans[i+1], ans[i])

        return sum(ans)
```

### [881\. Boats to Save People](https://leetcode.com/problems/boats-to-save-people/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/)


You are given an array `people` where `people[i]` is the weight of the `i<sup>th</sup>` person, and an **infinite number of boats** where each boat can carry a maximum weight of `limit`. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most `limit`.

Return _the minimum number of boats to carry every given person_.

**Example 1:**

```
Input: people = [1,2], limit = 3
Output: 1
Explanation: 1 boat (1, 2)
```

**Example 2:**

```
Input: people = [3,2,2,1], limit = 3
Output: 3
Explanation: 3 boats (1, 2), (2) and (3)
```

**Example 3:**

```
Input: people = [3,5,3,4], limit = 5
Output: 4
Explanation: 4 boats (3), (3), (4), (5)
```

**Constraints:**

*   `1 <= people.length <= 5 * 10<sup>4</sup>`
*   `1 <= people[i] <= limit <= 3 * 10<sup>4</sup>`


#### Solution

Language: **Python**

Let `people[i]` to the currently lightest person, and `people[j]` to the heaviest.

Then, as described above, if the heaviest person can share a boat with the lightest person (if `people[j] + people[i] <= limit`) then do so; otherwise, the heaviest person sits in their own boat.

```python
class Solution(object):
    def numRescueBoats(self, people, limit):
        people.sort()
        i, j = 0, len(people) - 1
        ans = 0
        while i <= j:
            ans += 1
            if people[i] + people[j] <= limit:
                i += 1
            j -= 1
        return ans
```

### [1792\. Maximum Average Pass Ratio](https://leetcode.com/problems/maximum-average-pass-ratio/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/)


There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array `classes`, where `classes[i] = [pass<sub style="display: inline;">i</sub>, total<sub style="display: inline;">i</sub>]`. You know beforehand that in the `i<sup>th</sup>` class, there are `total<sub style="display: inline;">i</sub>` total students, but only `pass<sub style="display: inline;">i</sub>` number of students will pass the exam.

You are also given an integer `extraStudents`. There are another `extraStudents` brilliant students that are **guaranteed** to pass the exam of any class they are assigned to. You want to assign each of the `extraStudents` students to a class in a way that **maximizes** the **average** pass ratio across **all** the classes.

The **pass ratio** of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The **average pass ratio** is the sum of pass ratios of all the classes divided by the number of the classes.

Return _the **maximum** possible average pass ratio after assigning the_ `extraStudents` _students._ Answers within `10<sup>-5</sup>` of the actual answer will be accepted.

**Example 1:**

```
Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2
Output: 0.78333
Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.
```

**Example 2:**

```
Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4
Output: 0.53485
```

**Constraints:**

*   `1 <= classes.length <= 10<sup>5</sup>`
*   `classes[i].length == 2`
*   `1 <= pass<sub style="display: inline;">i</sub> <= total<sub style="display: inline;">i</sub> <= 10<sup>5</sup>`
*   `1 <= extraStudents <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def maxAverageRatio(self, classes, extraStudents):
        """
        :type classes: List[List[int]]
        :type extraStudents: int
        :rtype: float
        """
        heap = []
        for pass_i, total_i in classes:
            delta = (pass_i + 1) / (total_i + 1) - pass_i / total_i
            heapq.heappush(heap, (-delta, pass_i, total_i))
        for _ in range(extraStudents):
            _, pass_i, total_i = heapq.heappop(heap)
            pass_i += 1
            total_i += 1
            new_delta = (pass_i + 1) / (total_i + 1) - pass_i / total_i
            heapq.heappush(heap, (-new_delta, pass_i, total_i))
        stack = []
        while heap:
            _, pass_i, total_i = heapq.heappop(heap)
            stack.append(pass_i/total_i)
        return sum(stack)/len(stack)



```

### [55\. Jump Game :rainbow:](https://leetcode.com/problems/jump-game/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Greedy](https://leetcode.com/tag/greedy/)


You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.

Return `true` _if you can reach the last index, or_ `false` _otherwise_.

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>4</sup>`
*   `0 <= nums[i] <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
#  
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        reach = 0
        for i, n in enumerate(nums):
            if i > reach:
                return False
            reach = max(reach, i + n)
        return True

#  
```

### [45\. Jump Game II :rainbow:](https://leetcode.com/problems/jump-game-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Greedy](https://leetcode.com/tag/greedy/)


Given an array of non-negative integers `nums`, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

You can assume that you can always reach the last index.

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2\. Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [2,3,0,1,4]
Output: 2
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>4</sup>`
*   `0 <= nums[i] <= 1000`


#### Solution

Language: **Python**

```python
class Solution(object):
    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        res = 0
        l = r = 0
        while r < len(nums) - 1:
            farthest = 0
            for i in range(l, r + 1):
                farthest = max(farthest, i + nums[i])
            l = r + 1
            r = farthest
            res += 1
        return res

```

## Two Pointers
### [125\. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)

Difficulty: **Easy**  

Related Topics: [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/)


A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

*   `1 <= s.length <= 2 * 10<sup>5</sup>`
*   `s` consists only of printable ASCII characters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        i = 0
        j = len(s) - 1
        s = s.lower()
        while i < j:
            while i < j and not s[i].isalnum():
                i += 1
            while i < j and not s[j].isalnum():
                j -= 1
            if s[i] != s[j]:
                return False
            else:
                i += 1
                j -= 1
        return True

class Solution(object):
    def isPalindrome(self, word):
        """
        :type s: str
        :rtype: bool
        """
        if len(word) < 2: return True
        if word[0] != word[-1]: return False
        return self.isPalindrome(word[1:-1])
```

### [986\. Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/)


You are given two lists of closed intervals, `firstList` and `secondList`, where `firstList[i] = [start<sub style="display: inline;">i</sub>, end<sub style="display: inline;">i</sub>]` and `secondList[j] = [start<sub style="display: inline;">j</sub>, end<sub style="display: inline;">j</sub>]`. Each list of intervals is pairwise **disjoint** and in **sorted order**.

Return _the intersection of these two interval lists_.

A **closed interval** `[a, b]` (with `a <= b`) denotes the set of real numbers `x` with `a <= x <= b`.

The **intersection** of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of `[1, 3]` and `[2, 4]` is `[2, 3]`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/01/30/interval1.png)

```
Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
```

**Example 2:**

```
Input: firstList = [[1,3],[5,9]], secondList = []
Output: []
```

**Example 3:**

```
Input: firstList = [], secondList = [[4,8],[10,12]]
Output: []
```

**Example 4:**

```
Input: firstList = [[1,7]], secondList = [[3,10]]
Output: [[3,7]]
```

**Constraints:**

*   `0 <= firstList.length, secondList.length <= 1000`
*   `firstList.length + secondList.length >= 1`
*   `0 <= start<sub style="display: inline;">i</sub> < end<sub style="display: inline;">i</sub> <= 10<sup>9</sup>`
*   `end<sub style="display: inline;">i</sub> < start<sub style="display: inline;">i+1</sub>`
*   `0 <= start<sub style="display: inline;">j</sub> < end<sub style="display: inline;">j</sub> <= 10<sup>9</sup>`
*   `end<sub style="display: inline;">j</sub> < start<sub style="display: inline;">j+1</sub>`


#### Solution

Language: **Python**

```python
def intervalIntersection(firstList, secondList):
    n, m = len(firstList), len(secondList)
    i , j = 0, 0
    result = []
    while i < n and j < m:
        if firstList[i][1] < secondList[j][0]:
            i += 1
        elif secondList[j][1] < firstList[i][0]:
            j += 1
        else:
            overlap = [max(firstList[i][0], secondList[j][0]), min(firstList[i][1], secondList[j][1])]
            result.append(overlap)
            if firstList[i][1] < secondList[j][1]:
                i += 1
            else:
                j += 1
    return result


intervalIntersection(firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]])
intervalIntersection(firstList = [[1,3],[5,9]], secondList = [])         
intervalIntersection(firstList = [], secondList = [[4,8],[10,12]])
intervalIntersection(firstList = [[1,7]], secondList = [[3,10]])           
```

### [88\. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Sorting](https://leetcode.com/tag/sorting/)


You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.

**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.

The final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.

**Example 1:**

```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
```

**Example 2:**

```
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
```

**Example 3:**

```
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1\. The 0 is only there to ensure the merge result can fit in nums1.
```

**Constraints:**

*   `nums1.length == m + n`
*   `nums2.length == n`
*   `0 <= m, n <= 200`
*   `1 <= m + n <= 200`
*   `-10<sup>9</sup> <= nums1[i], nums2[j] <= 10<sup>9</sup>`

**Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?


#### Solution

Language: **Python**

```python
def merge(nums1, m, nums2, n):
    i, j = m - 1, n - 1
    k = m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
    return nums1

merge(nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3)
```

### [15\. 3Sum](https://leetcode.com/problems/3sum/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Sorting](https://leetcode.com/tag/sorting/)


Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

**Example 2:**

```
Input: nums = []
Output: []
```

**Example 3:**

```
Input: nums = [0]
Output: []
```

**Constraints:**

*   `0 <= nums.length <= 3000`
*   `-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
def threeSum(nums):
    nums.sort()
    result = []
    n = len(nums)
    for i in range(n):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        target = 0 - nums[i]
        j = i + 1
        k = n - 1
        while j < k:
            if nums[j] + nums[k] < target:
                j += 1
            elif nums[j] + nums[k] > target:
                k -= 1
            else:
                curr = [nums[i], nums[j], nums[k]]
                if curr not in result:
                    result.append(curr)
                j += 1
                k -= 1
    return result

threeSum(nums = [-1,0,1,2,-1,-4])
threeSum(nums = [])
threeSum(nums = [0])
```

### [283\. Move Zeroes](https://leetcode.com/problems/move-zeroes/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/)


Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

**Note** that you must do this in-place without making a copy of the array.

**Example 1:**

```
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
```

**Example 2:**

```
Input: nums = [0]
Output: [0]
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>4</sup>`
*   `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`

**Follow up:** Could you minimize the total number of operations done?

#### Solution

Language: **Python**

```python
def moveZeroes(nums):
    count = 0
    for i in range(len(nums)):
        if nums[i]:
            nums[count], nums[i] = nums[i], nums[count]  
            count += 1
    return nums  

moveZeroes(nums = [0,1,0,3,12])
moveZeroes(nums = [0])    
```

### [408\. Valid Word Abbreviation](https://leetcode.com/problems/valid-word-abbreviation/)

Difficulty: **Easy**  

Related Topics: [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/)


A string can be **abbreviated** by replacing any number of **non-adjacent**, **non-empty** substrings with their lengths. The lengths **should not** have leading zeros.

For example, a string such as `"substitution"` could be abbreviated as (but not limited to):

*   `"s10n"` (`"s <u style="display: inline;">ubstitutio</u> n"`)
*   `"sub4u4"` (`"sub <u style="display: inline;">stit</u> u <u style="display: inline;">tion</u>"`)
*   `"12"` (`"<u style="display: inline;">substitution</u>"`)
*   `"su3i1u2on"` (`"su <u style="display: inline;">bst</u> i <u style="display: inline;">t</u> u <u style="display: inline;">ti</u> on"`)
*   `"substitution"` (no substrings replaced)

The following are **not valid** abbreviations:

*   `"s55n"` (`"s <u style="display: inline;">ubsti</u> <u style="display: inline;">tutio</u> n"`, the replaced substrings are adjacent)
*   `"s010n"` (has leading zeros)
*   `"s0ubstitution"` (replaces an empty substring)

Given a string `word` and an abbreviation `abbr`, return _whether the string **matches** the given abbreviation_.

A **substring** is a contiguous **non-empty** sequence of characters within a string.

**Example 1:**

```
Input: word = "internationalization", abbr = "i12iz4n"
Output: true
Explanation: The word "internationalization" can be abbreviated as "i12iz4n" ("i nternational iz atio n").
```

**Example 2:**

```
Input: word = "apple", abbr = "a2e"
Output: false
Explanation: The word "apple" cannot be abbreviated as "a2e".
```

**Constraints:**

*   `1 <= word.length <= 20`
*   `word` consists of only lowercase English letters.
*   `1 <= abbr.length <= 10`
*   `abbr` consists of lowercase English letters and digits.
*   All the integers in `abbr` will fit in a 32-bit integer.


#### Solution

Language: **Python**

```python
class Solution(object):
    def validWordAbbreviation(self, word, abbr):    
        i, j = 0, 0
        while i < len(word) and j < len(abbr):
            if abbr[j].isalpha():
                if word[i] !=  abbr[j]:
                    return False
                i += 1
                j += 1
            else:
                if abbr[j] == "0":
                    return False
                tmp = ""
                while j < len(abbr) and abbr[j].isdigit():
                    tmp = tmp + abbr[j]
                    j += 1
                i += int(tmp)
        return i == len(word) and j == len(abbr)
```

### [977\. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Sorting](https://leetcode.com/tag/sorting/)


Given an integer array `nums` sorted in **non-decreasing** order, return _an array of **the squares of each number** sorted in non-decreasing order_.

**Example 1:**

```
Input: nums = [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Explanation: After squaring, the array becomes [16,1,0,9,100].
After sorting, it becomes [0,1,9,16,100].
```

**Example 2:**

```
Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]
```

**Constraints:**

*   `<span style="display: inline;">1 <= nums.length <=</span> 10<sup>4</sup>`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
*   `nums` is sorted in **non-decreasing** order.

**Follow up:** Squaring each element and sorting the new array is very trivial, could you find an `O(n)` solution using a different approach?

#### Solution

Language: **Python**

```python
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        result = [None for _ in A]
        left, right = 0, len(A) - 1
        for index in range(len(A)-1, -1, -1):
            if abs(A[left]) > abs(A[right]):
                result[index] = A[left] ** 2
                left += 1
            else:
                result[index] = A[right] ** 2
                right -= 1
        return result
```

### [75\. Sort Colors :rainbow:](https://leetcode.com/problems/sort-colors/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Sorting](https://leetcode.com/tag/sorting/)


Given an array `nums` with `n` objects colored red, white, or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

**Example 1:**

```
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

**Example 2:**

```
Input: nums = [2,0,1]
Output: [0,1,2]
```

**Example 3:**

```
Input: nums = [0]
Output: [0]
```

**Example 4:**

```
Input: nums = [1]
Output: [1]
```

**Constraints:**

*   `n == nums.length`
*   `1 <= n <= 300`
*   `nums[i]` is `0`, `1`, or `2`.

**Follow up:** Could you come up with a one-pass algorithm using only constant extra space?


#### Solution

Language: **Python**

```python
from collections import Counter
def sortColors(nums):
    hashmap = Counter(nums)
    for i in range(len(nums)):
        if i < hashmap[0]:
            nums[i] = 0
        elif i < hashmap[0] + hashmap[1]:
            nums[i] = 1
        else:
            nums[i] = 2
    return nums
sortColors([2,0,2,1,1,0])

class Solution(object):
    def sortColors(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        zero = 0
        two = len(nums) - 1
        i = 0
        while i <= two:
            if nums[i] == 0:
                nums[zero], nums[i] = nums[i], nums[zero]
                i += 1
                zero += 1
            elif nums[i] == 1:
                i += 1
            elif nums[i] == 2:
                nums[two], nums[i] = nums[i], nums[two]
                two -= 1
        return nums
```

### [611\. Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Binary Search](https://leetcode.com/tag/binary-search/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/)


Given an integer array `nums`, return _the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle_.

**Example 1:**

```
Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid combinations are:
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
```

**Example 2:**

```
Input: nums = [4,2,3,4]
Output: 4
```

**Constraints:**

*   `1 <= nums.length <= 1000`
*   `0 <= nums[i] <= 1000`


#### Solution

Language: **Python**

```python
def triangleNumber(nums):
    nums.sort(reverse = True)
    nums
    n = len(nums)
    ans = 0
    for c in range(n - 2):
        b, a = c + 1, n - 1
        while b < a:
            if nums[c] < nums[b] + nums[a]:
                ans += a - b
                b += 1
            else:
                a -= 1
    return ans
triangleNumber(nums = [2,2,3,4])
```

### [243\. Shortest Word Distance](https://leetcode.com/problems/shortest-word-distance/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/)


Given an array of strings `wordsDict` and two different strings that already exist in the array `word1` and `word2`, return _the shortest distance between these two words in the list_.

**Example 1:**

```
Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "coding", word2 = "practice"
Output: 3
```

**Example 2:**

```
Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "coding"
Output: 1
```

**Constraints:**

*   `1 <= wordsDict.length <= 3 * 10<sup>4</sup>`
*   `1 <= wordsDict[i].length <= 10`
*   `wordsDict[i]` consists of lowercase English letters.
*   `word1` and `word2` are in `wordsDict`.
*   `word1 != word2`


#### Solution

Language: **Python**

```python
class Solution(object):
    def shortestDistance(self, wordsDict, word1, word2):
        """
        :type wordsDict: List[str]
        :type word1: str
        :type word2: str
        :rtype: int
        """
        result = float('inf')
        i, j = None, None
        for index, word in enumerate(wordsDict):
            if word == word1:
                i = index
            elif word == word2:
                j = index
            if i is not None and j is not None:
                result = min(result, abs(i - j))
            print i, j
        return result
```

### [244\. Shortest Word Distance II](https://leetcode.com/problems/shortest-word-distance-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/), [Design](https://leetcode.com/tag/design/)


Design a data structure that will be initialized with a string array, and then it should answer queries of the shortest distance between two different strings from the array.

Implement the `WordDistance` class:

*   `WordDistance(String[] wordsDict)` initializes the object with the strings array `wordsDict`.
*   `int shortest(String word1, String word2)` returns the shortest distance between `word1` and `word2` in the array `wordsDict`.

**Example 1:**

```
Input
["WordDistance", "shortest", "shortest"]
[[["practice", "makes", "perfect", "coding", "makes"]], ["coding", "practice"], ["makes", "coding"]]
Output
[null, 3, 1]

Explanation
WordDistance wordDistance = new WordDistance(["practice", "makes", "perfect", "coding", "makes"]);
wordDistance.shortest("coding", "practice"); // return 3
wordDistance.shortest("makes", "coding");    // return 1
```

**Constraints:**

*   `1 <= wordsDict.length <= 3 * 10<sup>4</sup>`
*   `1 <= wordsDict[i].length <= 10`
*   `wordsDict[i]` consists of lowercase English letters.
*   `word1` and `word2` are in `wordsDict`.
*   `word1 != word2`
*   At most `5000` calls will be made to `shortest`.


#### Solution

Language: **Python**

```python
from collections import defaultdict

class WordDistance(object):

    def __init__(self, wordsDict):
        """
        :type wordsDict: List[str]
        """
        self.pos = defaultdict(list)
        for index, word in enumerate(wordsDict):
            self.pos[word].append(index)

    def shortest(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """
        result = float('inf')
        pos1_list = self.pos[word1]
        pos2_list = self.pos[word2]
        l1 = len(pos1_list)
        l2 = len(pos2_list)
        i, j = 0, 0
        while i < l1 and j < l2:
            result = min(result, abs(pos1_list[i] - pos2_list[j]))
            if pos1_list[i] < pos2_list[j]:
                i += 1
            else:
                j += 1
        return result
```

### [245\. Shortest Word Distance III](https://leetcode.com/problems/shortest-word-distance-iii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/)


Given an array of strings `wordsDict` and two strings that already exist in the array `word1` and `word2`, return _the shortest distance between these two words in the list_.

**Note** that `word1` and `word2` may be the same. It is guaranteed that they represent **two individual words** in the list.

**Example 1:**

```
Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "coding"
Output: 1
```

**Example 2:**

```
Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "makes"
Output: 3
```

**Constraints:**

*   `1 <= wordsDict.length <= 10<sup>5</sup>`
*   `1 <= wordsDict[i].length <= 10`
*   `wordsDict[i]` consists of lowercase English letters.
*   `word1` and `word2` are in `wordsDict`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def shortestWordDistance(self, words, word1, word2):
        """
        :type wordsDict: List[str]
        :type word1: str
        :type word2: str
        :rtype: int
        """
        dist = float("inf")
        is_same = (word1 == word2)
        i, index1, index2 = 0, None, None
        while i < len(words):
            if words[i] == word1:
                if is_same and index1 is not None:
                    dist = min(dist, abs(index1 - i))
                index1 = i
            elif words[i] == word2:
                index2 = i
            i += 1

            if index1 is not None and index2 is not None:
                dist = min(dist, abs(index1 - index2))

        return dist
```

### [1861\. Rotating the Box](https://leetcode.com/problems/rotating-the-box/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Matrix](https://leetcode.com/tag/matrix/)


You are given an `m x n` matrix of characters `box` representing a side-view of a box. Each cell of the box is one of the following:

*   A stone `'#'`
*   A stationary obstacle `'*'`
*   Empty `'.'`

The box is rotated **90 degrees clockwise**, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity **does not** affect the obstacles' positions, and the inertia from the box's rotation **does not** affect the stones' horizontal positions.

It is **guaranteed** that each stone in `box` rests on an obstacle, another stone, or the bottom of the box.

Return _an_ `n x m` _matrix representing the box after the rotation described above_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcodewithstones.png)

```
Input: box = [["#",".","#"]]
Output: [["."],
         ["#"],
         ["#"]]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode2withstones.png)

```
Input: box = [["#",".","*","."],
              ["#","#","*","."]]
Output: [["#","."],
         ["#","#"],
         ["*","*"],
         [".","."]]
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode3withstone.png)

```
Input: box = [["#","#","*",".","*","."],
              ["#","#","#","*",".","."],
              ["#","#","#",".","#","."]]
Output: [[".","#","#"],
         [".","#","#"],
         ["#","#","*"],
         ["#","*","."],
         ["#",".","*"],
         ["#",".","."]]
```

**Constraints:**

*   `m == box.length`
*   `n == box[i].length`
*   `1 <= m, n <= 500`
*   `box[i][j]` is either `'#'`, `'*'`, or `'.'`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def rotateTheBox(self, box):
        """
        :type box: List[List[str]]
        :rtype: List[List[str]]
        """
        for row in box:
            count = 0
            for j in range(len(row)):
                if row[j] == ".":
                    row[j], row[count] = row[count], row[j]
                    count += 1
                if row[j] == "*":
                    count = j + 1
        return [list(rows[::-1]) for rows in zip(*box)]
```

### [443\. String Compression](https://leetcode.com/problems/string-compression/)

Difficulty: **Medium**  

Related Topics: [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/)


Given an array of characters `chars`, compress it using the following algorithm:

Begin with an empty string `s`. For each group of **consecutive repeating characters** in `chars`:

*   If the group's length is `1`, append the character to `s`.
*   Otherwise, append the character followed by the group's length.

The compressed string `s` **should not be returned separately**, but instead, be stored **in the input character array `chars`**. Note that group lengths that are `10` or longer will be split into multiple characters in `chars`.

After you are done **modifying the input array**, return _the new length of the array_.

You must write an algorithm that uses only constant extra space.

**Example 1:**

```
Input: chars = ["a","a","b","b","c","c","c"]
Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]
Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".
```

**Example 2:**

```
Input: chars = ["a"]
Output: Return 1, and the first character of the input array should be: ["a"]
Explanation: The only group is "a", which remains uncompressed since it's a single character.
```

**Example 3:**

```
Input: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].
Explanation: The groups are "a" and "bbbbbbbbbbbb". This compresses to "ab12".
```

**Example 4:**

```
Input: chars = ["a","a","a","b","b","a","a"]
Output: Return 6, and the first 6 characters of the input array should be: ["a","3","b","2","a","2"].
Explanation: The groups are "aaa", "bb", and "aa". This compresses to "a3b2a2". Note that each group is independent even if two groups have the same character.
```

**Constraints:**

*   `1 <= chars.length <= 2000`
*   `chars[i]` is a lowercase English letter, uppercase English letter, digit, or symbol.


#### Solution

Language: **Python**

```python
chars = ["a","a","b","c","c","c"]
chars.append(None)
count = 1
result = []
for i in range(len(chars) - 1):
    if chars[i] == chars[i + 1]:
        count += 1
    else:
        result.append(chars[i])
        if count != 1:
            result.extend(list(str(count)))
        count = 1
result
len(result)
''.join(result)


count = 1
for i in range(len(chars)-1,-1,-1):
    if i and chars[i]==chars[i-1]:
        count += 1
        chars.pop(i)
    else:
        if count>1:
            for item in str(count)[::-1]:
                chars.insert(i+1, item)
            count = 1
''.join(chars)

chars = ["a","a","b","c","c","c"]
right, left = 0, 0
while right < len(chars):
    ch, f = chars[right], 0
    while right < len(chars) and chars[right] == ch:
        right += 1
        f += 1
    chars[left] = ch
    left += 1
    if f > 1:
        for c in str(f):
            chars[left] = c
            left += 1
chars[:left]
```

### [1465\. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/)


You are given a rectangular cake of size `h x w` and two arrays of integers `horizontalCuts` and `verticalCuts` where:

*   `horizontalCuts[i]` is the distance from the top of the rectangular cake to the `i<sup>th</sup>` horizontal cut and similarly, and
*   `verticalCuts[j]` is the distance from the left of the rectangular cake to the `j<sup>th</sup>` vertical cut.

Return _the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays_ `horizontalCuts` _and_ `verticalCuts`. Since the answer can be a large number, return this **modulo** `10<sup>9</sup> + 7`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/05/14/leetcode_max_area_2.png)

```
Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]
Output: 4
Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/05/14/leetcode_max_area_3.png)

```
Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]
Output: 6
Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.
```

**Example 3:**

```
Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]
Output: 9
```

**Constraints:**

*   `2 <= h, w <= 10<sup>9</sup>`
*   `1 <= horizontalCuts.length <= min(h - 1, 10<sup>5</sup>)`
*   `1 <= verticalCuts.length <= min(w - 1, 10<sup>5</sup>)`
*   `1 <= horizontalCuts[i] < h`
*   `1 <= verticalCuts[i] < w`
*   All the elements in `horizontalCuts` are distinct.
*   All the elements in `verticalCuts` are distinct.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/discuss/753060/Python-3-%2B-Explanation)
```python
h = 5; w = 4; horizontalCuts = [1,2,4]; verticalCuts = [1,3]

horizontalStrips = [0] + sorted(horizontalCuts) + [h]
verticalStrips = [0] + sorted(verticalCuts) + [w]

maxStripWidth = max([horizontalStrips[i + 1] - horizontalStrips[i] for i in range(len(horizontalStrips) - 1)])
maxStripHeight = max([verticalStrips[i + 1] - verticalStrips[i] for i in range(len(verticalStrips) - 1)])
```

### [532\. K-diff Pairs in an Array](https://leetcode.com/problems/k-diff-pairs-in-an-array/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Binary Search](https://leetcode.com/tag/binary-search/), [Sorting](https://leetcode.com/tag/sorting/)


Given an array of integers `nums` and an integer `k`, return _the number of **unique** k-diff pairs in the array_.

A **k-diff** pair is an integer pair `(nums[i], nums[j])`, where the following are true:

*   `0 <= i < j < nums.length`
*   `|nums[i] - nums[j]| == k`

**Notice** that `|val|` denotes the absolute value of `val`.

**Example 1:**

```
Input: nums = [3,1,4,1,5], k = 2
Output: 2
Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).
Although we have two 1s in the input, we should only return the number of unique pairs.
```

**Example 2:**

```
Input: nums = [1,2,3,4,5], k = 1
Output: 4
Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).
```

**Example 3:**

```
Input: nums = [1,3,1,5,4], k = 0
Output: 1
Explanation: There is one 0-diff pair in the array, (1, 1).
```

**Example 4:**

```
Input: nums = [1,2,4,4,3,3,0,9,2,3], k = 3
Output: 2
```

**Example 5:**

```
Input: nums = [-1,-2,-3], k = 1
Output: 2
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>4</sup>`
*   `-10<sup>7</sup> <= nums[i] <= 10<sup>7</sup>`
*   `0 <= k <= 10<sup>7</sup>`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution/)
```python
class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:

        nums = sorted(nums)

        left = 0
        right = 1

        result = 0

        while (left < len(nums) and right < len(nums)):
            if (left == right or nums[right] - nums[left] < k):
                # List item 1 in the text
                right += 1
            elif nums[right] - nums[left] > k:
                # List item 2 in the text
                left += 1
            else:
                # List item 3 in the text
                left += 1
                result += 1
                while (left < len(nums) and nums[left] == nums[left - 1]):
                    left += 1

        return result

from collections import Counter

class Solution:
    def findPairs(self, nums, k):
        result = 0

        counter = Counter(nums)

        for x in counter:
            if k > 0 and x + k in counter:
                result += 1
            elif k == 0 and counter[x] > 1: ## For example, if we have nums = [1,1,1,1] and k = 0, we have one unique (1,1) pair.
                result += 1
        return result
```

### [1868\. Product of Two Run-Length Encoded Arrays :rainbow:](https://leetcode.com/problems/product-of-two-run-length-encoded-arrays/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/)


**Run-length encoding** is a compression algorithm that allows for an integer array `nums` with many segments of **consecutive repeated** numbers to be represented by a (generally smaller) 2D array `encoded`. Each `encoded[i] = [val<sub style="display: inline;">i</sub>, freq<sub style="display: inline;">i</sub>]` describes the `i<sup>th</sup>` segment of repeated numbers in `nums` where `val<sub style="display: inline;">i</sub>` is the value that is repeated `freq<sub style="display: inline;">i</sub>` times.

*   For example, `nums = [1,1,1,2,2,2,2,2]` is represented by the **run-length encoded** array `encoded = [[1,3],[2,5]]`. Another way to read this is "three `1`'s followed by five `2`'s".

The **product** of two run-length encoded arrays `encoded1` and `encoded2` can be calculated using the following steps:

1.  **Expand** both `encoded1` and `encoded2` into the full arrays `nums1` and `nums2` respectively.
2.  Create a new array `prodNums` of length `nums1.length` and set `prodNums[i] = nums1[i] * nums2[i]`.
3.  **Compress** `prodNums` into a run-length encoded array and return it.

You are given two **run-length encoded** arrays `encoded1` and `encoded2` representing full arrays `nums1` and `nums2` respectively. Both `nums1` and `nums2` have the **same length**. Each `encoded1[i] = [val<sub style="display: inline;">i</sub>, freq<sub style="display: inline;">i</sub>]` describes the `i<sup>th</sup>` segment of `nums1`, and each `encoded2[j] = [val<sub style="display: inline;">j</sub>, freq<sub style="display: inline;">j</sub>]` describes the `j<sup>th</sup>` segment of `nums2`.

Return _the **product** of_ `encoded1` _and_ `encoded2`.

**Note:** Compression should be done such that the run-length encoded array has the **minimum** possible length.

**Example 1:**

```
Input: encoded1 = [[1,3],[2,3]], encoded2 = [[6,3],[3,3]]
Output: [[6,6]]
Explanation: encoded1 expands to [1,1,1,2,2,2] and encoded2 expands to [6,6,6,3,3,3].
prodNums = [6,6,6,6,6,6], which is compressed into the run-length encoded array [[6,6]].
```

**Example 2:**

```
Input: encoded1 = [[1,3],[2,1],[3,2]], encoded2 = [[2,3],[3,3]]
Output: [[2,3],[6,1],[9,2]]
Explanation: encoded1 expands to [1,1,1,2,3,3] and encoded2 expands to [2,2,2,3,3,3].
prodNums = [2,2,2,6,9,9], which is compressed into the run-length encoded array [[2,3],[6,1],[9,2]].
```

**Constraints:**

*   `1 <= encoded1.length, encoded2.length <= 10<sup>5</sup>`
*   `encoded1[i].length == 2`
*   `encoded2[j].length == 2`
*   `1 <= val<sub style="display: inline;">i</sub>, freq<sub style="display: inline;">i</sub> <= 10<sup>4</sup>` for each `encoded1[i]`.
*   `1 <= val<sub style="display: inline;">j</sub>, freq<sub style="display: inline;">j</sub> <= 10<sup>4</sup>` for each `encoded2[j]`.
*   The full arrays that `encoded1` and `encoded2` represent are the same length.


#### Solution

Language: **Python**

```python
class Solution(object):
    def findRLEArray(self, encoded1, encoded2):
        """
        :type encoded1: List[List[int]]
        :type encoded2: List[List[int]]
        :rtype: List[List[int]]
        """
        p1,p2 = 0, 0
        ans = []
        while p1<len(encoded1) and p2< len(encoded2):
            l1 = encoded1[p1][1]
            l2 = encoded2[p2][1]
            current_v = encoded1[p1][0]*encoded2[p2][0]

            if l1 < l2:
                current_f = l1
                p1 += 1
                encoded2[p2][1] = l2-l1 # update frequency for uncounted encoded2
            elif l2 < l1:
                current_f = l2
                p2 += 1
                encoded1[p1][1] = l1-l2 # update frequency for uncounted encoded1
            else:  # l1 == l2
                current_f = l2
                p1 += 1
                p2 += 1

            # update ans
            if ans and ans[-1][0] == current_v: # check if current_v == previous value in ans
                ans[-1][1] += current_f
            else:
                ans.append([current_v,current_f])
        return ans
```

### [360\. Sort Transformed Array](https://leetcode.com/problems/sort-transformed-array/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Math](https://leetcode.com/tag/math/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Sorting](https://leetcode.com/tag/sorting/)


Given a **sorted** integer array `nums` and three integers `a`, `b` and `c`, apply a quadratic function of the form `f(x) = ax<sup>2</sup> + bx + c` to each element `nums[i]` in the array, and return _the array in a sorted order_.

**Example 1:**

```
Input: nums = [-4,-2,2,4], a = 1, b = 3, c = 5
Output: [3,9,15,33]
```

**Example 2:**

```
Input: nums = [-4,-2,2,4], a = -1, b = 3, c = 5
Output: [-23,-5,1,7]
```

**Constraints:**

*   `1 <= nums.length <= 200`
*   `-100 <= nums[i], a, b, c <= 100`
*   `nums` is sorted in **ascending** order.

**Follow up:** Could you solve it in `O(n)` time?


#### Solution

Language: **Python**

```python
def sortTransformedArray(nums, a, b, c):
    f = lambda x: a * x ** 2 + b * x + c
    n = len(nums)
    index = 0 if a < 0 else n-1
    l, r, ans = 0, n-1, [0] * n
    while l <= r:
        l_val, r_val = f(nums[l]), f(nums[r])
        if a >= 0:
            if l_val > r_val:
                ans[index] = l_val
                l += 1
            else:    
                ans[index] = r_val
                r -= 1
            index -= 1
        else:
            if l_val > r_val:
                ans[index] = r_val
                r -= 1
            else:    
                ans[index] = l_val
                l += 1
            index += 1
    return ans


sortTransformedArray(nums = [-4, -2, 0, 4], a = 0, b = 1, c = 0)
sortTransformedArray(nums = [-4, -2, 2, 4], a = -1, b = 3, c = 5)    
```

### [11\. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Greedy](https://leetcode.com/tag/greedy/)


Given `n` non-negative integers `a<sub style="display: inline;">1</sub>, a<sub style="display: inline;">2</sub>, ..., a<sub style="display: inline;">n</sub>`, where each represents a point at coordinate `(i, a<sub style="display: inline;">i</sub>)`. `n` vertical lines are drawn such that the two endpoints of the line `i` is at `(i, a<sub style="display: inline;">i</sub>)` and `(i, 0)`. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.

**Notice** that you may not slant the container.

**Example 1:**

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```

**Example 2:**

```
Input: height = [1,1]
Output: 1
```

**Example 3:**

```
Input: height = [4,3,2,1,4]
Output: 16
```

**Example 4:**

```
Input: height = [1,2,1]
Output: 2
```

**Constraints:**

*   `n == height.length`
*   `2 <= n <= 10<sup>5</sup>`
*   `0 <= height[i] <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        max_area = 0
        while left < right:
            max_area = max(max_area, (right - left) * min(height[left], height[right]))
            if height[left] < height[right]:
                left += 1
            elif height[left] > height[right]:
                right -= 1
            else:
                left += 1
                right -= 1
        return max_area
```

### [809\. Expressive Words](https://leetcode.com/problems/expressive-words/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/)


Sometimes people repeat letters to represent extra feeling. For example:

*   `"hello" -> "heeellooo"`
*   `"hi" -> "hiiii"`

In these strings like `"heeellooo"`, we have groups of adjacent letters that are all the same: `"h"`, `"eee"`, `"ll"`, `"ooo"`.

You are given a string `s` and an array of query strings `words`. A query word is **stretchy** if it can be made to be equal to `s` by any number of applications of the following extension operation: choose a group consisting of characters `c`, and add some number of characters `c` to the group so that the size of the group is **three or more**.

*   For example, starting with `"hello"`, we could do an extension on the group `"o"` to get `"hellooo"`, but we cannot get `"helloo"` since the group `"oo"` has a size less than three. Also, we could do another extension like `"ll" -> "lllll"` to get `"helllllooo"`. If `s = "helllllooo"`, then the query word `"hello"` would be **stretchy** because of these two extension operations: `query = "hello" -> "hellooo" -> "helllllooo" = s`.

Return _the number of query strings that are **stretchy**_.

**Example 1:**

```
Input: s = "heeellooo", words = ["hello", "hi", "helo"]
Output: 1
Explanation:
We can extend "e" and "o" in the word "hello" to get "heeellooo".
We can't extend "helo" to get "heeellooo" because the group "ll" is not size 3 or more.
```

**Example 2:**

```
Input: s = "zzzzzyyyyy", words = ["zzyy","zy","zyy"]
Output: 3
```

**Constraints:**

*   `1 <= s.length, words.length <= 100`
*   `1 <= words[i].length <= 100`
*   `s` and `words[i]` consist of lowercase letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def expressiveWords(self, s, words):
        """
        :type s: str
        :type words: List[str]
        :rtype: int
        """
        def helper(word):
            stack = []
            for w in word:
                if not stack or w != stack[-1][0]:
                    stack.append([w, 1])
                else:
                    stack[-1][1] += 1
            return stack

        def stretchy(word1, word2):
            stack1 = helper(word1)
            stack2 = helper(word2)
            print stack1, stack2
            if len(stack1) != len(stack2):
                return False
            while stack1 and stack2:
                w1, f1 = stack1.pop()
                w2, f2 = stack2.pop()
                condition1 = w1 == w2 and f1 == f2
                condition2 = w1 == w2 and f1 - f2 > 0 and f1 >= 3
                #print w1, w2, f1, f2, condition1,  condition2

                if not condition1 and not condition2:
                    return False
            return True

        count = 0
        for j, word in enumerate(words):
            if stretchy(s, word):
                count += 1
                t = j
                print(t)
        return count
```

### [134\. Gas Station](https://leetcode.com/problems/gas-station/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/)


There are `n` gas stations along a circular route, where the amount of gas at the `i<sup>th</sup>` station is `gas[i]`.

You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `i<sup>th</sup>` station to its next `(i + 1)<sup>th</sup>` station. You begin the journey with an empty tank at one of the gas stations.

Given two integer arrays `gas` and `cost`, return _the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return_ `-1`. If there exists a solution, it is **guaranteed** to be **unique**

**Example 1:**

```
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3
Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4\. Your tank = 4 - 1 + 5 = 8
Travel to station 0\. Your tank = 8 - 2 + 1 = 7
Travel to station 1\. Your tank = 7 - 3 + 2 = 6
Travel to station 2\. Your tank = 6 - 4 + 3 = 5
Travel to station 3\. The cost is 5\. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
```

**Example 2:**

```
Input: gas = [2,3,4], cost = [3,4,3]
Output: -1
Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0\. Your tank = 4 - 3 + 2 = 3
Travel to station 1\. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
```

**Constraints:**

*   `gas.length == n`
*   `cost.length == n`
*   `1 <= n <= 10<sup>5</sup>`
*   `0 <= gas[i], cost[i] <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def canCompleteCircuit(self, gas, cost):
        """
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        """
        if sum(gas) < sum(cost):
            return -1
        remain = start = 0
        for i in range(len(gas)):
            if remain + gas[i] < cost[i]:
                remain = 0
                start = i + 1
            else:
                remain += gas[i] - cost[i]
        return start              

```

### [763\. Partition Labels :rainbow:](https://leetcode.com/problems/partition-labels/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/), [Greedy](https://leetcode.com/tag/greedy/)


You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part.

Note that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.

Return _a list of integers representing the size of these parts_.

**Example 1:**

```
Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.
```

**Example 2:**

```
Input: s = "eccbbbbdec"
Output: [10]
```

**Constraints:**

*   `1 <= s.length <= 500`
*   `s` consists of lowercase English letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def partitionLabels(self, s):
        """
        :type s: str
        :rtype: List[int]
        """
        count = {}
        res = []
        i, length = 0, len(s)
        for j in range(length):
            c = s[j]
            count[c] = j

        curLen = 0
        goal = 0
        while i < length:
            c = s[i]
            goal = max(goal, count[c])
            curLen += 1

            if goal == i:
                res.append(curLen)
                curLen = 0
            i += 1    
        return res
```

## Binary Search
### [278\. First Bad Version](https://leetcode.com/problems/first-bad-version/)

Difficulty: **Easy**  

Related Topics: [Binary Search](https://leetcode.com/tag/binary-search/), [Interactive](https://leetcode.com/tag/interactive/)


You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

**Example 1:**

```
Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.
```

**Example 2:**

```
Input: n = 1, bad = 1
Output: 1
```

**Constraints:**

*   `1 <= bad <= n <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

```python
# The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

def firstBadVersion(n, bad):
    left = 1
    right = n
    while left < right:
        mid = left + (right - left) / 2
        if isBadVersion(mid):
            right = mid
        else:
            left = mid + 1
    return left
```

### [34\. Find First and Last Position of Element in Sorted Array :rainbow:](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.

If `target` is not found in the array, return `[-1, -1]`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```

**Example 2:**

```
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
```

**Example 3:**

```
Input: nums = [], target = 0
Output: [-1,-1]
```

**Constraints:**

*   `0 <= nums.length <= 10<sup>5</sup>`
*   `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`
*   `nums` is a non-decreasing array.
*   `-10<sup>9</sup> <= target <= 10<sup>9</sup>`


#### Solution

Language: **Python**

The idea is to use `bisect` (which is also `bisect_right`) and `bisect_left` to get the range of numbers: first one will return index before all repetitions of `target` and the second one: after. So, if these two indexes are equal, it means that we did not found this element, so we return `[-1, -1]`. If we found, we return `[l, r - 1]`.

```python
class Solution(object):
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        left = self.lowwer_bound(nums, target)
        right = self.higher_bound(nums, target)
        if left == right:
            return [-1, -1]
        return [left, right - 1]

    def lowwer_bound(self, nums, target):
        # find in range [left, right)
        left, right = 0, len(nums)
        while left < right:
            mid = left + (right - left) / 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left

    def higher_bound(self, nums, target):
        # find in range [left, right)
        left, right = 0, len(nums)
        while left < right:
            mid = left + (right - left) / 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid
        return left
```

```Python
class Solution(object):
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        left = self.helper(nums, target, True)
        right = self.helper(nums, target, False)
        return [left, right]

    def helper(self, nums, target, leftBias):
        l, r = 0, len(nums) - 1
        i = -1
        while l <= r:
            m = (l + r) // 2
            if nums[m] < target:
                l = m + 1
            elif nums[m] > target:
                r = m - 1
            else:
                i = m
                if leftBias:
                    r = m - 1
                else:
                    l = m + 1
        return i
```

### [50\. Pow(x, n)](https://leetcode.com/problems/powx-n/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Recursion](https://leetcode.com/tag/recursion/)


Implement , which calculates `x` raised to the power `n` (i.e., `x<sup>n</sup>`).

**Example 1:**

```
Input: x = 2.00000, n = 10
Output: 1024.00000
```

**Example 2:**

```
Input: x = 2.10000, n = 3
Output: 9.26100
```

**Example 3:**

```
Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
```

**Constraints:**

*   `-100.0 < x < 100.0`
*   `-2<sup>31</sup> <= n <= 2<sup>31</sup>-1`
*   `-10<sup>4</sup> <= x<sup>n</sup> <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
def pow(x, n):
    if n == 0:
        return 1
    elif n == 1:
        return x
    elif n < 0:
        return 1 / pow(x, -n)
    else:
        division, carry  = divmod(n, 2)
        half = pow(x, division)
        return half * half if carry == 0 else half * half * x
```

### [528\. Random Pick with Weight](https://leetcode.com/problems/random-pick-with-weight/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Binary Search](https://leetcode.com/tag/binary-search/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/), [Randomized](https://leetcode.com/tag/randomized/)


You are given a **0-indexed** array of positive integers `w` where `w[i]` describes the **weight** of the `i<sup>th</sup>` index.

You need to implement the function `pickIndex()`, which **randomly** picks an index in the range `[0, w.length - 1]` (**inclusive**) and returns it. The **probability** of picking an index `i` is `w[i] / sum(w)`.

*   For example, if `w = [1, 3]`, the probability of picking index `0` is `1 / (1 + 3) = 0.25` (i.e., `25%`), and the probability of picking index `1` is `3 / (1 + 3) = 0.75` (i.e., `75%`).

**Example 1:**

```
Input
["Solution","pickIndex"]
[[[1]],[]]
Output
[null,0]

Explanation
Solution solution = new Solution([1]);
solution.pickIndex(); // return 0\. The only option is to return 0 since there is only one element in w.
```

**Example 2:**

```
Input
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
Output
[null,1,1,1,1,0]

Explanation
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // return 1\. It is returning the second element (index = 1) that has a probability of 3/4.
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 0\. It is returning the first element (index = 0) that has a probability of 1/4.

Since this is a randomization problem, multiple answers are allowed.
All of the following outputs can be considered correct:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
and so on.
```

**Constraints:**

*   `1 <= w.length <= 10<sup>4</sup>`
*   `1 <= w[i] <= 10<sup>5</sup>`
*   `pickIndex` will be called at most `10<sup>4</sup>` times.


#### Solution

Language: **Python**

```python
class Solution:
    def __init__(self, w):
        """
        :type w: List[int]
        """
        self.prefix_sums = []
        prefix_sum = 0
        for weight in w:
            prefix_sum += weight
            self.prefix_sums.append(prefix_sum)
        self.total_sum = prefix_sum

    def pickIndex(self):
        """
        :rtype: int
        """
        '''
        target = self.total_sum * random()
        # run a linear search to find the target zone
        for i, prefix_sum in enumerate(self.prefix_sums):
            if target < prefix_sum:
                return i
        '''
        target = self.total_sum * random.random()
        # run a binary search to find the target zone
        low, high = 0, len(self.prefix_sums)
        while low < high:
            mid = low + (high - low) // 2
            if self.prefix_sums[mid] < target:
                low = mid + 1
            else:
                high = mid
        return low
solution = Solution([1, 3])
solution.pickIndex()
solution.pickIndex()
solution.pickIndex()
solution.pickIndex()
```

### [33\. Search in Rotated Sorted Array :rainbow:](https://leetcode.com/problems/search-in-rotated-sorted-array/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Example 3:**

```
Input: nums = [1], target = 0
Output: -1
```

**Constraints:**

*   `1 <= nums.length <= 5000`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
*   All values of `nums` are **unique**.
*   `nums` is an ascending array that is possibly rotated.
*   `-10<sup>4</sup> <= target <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
def search(nums, target):
    if not nums:
        return -1
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] < nums[right]:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
        else:
            if target < nums[mid] and target >= nums[left]:
                right = mid - 1
            else:
                left = mid + 1
    return -1

search(nums = [4,5,6,7,0,1,2], target = 0)
search(nums = [4,5,6,7,0,1,2], target = 3)
search(nums = [1], target = 0)
```

```python
def search(nums, target):
    if not nums:
        return False
    l, r = 0, len(nums)-1
    while l <= r:
        mid = l + (r-l)//2
        if nums[mid] == target:
            return mid
        # the first half is ordered
        if nums[l] <= nums[mid]:
            # target is in the first half
            if nums[l] <= target < nums[mid]:
                r = mid - 1
            else:
                l = mid + 1
        # the second half is ordered
        else:
            # target is in the second half
            if nums[mid] < target <= nums[r]:
                l = mid + 1
            else:
                r = mid - 1
    return -1

search(nums = [4,5,6,7,0,1,2], target = 0)
search(nums = [4,5,6,7,0,1,2], target = 3)
```

### [1060\. Missing Element in Sorted Array :fire:](https://leetcode.com/problems/missing-element-in-sorted-array/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


Given an integer array `nums` which is sorted in **ascending order** and all of its elements are **unique** and given also an integer `k`, return the `k<sup>th</sup>` missing number starting from the leftmost number of the array.

**Example 1:**

```
Input: nums = [4,7,9,10], k = 1
Output: 5
Explanation: The first missing number is 5.
```

**Example 2:**

```
Input: nums = [4,7,9,10], k = 3
Output: 8
Explanation: The missing numbers are [5,6,8,...], hence the third missing number is 8.
```

**Example 3:**

```
Input: nums = [1,2,4], k = 3
Output: 6
Explanation: The missing numbers are [3,5,6,7,...], hence the third missing number is 6.
```

**Constraints:**

*   `1 <= nums.length <= 5 * 10<sup>4</sup>`
*   `1 <= nums[i] <= 10<sup>7</sup>`
*   `nums` is sorted in **ascending order,** and all the elements are **unique**.
*   `1 <= k <= 10<sup>8</sup>`

**Follow up:** Can you find a logarithmic time complexity (i.e., `O(log(n))`) solution?

#### Solution

Language: **Python**

```python
def missingElement(nums, k):
    prev = nums[0]
    for num in nums[1: ]:
        if k < num - prev:
            return prev + k
        else:
            k -= num - prev - 1
        prev = num
    return num + k

missingElement([4,7,9,10], 1)
missingElement([4,7,9,10], 3)
missingElement([1,2,4], 3)

class Solution(object):
    def missingElement(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        l = 0
        r = len(nums)
        while l < r - 1:
            m = (l + r)  // 2
            missing = (nums[m] -nums[l]) - (m - l)
            if missing < k:
                l = m
                k -= missing
            else:
                r = m
        return nums[l] + k
```

### [162\. Find Peak Element](https://leetcode.com/problems/find-peak-element/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


A peak element is an element that is strictly greater than its neighbors.

Given an integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.

You may imagine that `nums[-1] = nums[n] = -`.

You must write an algorithm that runs in `O(log n)` time.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
```

**Example 2:**

```
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
```

**Constraints:**

*   `1 <= nums.length <= 1000`
*   `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`
*   `nums[i] != nums[i + 1]` for all valid `i`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def findPeakElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < nums[mid + 1]:
                left = mid + 1
            else:
                right = mid
        return left
```

### [658\. Find K Closest Elements :rainbow:](https://leetcode.com/problems/find-k-closest-elements/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Binary Search](https://leetcode.com/tag/binary-search/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/)


Given a **sorted** integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order.

An integer `a` is closer to `x` than an integer `b` if:

*   `|a - x| < |b - x|`, or
*   `|a - x| == |b - x|` and `a < b`

**Example 1:**

```
Input: arr = [1,2,3,4,5], k = 4, x = 3
Output: [1,2,3,4]
```

**Example 2:**

```
Input: arr = [1,2,3,4,5], k = 4, x = -1
Output: [1,2,3,4]
```

**Constraints:**

*   `1 <= k <= arr.length`
*   `1 <= arr.length <= 10<sup>4</sup>`
*   `arr` is sorted in **ascending** order.
*   `-10<sup>4</sup> <= arr[i], x <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
# sol-1: O(nlogk)
from heapq import heappush, heappop

def findClosestElements(arr, k, x):
    heap = []
    for i, num in enumerate(arr):
        distance = abs(num - x)
        heappush(heap, (-distance, i))
        if i > k - 1:
            heappop(heap)
    return sorted([arr[i] for distance, i in heap])

findClosestElements(arr = [1,2,3,4,5], k = 4, x = 3)
findClosestElements(arr = [1,2,3,4,5], k = 4, x = -1)

# sol-2: O(n)
def findClosestElements(arr, k, x):
    i = 0
    j = len(arr) - 1
    while j - i > k:
        if abs(arr[i] - x) > abs(arr[j] - x):
            i += 1
        else:
            j -= 1
    return arr[i: j]

findClosestElements(arr = [1,2,3,4,5], k = 4, x = 3)
findClosestElements(arr = [1,2,3,4,5], k = 4, x = -1)

# sol-3: O(log(n))
def findClosestElements(arr, k, x):
    left = 0
    right = len(arr) - k
    while left < right:
        mid = left + (right - left) // 2
        if abs(x - arr[mid]) > abs(x - arr[mid + k]):
            left = mid + 1
        else:
            right = mid
    return arr[left: left + k]

findClosestElements(arr = [1,2,3,4,5], k = 4, x = 3)
findClosestElements(arr = [1,2,3,4,5], k = 4, x = -1)
```

### [240\. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Matrix](https://leetcode.com/tag/matrix/)


Write an efficient algorithm that searches for a `target` value in an `m x n` integer `matrix`. The `matrix` has the following properties:

*   Integers in each row are sorted in ascending from left to right.
*   Integers in each column are sorted in ascending from top to bottom.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg)

```
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg)

```
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
Output: false
```

**Constraints:**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= n, m <= 300`
*   `-10<sup>9</sup> <= matrix[i][j] <= 10<sup>9</sup>`
*   All the integers in each row are **sorted** in ascending order.
*   All the integers in each column are **sorted** in ascending order.
*   `-10<sup>9</sup> <= target <= 10<sup>9</sup>`


#### Solution

Language: **Python**

```python
# sol1: starting from left bottom
# time: O(m+n)
def searchMatrix(matrix, target):
    if matrix == [] or matrix[0] == []:
        return 0

    row, column = len(matrix), len(matrix[0])
    i, j = row - 1, 0
    while i >= 0 and j < column:
        if matrix[i][j] == target:
            return True
        elif matrix[i][j] < target:
            j += 1
        elif matrix[i][j] > target:
            i -= 1
    return False

if __name__ == '__main__':
    matrix = [[1, 4, 7, 11, 15],
              [2, 5, 8, 12, 19],
              [3, 6, 9, 16, 22],
              [10, 13, 14, 17, 24],
              [18, 21, 23, 26, 30]]
    searchMatrix(matrix, 20)

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        ROWS, COLS = len(matrix), len(matrix[0])

        top, bot = 0, ROWS - 1
        while top <= bot:
            row = (top + bot) // 2
            if target > matrix[row][-1]:
                top = row + 1
            elif target < matrix[row][0]:
                bot = row - 1
            else:
                break

        if not (top <= bot):
            return False
        row = (top + bot) // 2
        l, r = 0, COLS - 1
        while l <= r:
            m = (l + r) // 2
            if target > matrix[row][m]:
                l = m + 1
            elif target < matrix[row][m]:
                r = m - 1
            else:
                return True
        return False
```

### [230\. Kth Smallest Element in a BST :rainbow:](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary search tree, and an integer `k`, return _the_ `k<sup>th</sup>` _smallest value (**1-indexed**) of all the values of the nodes in the tree_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```
Input: root = [3,1,4,null,2], k = 1
Output: 1
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
```

**Constraints:**

*   The number of nodes in the tree is `n`.
*   `1 <= k <= n <= 10<sup>4</sup>`
*   `0 <= Node.val <= 10<sup>4</sup>`

**Follow up:** If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

# inorder traversal
def kthSmallest(root, k):
    return helper(root)[k - 1]

def helper(root):
    if not root:
        return []
    return helper(root.left) + [root.val] + helper(root.right)


# Recursive:
def kthSmallest(self, root, k):
    self.k = k
    self.res = None
    self.helper(root)
    return self.res

def helper(self, node):
    if not node:
        return
    self.helper(node.left)
    self.k -= 1
    if self.k == 0:
        self.res = node.val
        return
    self.helper(node.right)   

# Iterative:
def kthSmallest(root, k):
    stack = []
    while root or stack:
        while root:
            stack.append(root)
            root = root.left
        root = stack.pop()
        k -= 1
        if k == 0:
            return root.val
        root = root.right
```

### [300\. Longest Increasing Subsequence :fire:](https://leetcode.com/problems/longest-increasing-subsequence/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given an integer array `nums`, return the length of the longest strictly increasing subsequence.

A **subsequence** is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`.

**Example 1:**

```
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
```

**Example 2:**

```
Input: nums = [0,1,0,3,2,3]
Output: 4
```

**Example 3:**

```
Input: nums = [7,7,7,7,7,7,7]
Output: 1
```

**Constraints:**

*   `1 <= nums.length <= 2500`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`

**Follow up:** Can you come up with an algorithm that runs in `O(n log(n))` time complexity?


#### Solution

Language: **Python**

```python
def lengthOfLIS(nums):
    n = len(nums)
    dp = [1] * n
    for i in xrange(n - 1, -1, -1):
        for j in xrange(i + 1, n):
            if nums[i] < nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

lengthOfLIS([10,9,2,5,3,7,101,18])

from bisect import bisect_left

def lengthOfLIS(nums):
    sub = []
    for num in nums:
        i = bisect_left(sub, num)

        # If num is greater than any element in sub
        if i == len(sub):
            sub.append(num)

        # Otherwise, replace the first element in sub greater than or equal to num
        else:
            sub[i] = num
        print sub
    return len(sub)

lengthOfLIS([10,9,2,5,3,7,101,18])
```


### [852\. Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


Let's call an array `arr` a **mountain** if the following properties hold:

*   `arr.length >= 3`
*   There exists some `i` with `0 < i < arr.length - 1` such that:
    *   `arr[0] < arr[1] < ... arr[i-1] < arr[i]`
    *   `arr[i] > arr[i+1] > ... > arr[arr.length - 1]`

Given an integer array `arr` that is **guaranteed** to be a mountain, return any `i` such that `arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`.

**Example 1:**

```
Input: arr = [0,1,0]
Output: 1
```

**Example 2:**

```
Input: arr = [0,2,1,0]
Output: 1
```

**Example 3:**

```
Input: arr = [0,10,5,2]
Output: 1
```

**Example 4:**

```
Input: arr = [3,4,5,1]
Output: 2
```

**Example 5:**

```
Input: arr = [24,69,100,99,79,78,67,36,26,19]
Output: 2
```

**Constraints:**

*   `3 <= arr.length <= 10<sup>4</sup>`
*   `0 <= arr[i] <= 10<sup>6</sup>`
*   `arr` is **guaranteed** to be a mountain array.

**Follow up:** Finding the `O(n)` is straightforward, could you find an `O(log(n))` solution?

#### Solution

Language: **Python**

```python
def findPeakElement(nums):
    left = 0
    right = len(nums) - 1
    while left < right:
        mid = left + (right - left) // 2
        print left, right, mid
        if nums[mid] > nums[mid - 1] and nums[mid] > nums[mid + 1]:
            return mid
        elif nums[mid] < nums[mid + 1]:
            left = mid + 1
        else:
            right = mid

findPeakElement([0,1,0])
findPeakElement([0,2,1,0])
findPeakElement([0,10,5,2])
findPeakElement(nums = [3,4,5,1])        
findPeakElement([24,69,100,99,79,78,67,36,26,19])   
```

### [69\. Sqrt(x)](https://leetcode.com/problems/sqrtx/)

Difficulty: **Easy**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Binary Search](https://leetcode.com/tag/binary-search/)


Given a non-negative integer `x`, compute and return _the square root of_ `x`.

Since the return type is an integer, the decimal digits are **truncated**, and only **the integer part** of the result is returned.

**Note: **You are not allowed to use any built-in exponent function or operator, such as `pow(x, 0.5)` or `x ** 0.5`.

**Example 1:**

```
Input: x = 4
Output: 2
```

**Example 2:**

```
Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.
```

**Constraints:**

*   `0 <= x <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

* [Newton's method](https://en.wikipedia.org/wiki/Newton%27s_method#Square_root)
```python
def sqrt(x):
    left, right = 0, x + 1
    while left < right:
        mid = left + (right - left) // 2
        if mid ** 2 == x:
            return mid
        elif mid ** 2 < x:
            left = mid + 1
        else:
            right = mid
    return left - 1

def mySqrt(a):
    x = a
    while x * x > a:
        x = (x + a // x) // 2
    return x
```

### [367\. Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square/)

Difficulty: **Easy**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Binary Search](https://leetcode.com/tag/binary-search/)


Given a **positive** integer _num_, write a function which returns True if _num_ is a perfect square else False.

**Follow up:** **Do not** use any built-in library function such as `sqrt`.

**Example 1:**

```
Input: num = 16
Output: true
```

**Example 2:**

```
Input: num = 14
Output: false
```

**Constraints:**

*   `1 <= num <= 2^31 - 1`


#### Solution

Language: **Python**

```python
class Solution(object):
    def isPerfectSquare(self, num):
        """
        :type num: int
        :rtype: bool
        """
        left = 0
        right = num
        while left <= right:
            mid = left + (right-left)//2
            if  mid ** 2 == num:
                return True
            elif mid ** 2 > num:
                right = mid -1
            else:
                left = mid +1
        return False
```

### [81\. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


There is an integer array `nums` sorted in non-decreasing order (not necessarily with **distinct** values).

Before being passed to your function, `nums` is **rotated** at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index `5` and become `[4,5,6,6,7,0,1,2,4,4]`.

Given the array `nums` **after** the rotation and an integer `target`, return `true` _if_ `target` _is in_ `nums`_, or_ `false` _if it is not in_ `nums`_._

You must decrease the overall operation steps as much as possible.

**Example 1:**

```
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
```

**Example 2:**

```
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
```

**Constraints:**

*   `1 <= nums.length <= 5000`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
*   `nums` is guaranteed to be rotated at some pivot.
*   `-10<sup>4</sup> <= target <= 10<sup>4</sup>`

**Follow up:** This problem is similar to , but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?


#### Solution

Language: **Python**


```python
def search(nums, target):
    l, r = 0, len(nums)-1
    while l <= r:
        while l < r and nums[l] == nums[r]: # tricky part
            l += 1
        mid = l + (r-l)//2
        if nums[mid] == target:
            return True
        # the first half is ordered
        if nums[l] <= nums[mid]:
            # target is in the first half
            if nums[l] <= target < nums[mid]:
                r = mid - 1
            else:
                l = mid + 1
        # the second half is ordered
        else:
            # target is in the second half
            if nums[mid] < target <= nums[r]:
                l = mid + 1
            else:
                r = mid - 1
    return False

search(nums = [2,5,6,0,0,1,2], target = 0) == True
search(nums = [2,5,6,0,0,1,2], target = 3) == False
```

### [744\. Find Smallest Letter Greater Than Target](https://leetcode.com/problems/find-smallest-letter-greater-than-target/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


Given a characters array `letters` that is sorted in **non-decreasing** order and a character `target`, return _the smallest character in the array that is larger than_ `target`.

**Note** that the letters wrap around.

*   For example, if `target == 'z'` and `letters == ['a', 'b']`, the answer is `'a'`.

**Example 1:**

```
Input: letters = ["c","f","j"], target = "a"
Output: "c"
```

**Example 2:**

```
Input: letters = ["c","f","j"], target = "c"
Output: "f"
```

**Example 3:**

```
Input: letters = ["c","f","j"], target = "d"
Output: "f"
```

**Example 4:**

```
Input: letters = ["c","f","j"], target = "g"
Output: "j"
```

**Example 5:**

```
Input: letters = ["c","f","j"], target = "j"
Output: "c"
```

**Constraints:**

*   `2 <= letters.length <= 10<sup>4</sup>`
*   `letters[i]` is a lowercase English letter.
*   `letters` is sorted in **non-decreasing** order.
*   `letters` contains at least two different characters.
*   `target` is a lowercase English letter.


#### Solution

Language: **Python**

```python
import bisect

def nextGreatestLetter(letters, target):
    index = bisect.bisect_right(letters, target)
    return letters[index] if index < len(letters) else letters[0]

def nextGreatestLetter(letters, target):

    n = len(letters)
    if target < letters[0]:
        return letters[0]
    if target >= letters[n - 1]:
        return letters[0]
    left = 0
    right = n - 1
    while left <= right:
        mid = (left + right) // 2
        if letters[mid] == target:
            return letters[mid + 1]
        elif letters[mid] < target:
            left = mid + 1
        else:
            result = letters[mid]
            right = mid - 1
    return result

nextGreatestLetter(letters = ["c","f","j"], target = "a")
nextGreatestLetter(letters = ["c","f","j"], target = "c")
nextGreatestLetter(letters = ["c","f","j"], target = "d")
nextGreatestLetter(letters = ["c","f","j"], target = "g")
nextGreatestLetter(letters = ["c","f","j"], target = "j")        
```

### [981\. Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Binary Search](https://leetcode.com/tag/binary-search/), [Design](https://leetcode.com/tag/design/)


Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.

Implement the `TimeMap` class:

*   `TimeMap()` Initializes the object of the data structure.
*   `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time `timestamp`.
*   `String get(String key, int timestamp)` Returns a value such that `set` was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `""`.

**Example 1:**

```
Input
["TimeMap", "set", "get", "get", "set", "get", "get"]
[[], ["foo", "bar", 1], ["foo", 1], ["foo", 3], ["foo", "bar2", 4], ["foo", 4], ["foo", 5]]
Output
[null, null, "bar", "bar", null, "bar2", "bar2"]

Explanation
TimeMap timeMap = new TimeMap();
timeMap.set("foo", "bar", 1);  // store the key "foo" and value "bar" along with timestamp = 1.
timeMap.get("foo", 1);         // return "bar"
timeMap.get("foo", 3);         // return "bar", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is "bar".
timeMap.set("foo", "bar2", 4); // store the key "foo" and value "bar2" along with timestamp = 4.
timeMap.get("foo", 4);         // return "bar2"
timeMap.get("foo", 5);         // return "bar2"
```

**Constraints:**

*   `1 <= key.length, value.length <= 100`
*   `key` and `value` consist of lowercase English letters and digits.
*   `1 <= timestamp <= 10<sup>7</sup>`
*   All the timestamps `timestamp` of `set` are strictly increasing.
*   At most `2 * 10<sup>5</sup>` calls will be made to `set` and `get`.


#### Solution

Language: **Python**

```python
from collections import defaultdict
from bisect import bisect_right

class TimeMap:
    def __init__(self):
        self.ktimestamp = defaultdict(list)
        self.kv = defaultdict(list)

    def set(self, key: 'str', value: 'str', timestamp: 'int') -> 'None':
        self.kv[key].append(value)
        self.ktimestamp[key].append(timestamp)

    def get(self, key: 'str', timestamp: 'int') -> 'str':
        if key not in self.kv: return ''
        idx = bisect_right(self.ktimestamp[key], timestamp)
        return '' if idx == 0 else self.kv[key][idx-1]


class TimeMap(object):

    def __init__(self):
        self.dic = collections.defaultdict(list)


    def set(self, key, value, timestamp):
        self.dic[key].append([timestamp, value])

    def get(self, key, timestamp):
        arr = self.dic[key]
        n = len(arr)

        left = 0
        right = n

        while left < right:
            mid = (left + right) / 2
            if arr[mid][0] <= timestamp:
                left = mid + 1
            elif arr[mid][0] > timestamp:
                right = mid

        return "" if right == 0 else arr[right - 1][1]
```

### [1235\. Maximum Profit in Job Scheduling :fire:](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Sorting](https://leetcode.com/tag/sorting/)


We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.

You're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.

**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png)**

```
Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job.
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.
```

**Example 2:**

**![](https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png)**

```
Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job.
Profit obtained 150 = 20 + 70 + 60.
```

**Example 3:**

**![](https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png)**

```
Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6
```

**Constraints:**

*   `1 <= startTime.length == endTime.length == profit.length <= 5 * 10<sup>4</sup>`
*   `1 <= startTime[i] < endTime[i] <= 10<sup>9</sup>`
*   `1 <= profit[i] <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        # Init
        jobs = sorted(zip(startTime, endTime, profit))
        startTime.sort()
        n = len(startTime)

        # MACROS
        START_TIME, END_TIME, PROFIT = 0, 1, 2

        @cache # recursion with memoization
        def schedule(jobIdx):

            # Check if the job id is valid
            if (0 <= jobIdx < n):

                # Get the next non-conflicting job which can be scheduled with the current job
                nextJobIdx = bisect_left(startTime, jobs[jobIdx][END_TIME])

                # Calc max profit, in case if the current job is scheduled
                # verses the current job is not scheduled
                # Case 1: Current job is scheduled, hence,
                # the next "non conflicting" job is also scheduled
                # Case 2: Current job is not scheduled, hence,
                # the very next is scheduled
                jobProfit =  max(jobs[jobIdx][PROFIT] + schedule(nextJobIdx), schedule(jobIdx+1))

                return jobProfit # return the profit

            return 0 # default return

        return schedule(0) # schedule from the first job
```

### [1482\. Minimum Number of Days to Make m Bouquets :rainbow:](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


Given an integer array `bloomDay`, an integer `m` and an integer `k`.

We need to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden.

The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet.

Return _the minimum number of days_ you need to wait to be able to make `m` bouquets from the garden. If it is impossible to make `m` bouquets return **-1**.

**Example 1:**

```
Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
Output: 3
Explanation: Let's see what happened in the first three days. x means flower bloomed and _ means flower didn't bloom in the garden.
We need 3 bouquets each should contain 1 flower.
After day 1: [x, _, _, _, _]   // we can only make one bouquet.
After day 2: [x, _, _, _, x]   // we can only make two bouquets.
After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.
```

**Example 2:**

```
Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
Output: -1
Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.
```

**Example 3:**

```
Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
Output: 12
Explanation: We need 2 bouquets each should have 3 flowers.
Here's the garden after the 7 and 12 days:
After day 7: [x, x, x, x, _, x, x]
We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.
After day 12: [x, x, x, x, x, x, x]
It is obvious that we can make two bouquets in different ways.
```

**Example 4:**

```
Input: bloomDay = [1000000000,1000000000], m = 1, k = 1
Output: 1000000000
Explanation: You need to wait 1000000000 days to have a flower ready for a bouquet.
```

**Example 5:**

```
Input: bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2
Output: 9
```

**Constraints:**

*   `bloomDay.length == n`
*   `1 <= n <= 10^5`
*   `1 <= bloomDay[i] <= 10^9`
*   `1 <= m <= 10^6`
*   `1 <= k <= n`


#### Solution

Language: **Python**

```python
class Solution(object):
    def minDays(self, bloomDay, m, k):
        """
        :type bloomDay: List[int]
        :type m: int
        :type k: int
        :rtype: int
        """
        def feasible(days):
            bonquets, flowers = 0, 0
            for bloom in bloomDay:
                if bloom > days:
                    flowers = 0
                else:
                    bonquets += (flowers + 1) // k
                    flowers = (flowers + 1) % k
            return bonquets >= m

        if len(bloomDay) < m * k:
            return -1
        left, right = 1, max(bloomDay)
        while left < right:
            mid = left + (right - left) // 2
            if feasible(mid):
                right = mid
            else:
                left = mid + 1
        return left
```

### [1011\. Capacity To Ship Packages Within D Days :rainbow:](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Greedy](https://leetcode.com/tag/greedy/)


A conveyor belt has packages that must be shipped from one port to another within `days` days.

The `i<sup>th</sup>` package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `days` days.

**Example 1:**

```
Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
Output: 15
Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10

Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.
```

**Example 2:**

```
Input: weights = [3,2,2,4,1,4], days = 3
Output: 6
Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:
1st day: 3, 2
2nd day: 2, 4
3rd day: 1, 4
```

**Example 3:**

```
Input: weights = [1,2,3,1,1], days = 4
Output: 3
Explanation:
1st day: 1
2nd day: 2
3rd day: 3
4th day: 1, 1
```

**Constraints:**

*   `1 <= days <= weights.length <= 5 * 10<sup>4</sup>`
*   `1 <= weights[i] <= 500`


#### Solution

Language: **Python**

```python
class Solution(object):
    def shipWithinDays(self, weights, days):
        """
        :type weights: List[int]
        :type days: int
        :rtype: int
        """
        def count_days(capacity, days, weights):
            count = 1
            cum_sum = 0
            for weight in weights:
                if cum_sum + weight <= capacity:
                    cum_sum += weight
                else:
                    cum_sum = weight
                    count += 1
            return count

        l = max(weights)
        r = sum(weights)
        while l < r:
            m = (r + l) // 2
            if count_days(m, days, weights) == days:
                r = m
            elif count_days(m, days, weights) > days:
                l = m + 1
            else:
                r = m
        return l
```

### [268\. Missing Number](https://leetcode.com/problems/missing-number/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/), [Sorting](https://leetcode.com/tag/sorting/)


Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._

**Example 1:**

```
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
```

**Example 2:**

```
Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
```

**Example 3:**

```
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
```

**Example 4:**

```
Input: nums = [0]
Output: 1
Explanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.
```

**Constraints:**

*   `n == nums.length`
*   `1 <= n <= 10<sup>4</sup>`
*   `0 <= nums[i] <= n`
*   All the numbers of `nums` are **unique**.

**Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?


#### Solution

Language: **Python**

```python
class Solution:
    def missingNumber(self, nums):
        num_set = set(nums)
        n = len(nums) + 1
        for number in range(n):
            if number not in num_set:
                return number

nums = [3,0,1]
nums.sort()
left, right = 0, len(nums) - 1
while left < right:
    mid = (left + right) // 2
    if nums[mid] > mid:
        right = mid
    else:
        left = mid + 1
left
```

### [633\. Sum of Square Numbers](https://leetcode.com/problems/sum-of-square-numbers/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Binary Search](https://leetcode.com/tag/binary-search/)


Given a non-negative integer `c`, decide whether there're two integers `a` and `b` such that `a<sup>2</sup> + b<sup>2</sup> = c`.

**Example 1:**

```
Input: c = 5
Output: true
Explanation: 1 * 1 + 2 * 2 = 5
```

**Example 2:**

```
Input: c = 3
Output: false
```

**Example 3:**

```
Input: c = 4
Output: true
```

**Example 4:**

```
Input: c = 2
Output: true
```

**Example 5:**

```
Input: c = 1
Output: true
```

**Constraints:**

*   `0 <= c <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

```python
class Solution(object):
    def judgeSquareSum(self, c):
        """
        :type c: int
        :rtype: bool
        """
        left, right = 0, int(c ** 0.5)
        while left <= right:
            cur = left ** 2 + right ** 2
            if cur > c:
                right -= 1
            elif cur <c:
                left += 1
            else:
                return True
        return False
```

### [702\. Search in a Sorted Array of Unknown Size](https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Interactive](https://leetcode.com/tag/interactive/)


This is an **_interactive problem_**.

You have a sorted array of **unique** elements and an **unknown size**. You do not have an access to the array but you can use the `ArrayReader` interface to access it. You can call `ArrayReader.get(i)` that:

*   returns the value at the `i<sup>th</sup>` index (**0-indexed**) of the secret array (i.e., `secret[i]`), or
*   returns `2<sup>31</sup> - 1` if the `i` is out of the boundary of the array.

You are also given an integer `target`.

Return the index `k` of the hidden array where `secret[k] == target` or return `-1` otherwise.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: secret = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in secret and its index is 4.
```

**Example 2:**

```
Input: secret = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in secret so return -1.
```

**Constraints:**

*   `1 <= secret.length <= 10<sup>4</sup>`
*   `-10<sup>4</sup> <= secret[i], target <= 10<sup>4</sup>`
*   `secret` is sorted in a strictly increasing order.


#### Solution

Language: **Python**

```python
class Solution(object):
    def search(self, reader, target):
        """
        :type reader: ArrayReader
        :type target: int
        :rtype: int
        """
        low = 0
        high = 1

        while reader.get(high) < target:
            low = high
            high *= 2

        while low <= high:
            mid = (low + high)/2

            if reader.get(mid) == target:
                return mid
            elif reader.get(mid) > target:
                high = mid - 1
            else:
                low = mid + 1
        return -1
```

### [1891\. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


You are given an integer array `ribbons`, where `ribbons[i]` represents the length of the `i<sup>th</sup>` ribbon, and an integer `k`. You may cut any of the ribbons into any number of segments of **positive integer** lengths, or perform no cuts at all.

*   For example, if you have a ribbon of length `4`, you can:
    *   Keep the ribbon of length `4`,
    *   Cut it into one ribbon of length `3` and one ribbon of length `1`,
    *   Cut it into two ribbons of length `2`,
    *   Cut it into one ribbon of length `2` and two ribbons of length `1`, or
    *   Cut it into four ribbons of length `1`.

Your goal is to obtain `k` ribbons of all the **same positive integer length**. You are allowed to throw away any excess ribbon as a result of cutting.

Return _the **maximum** possible positive integer length that you can obtain_ `k` _ribbons of__, or_ `0` _if you cannot obtain_ `k` _ribbons of the same length_.

**Example 1:**

```
Input: ribbons = [9,7,5], k = 3
Output: 5
Explanation:
- Cut the first ribbon to two ribbons, one of length 5 and one of length 4.
- Cut the second ribbon to two ribbons, one of length 5 and one of length 2.
- Keep the third ribbon as it is.
Now you have 3 ribbons of length 5.
```

**Example 2:**

```
Input: ribbons = [7,5,9], k = 4
Output: 4
Explanation:
- Cut the first ribbon to two ribbons, one of length 4 and one of length 3.
- Cut the second ribbon to two ribbons, one of length 4 and one of length 1.
- Cut the third ribbon to three ribbons, two of length 4 and one of length 1.
Now you have 4 ribbons of length 4.
```

**Example 3:**

```
Input: ribbons = [5,7,9], k = 22
Output: 0
Explanation: You cannot obtain k ribbons of the same positive integer length.
```

**Constraints:**

*   `1 <= ribbons.length <= 10<sup>5</sup>`
*   `1 <= ribbons[i] <= 10<sup>5</sup>`
*   `1 <= k <= 10<sup>9</sup>`


#### Solution

Language: **Python**

```Python
ribbons = [7,5,9]; k = 4
class Solution:
    def maxLength(self, ribbons: List[int], k: int) -> int:
        total = sum(ribbons)
        if k > total:
            return 0

        lo, hi = 1, min(total // k, max(ribbons))

        while lo < hi:
            mid = (lo + hi + 1) // 2
            if sum(x // mid for x in ribbons) >= k:
                lo = mid
            else:
                hi = mid - 1

        return lo
```

### [1539\. Kth Missing Positive Number :rainbow:](https://leetcode.com/problems/kth-missing-positive-number/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


Given an array `arr` of positive integers sorted in a **strictly increasing order**, and an integer `<font face="monospace" style="display: inline;">k</font>`.

_Find the_ <font face="monospace" style="display: inline;">`k<sup>th</sup>`</font>_ positive integer that is missing from this array._

**Example 1:**

```
Input: arr = [2,3,4,7,11], k = 5
Output: 9
Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.
```

**Example 2:**

```
Input: arr = [1,2,3,4], k = 2
Output: 6
Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6.
```

**Constraints:**

*   `1 <= arr.length <= 1000`
*   `1 <= arr[i] <= 1000`
*   `1 <= k <= 1000`
*   `arr[i] < arr[j]` for `1 <= i < j <= arr.length`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/kth-missing-positive-number/solution/)
```Python
A     = [2,3,4,7,11]; k = 5
index = [0,1,2,3,4]
miss  = [1,1,1,3,6] #l 3 6 

class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] - mid - 1 < k:
                left = mid + 1
            else:
                right = mid - 1
        return left + k
```

### [275\. H-Index II](https://leetcode.com/problems/h-index-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `i<sup>th</sup>` paper and `citations` is sorted in an **ascending order**, return compute the researcher's `h`**-index**.

According to the : A scientist has an index `h` if `h` of their `n` papers have at least `h` citations each, and the other `n  h` papers have no more than `h` citations each.

If there are several possible values for `h`, the maximum one is taken as the `h`**-index**.

You must write an algorithm that runs in logarithmic time.

**Example 1:**

```
Input: citations = [0,1,3,5,6]
Output: 3
Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
```

**Example 2:**

```
Input: citations = [1,2,100]
Output: 2
```

**Constraints:**

*   `n == citations.length`
*   `1 <= n <= 10<sup>5</sup>`
*   `0 <= citations[i] <= 1000`
*   `citations` is sorted in **ascending order**.


#### Solution

Language: **Python**

```Python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        l, r = 0, n -1
        while l < r:
            mid = (l + r) // 2
            if citations[mid]  == n - mid:
                return n - mid
            elif citations[mid] > n - mid:
                mid = r - 1
            else:
                mid = l + 1
        return n - l
```

### [1351\. Count Negative Numbers in a Sorted Matrix](https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Matrix](https://leetcode.com/tag/matrix/)


Given a `m x n` matrix `grid` which is sorted in non-increasing order both row-wise and column-wise, return _the number of **negative** numbers in_ `grid`.

**Example 1:**

```
Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
Output: 8
Explanation: There are 8 negatives number in the matrix.
```

**Example 2:**

```
Input: grid = [[3,2],[1,0]]
Output: 0
```

**Constraints:**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 100`
*   `-100 <= grid[i][j] <= 100`

**Follow up:** Could you find an `O(n + m)` solution?

#### Solution

Language: **Python**

```python
class Solution(object):
    def countNegatives(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """

        def helper(vec):
            l, r = 0, n
            while l < r:
                mid = (l + r) / 2
                if vec[mid] == 0:
                    l = mid + 1
                elif vec[mid] < 0:
                    r = mid
                else:
                    l = mid + 1
            return l

        m, n = len(grid), len(grid[0])
        count = 0
        for row in grid:
            index = helper(row)
            count += n - index
            print index, n, count, n - index
        return count
```

### [14\. Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)

Difficulty: **Easy**  

Related Topics: [String](https://leetcode.com/tag/string/)


Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string `""`.

**Example 1:**

```
Input: strs = ["flower","flow","flight"]
Output: "fl"
```

**Example 2:**

```
Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
```

**Constraints:**

*   `1 <= strs.length <= 200`
*   `0 <= strs[i].length <= 200`
*   `strs[i]` consists of only lower-case English letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        n = float('inf')
        for s in strs:
            size = len(s)
            n = min(n, size)

        l, r = 0, n
        while l <= r:
            m = (r + l) // 2
            if all(strs[0][: m] == s[:m] for s in strs[1: ]):
                l = m + 1
            else:
                r = m - 1
        return strs[0][: (r + l) // 2]
```

### [1348\. Tweet Counts Per Frequency :rainbow:](https://leetcode.com/problems/tweet-counts-per-frequency/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Binary Search](https://leetcode.com/tag/binary-search/), [Design](https://leetcode.com/tag/design/), [Sorting](https://leetcode.com/tag/sorting/), [Ordered Set](https://leetcode.com/tag/ordered-set/)


A social media company is trying to monitor activity on their site by analyzing the number of tweets that occur in select periods of time. These periods can be partitioned into smaller **time chunks** based on a certain frequency (every **minute**, **hour**, or **day**).

For example, the period `[10, 10000]` (in **seconds**) would be partitioned into the following **time chunks** with these frequencies:

*   Every **minute** (60-second chunks): `[10,69]`, `[70,129]`, `[130,189]`, `...`, `[9970,10000]`
*   Every **hour** (3600-second chunks): `[10,3609]`, `[3610,7209]`, `[7210,10000]`
*   Every **day** (86400-second chunks): `[10,10000]`

Notice that the last chunk may be shorter than the specified frequency's chunk size and will always end with the end time of the period (`10000` in the above example).

Design and implement an API to help the company with their analysis.

Implement the `TweetCounts` class:

*   `TweetCounts()` Initializes the `TweetCounts` object.
*   `void recordTweet(String tweetName, int time)` Stores the `tweetName` at the recorded `time` (in **seconds**).
*   `List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)` Returns a list of integers representing the number of tweets with `tweetName` in each **time chunk** for the given period of time `[startTime, endTime]` (in **seconds**) and frequency `freq`.
    *   `freq` is one of `"minute"`, `"hour"`, or `"day"` representing a frequency of every **minute**, **hour**, or **day** respectively.

**Example:**

```
Input
["TweetCounts","recordTweet","recordTweet","recordTweet","getTweetCountsPerFrequency","getTweetCountsPerFrequency","recordTweet","getTweetCountsPerFrequency"]
[[],["tweet3",0],["tweet3",60],["tweet3",10],["minute","tweet3",0,59],["minute","tweet3",0,60],["tweet3",120],["hour","tweet3",0,210]]

Output
[null,null,null,null,[2],[2,1],null,[4]]

Explanation
TweetCounts tweetCounts = new TweetCounts();
tweetCounts.recordTweet("tweet3", 0);                              // New tweet "tweet3" at time 0
tweetCounts.recordTweet("tweet3", 60);                             // New tweet "tweet3" at time 60
tweetCounts.recordTweet("tweet3", 10);                             // New tweet "tweet3" at time 10
tweetCounts.getTweetCountsPerFrequency("minute", "tweet3", 0, 59); // return [2]; chunk [0,59] had 2 tweets
tweetCounts.getTweetCountsPerFrequency("minute", "tweet3", 0, 60); // return [2,1]; chunk [0,59] had 2 tweets, chunk [60,60] had 1 tweet
tweetCounts.recordTweet("tweet3", 120);                            // New tweet "tweet3" at time 120
tweetCounts.getTweetCountsPerFrequency("hour", "tweet3", 0, 210);  // return [4]; chunk [0,210] had 4 tweets
```

**Constraints:**

*   `0 <= time, startTime, endTime <= 10<sup>9</sup>`
*   `0 <= endTime - startTime <= 10<sup>4</sup>`
*   There will be at most `10<sup>4</sup>` calls **in total** to `recordTweet` and `getTweetCountsPerFrequency`.


#### Solution

Language: **Python**

* [bisect left and bisect right](https://leetcode.com/problems/tweet-counts-per-frequency/discuss/503447/Python-binary-search)

```python
class TweetCounts(object):

    def __init__(self):
        self.tweets = collections.defaultdict(list)

    def recordTweet(self, tweetName, time):
        """
        :type tweetName: str
        :type time: int
        :rtype: None
        """
        self.tweets[tweetName].append(time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):
        """
        :type freq: str
        :type tweetName: str
        :type startTime: int
        :type endTime: int
        :rtype: List[int]
        """
        if freq == "minute": seconds = 60
        elif freq == "hour": seconds = 3600
        else: seconds = 86400

        ans = [0] * ((endTime - startTime)//seconds + 1)
        for t in self.tweets[tweetName]:
            if startTime <= t <= endTime: ans[(t-startTime)//seconds] += 1
        return ans

# using binary search
from collections import defaultdict
from bisect import bisect_left, bisect_right, insort
class TweetCounts(object):
    def __init__(self):
        self.tweets = defaultdict(list)

    def recordTweet(self, tweetName, time):
        insort(self.tweets[tweetName],time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):
        period = 60 if freq == 'minute' else 3600 if freq == 'hour'else 86400
        result = [0] * ((endTime-startTime)//period + 1)
        startIndex = bisect_left(self.tweets[tweetName], startTime)
        endIndex = bisect_right(self.tweets[tweetName], endTime)
        for i in range(startIndex, endIndex):
            timeblock = (self.tweets[tweetName][i] - startTime) //period
            result[timeblock] += 1
        return result
```

### [4\. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/)


Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

**Example 1:**

```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
```

**Example 2:**

```
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
```

**Constraints:**

*   `nums1.length == m`
*   `nums2.length == n`
*   `0 <= m <= 1000`
*   `0 <= n <= 1000`
*   `1 <= m + n <= 2000`
*   `-10<sup>6</sup> <= nums1[i], nums2[i] <= 10<sup>6</sup>`


#### Solution

Language: **Python3**

```python
class Solution:
    def findMedianSortedArrays(self, A: List[int], B: List[int]) -> float:
        total = len(A) + len(B)
        half = total // 2

        if len(A) > len(B):
            A, B = B, A

        l, r = 0, len(A) - 1
        while True:
            i = (l + r) // 2 # A
            j = half - i - 2 # B

            Aleft = A[i] if i >= 0 else float('inf')
            Aright = A[i + 1] if i + 1 <len(A) else float('inf')
            Bleft = B[j] if j >= 0 else float('inf')
            Bright = B[j + 1] if j + 1 < len(B) else float('inf')

            # partition is correct
            if Aleft <= Bright and Bleft <= Aright:
                # odd
                if total % 2:
                    return min(Aright, Bright)
                else:
                    return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
            elif Aleft > Bright:
                r = i - 1
            else:
                l = i + 1
```

### [875\. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/)


Koko loves to eat bananas. There are `n` piles of bananas, the `i<sup>th</sup>` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.

Koko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.

Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.

Return _the minimum integer_ `k` _such that she can eat all the bananas within_ `h` _hours_.

**Example 1:**

```
Input: piles = [3,6,7,11], h = 8
Output: 4
```

**Example 2:**

```
Input: piles = [30,11,23,4,20], h = 5
Output: 30
```

**Example 3:**

```
Input: piles = [30,11,23,4,20], h = 6
Output: 23
```

**Constraints:**

*   `1 <= piles.length <= 10<sup>4</sup>`
*   `piles.length <= h <= 10<sup>9</sup>`
*   `1 <= piles[i] <= 10<sup>9</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def minEatingSpeed(self, piles, h):
        """
        :type piles: List[int]
        :type h: int
        :rtype: int
        """
        l, r = 1, max(piles)
        k = 0
        
        while l <= r:
            m = (l + r) // 2
            
            totalTime = 0
            for p in piles:
                totalTime += ((p-1)//m) + 1
            if totalTime <= h:
                k = m
                r = m - 1
            else:
                l = m + 1
        return k
```

## Sort
### [215\. Kth Largest Element in an Array :fire:](https://leetcode.com/problems/kth-largest-element-in-an-array/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Quickselect](https://leetcode.com/tag/quickselect/)


Given an integer array `nums` and an integer `k`, return _the_ `k<sup>th</sup>` _largest element in the array_.

Note that it is the `k<sup>th</sup>` largest element in the sorted order, not the `k<sup>th</sup>` distinct element.

**Example 1:**

```
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
```

**Example 2:**

```
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
```

**Constraints:**

*   `1 <= k <= nums.length <= 10<sup>4</sup>`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
from heapq import heappush, heappop

def findKthLargest(nums, k):
    heap = []
    for i in range(len(nums)):
        heappush(heap, nums[i])
        if i > k - 1: # pop (k - 1)th times
            heappop(heap)
    return heap[0]

findKthLargest(nums = [3,2,1,5,6,4], k = 2)
findKthLargest(nums = [3,2,3,1,2,4,5,5,6], k = 4)  

class Solution:
    def findKthLargest(self, nums, k):
        if not nums: return
        pivot = random.choice(nums)
        left =  [x for x in nums if x > pivot]
        mid  =  [x for x in nums if x == pivot]
        right = [x for x in nums if x < pivot]

        L, M = len(left), len(mid)

        if k <= L:
            return self.findKthLargest(left, k)
        elif k > L + M:
            return self.findKthLargest(right, k - L - M)
        else:
            return mid[0]

class Solution:
    def findKthLargest(self, nums, k):
        k = len(nums) - k
        def quickSelect(l, r):
            if l == r: return nums[l]

            pivot, p = nums[r], l
            for i in range(l, r):
                if nums[i] <= pivot:
                    nums[p], nums[i] = nums[i], nums[p]
                    p += 1
            nums[p], nums[r] = nums[r], nums[p]

            if p > k:   return quickSelect(l, p - 1)
            elif p < k: return quickSelect(p + 1, r)
            else:       return nums[p]
        return quickSelect(0, len(nums) - 1)
```

### [791\. Custom Sort String](https://leetcode.com/problems/custom-sort-string/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Sorting](https://leetcode.com/tag/sorting/)


You are given two strings order and s. All the words of `order` are **unique** and were sorted in some custom order previously.

Permute the characters of `s` so that they match the order that `order` was sorted. More specifically, if a character `x` occurs before a character `y` in `order`, then `x` should occur before `y` in the permuted string.

Return _any permutation of_ `s` _that satisfies this property_.

**Example 1:**

```
Input: order = "cba", s = "abcd"
Output: "cbad"
Explanation:
"a", "b", "c" appear in order, so the order of "a", "b", "c" should be "c", "b", and "a".
Since "d" does not appear in order, it can be at any position in the returned string. "dcba", "cdba", "cbda" are also valid outputs.
```

**Example 2:**

```
Input: order = "cbafg", s = "abcd"
Output: "cbad"
```

**Constraints:**

*   `1 <= order.length <= 26`
*   `1 <= s.length <= 200`
*   `order` and `s` consist of lowercase English letters.
*   All the characters of `order` are **unique**.


#### Solution

Language: **Python**


```python
from collections import Counter

def customSortString(order, s):
    counter = Counter(s)
    result = ''
    for chr in order:
        result += chr * counter.get(chr, 0)
        counter[chr] = 0
    for chr in s:
        if counter[chr] != 0:
            result += chr
    return result

customSortString(order = "cba", s = "abcd")
customSortString(order = "cbafg", s = "abcd")    
```

### [57\. Insert Interval](https://leetcode.com/problems/insert-interval/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/)


You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [start<sub style="display: inline;">i</sub>, end<sub style="display: inline;">i</sub>]` represent the start and the end of the `i<sup>th</sup>` interval and `intervals` is sorted in ascending order by `start<sub style="display: inline;">i</sub>`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `start<sub style="display: inline;">i</sub>` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return `intervals` _after the insertion_.

**Example 1:**

```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Example 2:**

```
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

**Example 3:**

```
Input: intervals = [], newInterval = [5,7]
Output: [[5,7]]
```

**Example 4:**

```
Input: intervals = [[1,5]], newInterval = [2,3]
Output: [[1,5]]
```

**Example 5:**

```
Input: intervals = [[1,5]], newInterval = [2,7]
Output: [[1,7]]
```

**Constraints:**

*   `0 <= intervals.length <= 10<sup>4</sup>`
*   `intervals[i].length == 2`
*   `0 <= start<sub style="display: inline;">i</sub> <= end<sub style="display: inline;">i</sub> <= 10<sup>5</sup>`
*   `intervals` is sorted by `start<sub style="display: inline;">i</sub>` in **ascending** order.
*   `newInterval.length == 2`
*   `0 <= start <= end <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```Python
def insert(intervals, newInterval):
    res = []
    for i, interval in enumerate(intervals):
        if interval[1] < newInterval[0]:
            res.append(interval)
        elif newInterval[1] < interval[0]:
            res.append(newInterval)
            return res+intervals[i:]  # can return earlier
        else:  # overlap case
            newInterval[0] = min(newInterval[0], interval[0])
            newInterval[1] = max(newInterval[1], interval[1])
    res.append(newInterval)
    return res

intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]]
newInterval = [4,8]
insert(intervals, newInterval)
```

### [296\. Best Meeting Point](https://leetcode.com/problems/best-meeting-point/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Math](https://leetcode.com/tag/math/), [Sorting](https://leetcode.com/tag/sorting/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `m x n` binary grid `grid` where each `1` marks the home of one friend, return _the minimal **total travel distance**_.

The **total travel distance** is the sum of the distances between the houses of the friends and the meeting point.

The distance is calculated using , where `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/14/meetingpoint-grid.jpg)

```
Input: grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]
Output: 6
Explanation: Given three friends living at (0,0), (0,4), and (2,2).
The point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.
So return 6.
```

**Example 2:**

```
Input: grid = [[1,1]]
Output: 1
```

**Constraints:**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 200`
*   `grid[i][j]` is either `0` or `1`.
*   There will be **at least two** friends in the `grid`.


#### Solution

Language: **Python**

Time complexity : `O(mnlogmn)`.

Space complexity : `O(mn)`.
```python
def minTotalDistance(grid):
    n = len(grid)
    m = len(grid[0])
    v, h = [], []

    for i in range(n):
        for j in range(m):
            if grid[i][j] == 1:
                v.append(i)
                h.append(j)
    v.sort()
    h.sort()

    median_pos = len(v)/2
    x = v[median_pos]
    y = h[median_pos]

    distance = 0
    for i, j in zip(v, h):
        distance += abs(x - i) + abs(y - j)
    return distance

if __name__ == "__main__":
    grid = [[1, 0, 0, 0, 1],
            [0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0]]
    minTotalDistance(grid)
```


### [252\. Meeting Rooms](https://leetcode.com/problems/meeting-rooms/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Sorting](https://leetcode.com/tag/sorting/)


Given an array of meeting time `intervals` where `intervals[i] = [start<sub style="display: inline;">i</sub>, end<sub style="display: inline;">i</sub>]`, determine if a person could attend all meetings.

**Example 1:**

```
Input: intervals = [[0,30],[5,10],[15,20]]
Output: false
```

**Example 2:**

```
Input: intervals = [[7,10],[2,4]]
Output: true
```

**Constraints:**

*   `0 <= intervals.length <= 10<sup>4</sup>`
*   `intervals[i].length == 2`
*   `0 <= start<sub style="display: inline;">i</sub> < end<sub style="display: inline;">i</sub> <= 10<sup>6</sup>`


#### Solution

Language: **Python**

```python
def canAttendMeetings(nums):
    nums = sorted(nums, key =lambda x:x[0])
    for i in range(1, len(nums)):
        if nums[i - 1][1] > nums[i][0]:
            return False
    return True

canAttendMeetings([[0, 30],[5, 10],[15, 20]])
```

### [1366\. Rank Teams by Votes :fire:](https://leetcode.com/problems/rank-teams-by-votes/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Sorting](https://leetcode.com/tag/sorting/), [Counting](https://leetcode.com/tag/counting/)


In a special ranking system, each voter gives a rank from highest to lowest to all teams participated in the competition.

The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.

Given an array of strings `votes` which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.

Return _a string of all teams_ **sorted** by the ranking system.

**Example 1:**

```
Input: votes = ["ABC","ACB","ABC","ACB","ACB"]
Output: "ACB"
Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team.
Team B was ranked second by 2 voters and was ranked third by 3 voters.
Team C was ranked second by 3 voters and was ranked third by 2 voters.
As most of the voters ranked C second, team C is the second team and team B is the third.
```

**Example 2:**

```
Input: votes = ["WXYZ","XYZW"]
Output: "XWYZ"
Explanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn't have any votes as second position.
```

**Example 3:**

```
Input: votes = ["ZMNAGUEDSJYLBOPHRQICWFXTVK"]
Output: "ZMNAGUEDSJYLBOPHRQICWFXTVK"
Explanation: Only one voter so his votes are used for the ranking.
```

**Example 4:**

```
Input: votes = ["BCA","CAB","CBA","ABC","ACB","BAC"]
Output: "ABC"
Explanation:
Team A was ranked first by 2 voters, second by 2 voters and third by 2 voters.
Team B was ranked first by 2 voters, second by 2 voters and third by 2 voters.
Team C was ranked first by 2 voters, second by 2 voters and third by 2 voters.
There is a tie and we rank teams ascending by their IDs.
```

**Example 5:**

```
Input: votes = ["M","M","M","M"]
Output: "M"
Explanation: Only team M in the competition so it has the first rank.
```

**Constraints:**

*   `1 <= votes.length <= 1000`
*   `1 <= votes[i].length <= 26`
*   `votes[i].length == votes[j].length` for `0 <= i, j < votes.length`.
*   `votes[i][j]` is an English **upper-case** letter.
*   All characters of `votes[i]` are unique.
*   All the characters that occur in `votes[0]` **also occur** in `votes[j]` where `1 <= j < votes.length`.


#### Solution

Language: **Python**

```python
def rankTeams(votes):
    n = len(votes[0])
    score = [[0] * (n + 1) for _ in range(26)]
    for vote in votes:
        for j, v in enumerate(vote):
            i = ord(v) - ord("A")
            score[i][j] += 1
            score[i][n] = -ord(v)
    score.sort(reverse=True)
    return ''.join([chr(-row[n]) for row in score if row[-1] != 0])
votes = ["BCA","CAB","CBA","ABC","ACB","BAC"]
rankTeams(votes)
```

### [274\. H-Index :rainbow:](https://leetcode.com/problems/h-index/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Sorting](https://leetcode.com/tag/sorting/), [Counting Sort](https://leetcode.com/tag/counting-sort/)


Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `i<sup>th</sup>` paper, return compute the researcher's `h`**-index**.

According to the : A scientist has an index `h` if `h` of their `n` papers have at least `h` citations each, and the other `n  h` papers have no more than `h` citations each.

If there are several possible values for `h`, the maximum one is taken as the `h`**-index**.

**Example 1:**

```
Input: citations = [3,0,6,1,5]
Output: 3
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
```

**Example 2:**

```
Input: citations = [1,3,1]
Output: 1
```

**Constraints:**

*   `n == citations.length`
*   `1 <= n <= 5000`
*   `0 <= citations[i] <= 1000`


#### Solution

Language: **Python**

```Python
class Solution(object):
    def hIndex(self, citations):
        """
        :type citations: List[int]
        :rtype: int
        """
        n = len(citations);
        count = [0] * (n + 1)
        for x in citations:
            # Put all x >= n in the same bucket.
            if x >= n:
                count[n] += 1
            else:
                count[x] += 1

        s, h = count[-1], n
        while h > s:
            h -= 1
            s += count[h]    
        return h
```

### [646\. Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/)


You are given an array of `n` pairs `pairs` where `pairs[i] = [left<sub style="display: inline;">i</sub>, right<sub style="display: inline;">i</sub>]` and `left<sub style="display: inline;">i</sub> < right<sub style="display: inline;">i</sub>`.

A pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion.

Return _the length longest chain which can be formed_.

You do not need to use up all the given intervals. You can select pairs in any order.

**Example 1:**

```
Input: pairs = [[1,2],[2,3],[3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4].
```

**Example 2:**

```
Input: pairs = [[1,2],[7,8],[4,5]]
Output: 3
Explanation: The longest chain is [1,2] -> [4,5] -> [7,8].
```

**Constraints:**

*   `n == pairs.length`
*   `1 <= n <= 1000`
*   `-1000 <= left<sub style="display: inline;">i</sub> < right<sub style="display: inline;">i</sub> <= 1000`


#### Solution

Language: **Python**

```python
class Solution(object):
    def findLongestChain(self, pairs):
        """
        :type pairs: List[List[int]]
        :rtype: int
        """
        pairs.sort(key=lambda x: x[1])
        currTime, ans = float('-inf'), 0
        for x, y in pairs:
            if currTime < x:
                currTime = y
                ans += 1
        return ans

class Solution(object): #Time Limit Exceeded
    def findLongestChain(self, pairs):
        pairs.sort()
        dp = [1] * len(pairs)

        for j in xrange(len(pairs)):
            for i in xrange(j):
                if pairs[i][1] < pairs[j][0]:
                    dp[j] = max(dp[j], dp[i] + 1)

        return max(dp)
```

### [280\. Wiggle Sort](https://leetcode.com/problems/wiggle-sort/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/)


Given an integer array `nums`, reorder it such that `nums[0] <= nums[1] >= nums[2] <= nums[3]...`.

You may assume the input array always has a valid answer.

**Example 1:**

```
Input: nums = [3,5,2,1,6,4]
Output: [3,5,1,6,2,4]
Explanation: [1,6,2,5,3,4] is also accepted.
```

**Example 2:**

```
Input: nums = [6,6,5,6,3,8]
Output: [6,6,5,6,3,8]
```

**Constraints:**

*   `1 <= nums.length <= 5 * 10<sup>4</sup>`
*   `0 <= nums[i] <= 10<sup>4</sup>`
*   It is guaranteed that there will be an answer for the given input `nums`.

**Follow up:** Could you do it without sorting the array?

#### Solution

Language: **Python**

```python
class Solution(object):
    def wiggleSort(self, a):
        if not a:
            return
        n = len(a)
        for i in xrange(1, n, 2):
            if a[i] < a[i-1]:
                a[i], a[i-1] = a[i-1], a[i]

            if i + 1 < n and a[i] < a[i+1]:
                a[i], a[i+1] = a[i+1], a[i]
```

```
[1, 2, 3, 4, 5, 6]
          
    swap  swap

=> [1, 3, 2, 5, 4, 6]
```

```java
public void wiggleSort(int[] nums) {
    Arrays.sort(nums);
    for (int i = 1; i < nums.length - 1; i += 2) {
        swap(nums, i, i + 1);
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

### [324\. Wiggle Sort II](https://leetcode.com/problems/wiggle-sort-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Sorting](https://leetcode.com/tag/sorting/), [Quickselect](https://leetcode.com/tag/quickselect/)


Given an integer array `nums`, reorder it such that `nums[0] < nums[1] > nums[2] < nums[3]...`.

You may assume the input array always has a valid answer.

**Example 1:**

```
Input: nums = [1,5,1,1,6,4]
Output: [1,6,1,5,1,4]
Explanation: [1,4,1,5,1,6] is also accepted.
```

**Example 2:**

```
Input: nums = [1,3,2,2,3,1]
Output: [2,3,1,3,1,2]
```

**Constraints:**

*   `1 <= nums.length <= 5 * 10<sup>4</sup>`
*   `0 <= nums[i] <= 5000`
*   It is guaranteed that there will be an answer for the given input `nums`.

**Follow Up:** Can you do it in `O(n)` time and/or **in-place** with `O(1)` extra space?

#### Solution

Language: **Python**

Roughly speaking I put the smaller half of the numbers on the even indexes and the larger half on the odd indexes.
```python
def wiggleSort(self, nums):
    nums.sort()
    half = len(nums[::2]) - 1
    nums[::2], nums[1::2] = nums[half::-1], nums[:half:-1]
```
I put the smaller half of the numbers on the even indexes and the larger half on the odd indexes, both from right to left:

```
Example nums = [1,2,...,7]      Example nums = [1,2,...,8]

Small half:  4 . 3 . 2 . 1      Small half:  4 . 3 . 2 . 1 .
Large half:  . 7 . 6 . 5 .      Large half:  . 8 . 7 . 6 . 5
--------------------------      --------------------------
Together:    4 7 3 6 2 5 1      Together:    4 8 3 7 2 6 1 5
```

### [1710\. Maximum Units on a Truck](https://leetcode.com/problems/maximum-units-on-a-truck/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/)


You are assigned to put some amount of boxes onto **one truck**. You are given a 2D array `boxTypes`, where `boxTypes[i] = [numberOfBoxes<sub style="display: inline;">i</sub>, numberOfUnitsPerBox<sub style="display: inline;">i</sub>]`:

*   `numberOfBoxes<sub style="display: inline;">i</sub>` is the number of boxes of type `i`.
*   `numberOfUnitsPerBox<sub style="display: inline;">i</sub>`is the number of units in each box of the type `i`.

You are also given an integer `truckSize`, which is the **maximum** number of **boxes** that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed `truckSize`.

Return _the **maximum** total number of **units** that can be put on the truck._

**Example 1:**

```
Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
Output: 8
Explanation: There are:
- 1 box of the first type that contains 3 units.
- 2 boxes of the second type that contain 2 units each.
- 3 boxes of the third type that contain 1 unit each.
You can take all the boxes of the first and second types, and one box of the third type.
The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.
```

**Example 2:**

```
Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
Output: 91
```

**Constraints:**

*   `1 <= boxTypes.length <= 1000`
*   `1 <= numberOfBoxes<sub style="display: inline;">i</sub>, numberOfUnitsPerBox<sub style="display: inline;">i</sub> <= 1000`
*   `1 <= truckSize <= 10<sup>6</sup>`


#### Solution

Language: **Python**

```python
class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        result = 0
        boxTypes.sort(key = lambda x: x[1], reverse = True)
        for boxType in boxTypes:
            numberOfBoxes,  numberOfUnitsPerBox = boxType[0], boxType[1]
            numberOfBoxes = min(numberOfBoxes, truckSize)
            truckSize -= numberOfBoxes
            result += numberOfBoxes * numberOfUnitsPerBox
            if truckSize <= 0:
                break
        return result
```

### [1498\. Number of Subsequences That Satisfy the Given Sum Condition](https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Binary Search](https://leetcode.com/tag/binary-search/), [Sorting](https://leetcode.com/tag/sorting/)


You are given an array of integers `nums` and an integer `target`.

Return _the number of **non-empty** subsequences of_ `nums` _such that the sum of the minimum and maximum element on it is less or equal to_ `target`. Since the answer may be too large, return it **modulo** `10<sup>9</sup> + 7`.

**Example 1:**

```
Input: nums = [3,5,6,7], target = 9
Output: 4
Explanation: There are 4 subsequences that satisfy the condition.
[3] -> Min value + max value <= target (3 + 3 <= 9)
[3,5] -> (3 + 5 <= 9)
[3,5,6] -> (3 + 6 <= 9)
[3,6] -> (3 + 6 <= 9)
```

**Example 2:**

```
Input: nums = [3,3,6,8], target = 10
Output: 6
Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
```

**Example 3:**

```
Input: nums = [2,3,3,4,6,7], target = 12
Output: 61
Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).
Number of valid subsequences (63 - 2 = 61).
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `1 <= nums[i] <= 10<sup>6</sup>`
*   `1 <= target <= 10<sup>6</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def numSubseq(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        nums.sort()
        right = len(nums) - 1
        result = 0
        mod = 10**9+7
        for i in range(len(nums)):
            while(i<=right and nums[i] + nums[right] > target):
                right -= 1
            if i <= right:
                result += (2**(right - i))
                result %= mod
        return result
```

## Breadth-first Search
### [199\. Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return _the values of the nodes you can see ordered from top to bottom_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

```
Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
```

**Example 2:**

```
Input: root = [1,null,3]
Output: [1,3]
```

**Example 3:**

```
Input: root = []
Output: []
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 100]`.
*   `-100 <= Node.val <= 100`


#### Solution

Language: **Python**

```python
# bfs
def rightSideView(root):
    curr = [root]
    result = []
    while curr:
        next_level = []
        for node in curr:
            if node.left:
                next_level.append(node.left)
            if node.right:
                next_level.append(node.right)
        result.append(curr.pop().val)
        curr = next_level
    return result        

# dfs
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if root is None:
            return []

        rightside = []

        def helper(node: TreeNode, level: int) -> None:
            if level == len(rightside):
                rightside.append(node.val)
            for child in [node.right, node.left]:
                if child:
                    helper(child, level + 1)

        helper(root, 0)
        return rightside
```     

### [314\. Binary Tree Vertical Order Traversal](https://leetcode.com/problems/binary-tree-vertical-order-traversal/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, return _**the vertical order traversal** of its nodes' values_. (i.e., from top to bottom, column by column).

If two nodes are in the same row and column, the order should be from **left to right**.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/28/vtree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[9],[3,15],[20],[7]]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/28/vtree2-1.jpg)

```
Input: root = [3,9,8,4,0,1,7]
Output: [[4],[9],[3,0,1],[8],[7]]
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/01/28/vtree2.jpg)

```
Input: root = [3,9,8,4,0,1,7,null,null,null,2,5]
Output: [[4],[9,5],[3,0,1],[8,2],[7]]
```

**Example 4:**

```
Input: root = []
Output: []
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 100]`.
*   `-100 <= Node.val <= 100`


#### Solution

Language: **Python**

```python
from collections import defaultdict

def verticalOrder(root):
    if not root:
        return []
    hashmap = defaultdict(list)
    cur = [(root, 0)]
    while cur:
        next_level = []
        for node, col in cur:
            hashmap[col].append(node.val)
            if node.left:
                next_level.append((node.left, col - 1))
            if node.right:
                next_level.append((node.right, col + 1))
        cur = next_level
    return [hashmap[col] for col in sorted(hashmap.keys())]
```

### [987\. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)

Difficulty: **Hard**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, calculate the **vertical order traversal** of the binary tree.

For each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.

The **vertical order traversal** of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.

Return _the **vertical order traversal** of the binary tree_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[9],[3,15],[20],[7]]
Explanation:
Column -1: Only node 9 is in this column.
Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.
Column 1: Only node 20 is in this column.
Column 2: Only node 7 is in this column.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg)

```
Input: root = [1,2,3,4,5,6,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
Column -2: Only node 4 is in this column.
Column -1: Only node 2 is in this column.
Column 0: Nodes 1, 5, and 6 are in this column.
          1 is at the top, so it comes first.
          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.
Column 1: Only node 3 is in this column.
Column 2: Only node 7 is in this column.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg)

```
Input: root = [1,2,3,4,6,5,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
This case is the exact same as example 2, but with nodes 5 and 6 swapped.
Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 1000]`.
*   `0 <= Node.val <= 1000`


#### Solution

Language: **Python**

```Python
class Solution(object):
    def verticalTraversal(self, root):
        g = collections.defaultdict(list)
        queue = [(root,0)]
        while queue:
            new = []
            d = collections.defaultdict(list)
            for node, s in queue:
                d[s].append(node.val)
                if node.left:  new += (node.left, s-1),
                if node.right: new += (node.right,s+1),  
            for i in d: g[i].extend(sorted(d[i]))
            queue = new
        return [g[i] for i in sorted(g)]
```

### [317\. Shortest Distance from All Buildings :fire:](https://leetcode.com/problems/shortest-distance-from-all-buildings/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Matrix](https://leetcode.com/tag/matrix/)


You are given an `m x n` grid `grid` of values `0`, `1`, or `2`, where:

*   each `0` marks **an empty land** that you can pass by freely,
*   each `1` marks **a building** that you cannot pass through, and
*   each `2` marks **an obstacle** that you cannot pass through.

You want to build a house on an empty land that reaches all buildings in the **shortest total travel** distance. You can only move up, down, left, and right.

Return _the **shortest travel distance** for such a house_. If it is not possible to build such a house according to the above rules, return `-1`.

The **total travel distance** is the sum of the distances between the houses of the friends and the meeting point.

The distance is calculated using , where `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/14/buildings-grid.jpg)

```
Input: grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]
Output: 7
Explanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).
The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.
So return 7.
```

**Example 2:**

```
Input: grid = [[1,0]]
Output: 1
```

**Example 3:**

```
Input: grid = [[1]]
Output: -1
```

**Constraints:**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 50`
*   `grid[i][j]` is either `0`, `1`, or `2`.
*   There will be **at least one** building in the `grid`.


#### Solution

Language: **Python**

```Python
class Solution:
    def shortestDistance(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """       
        h = len(grid)
        w = len(grid[0])

        distance = [[0 for _ in range(w)] for _ in range(h)]
        can_reach = [[0 for _ in range(w)] for _ in range(h)]

        buildingNum = 0

        for i in range(h):
            for j in range(w):
                if grid[i][j] == 1:
                    buildingNum += 1
                    q = [(i, j, 0)]

                    isVisited = [[False for _ in range(w)] for _ in range(h)]

                    for y, x, d in q:
                        for dy, dx in (-1, 0), (1, 0), (0, -1), (0, 1):
                            r = y + dy
                            c = x + dx

                            if 0 <= r < h and 0 <= c < w and grid[r][c] == 0 and not isVisited[r][c]:
                                distance[r][c] += d + 1
                                can_reach[r][c] += 1

                                isVisited[r][c] = True
                                q.append((r, c, d + 1))

        shortest = float("inf")
        for i in range(h):
            for j in range(w):
                if grid[i][j] == 0 and can_reach[i][j] == buildingNum:
                    shortest = min(shortest, distance[i][j])

        if shortest < float("inf"):
            return shortest
        else:
            return -1
```

### [286\. Walls and Gates](https://leetcode.com/problems/walls-and-gates/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Matrix](https://leetcode.com/tag/matrix/)


You are given an `m x n` grid `rooms` initialized with these three possible values.

*   `-1` A wall or an obstacle.
*   `0` A gate.
*   `INF` Infinity means an empty room. We use the value `2<sup>31</sup> - 1 = 2147483647` to represent `INF` as you may assume that the distance to a gate is less than `2147483647`.

Fill each empty room with the distance to _its nearest gate_. If it is impossible to reach a gate, it should be filled with `INF`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/03/grid.jpg)

```
Input: rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]
Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]
```

**Example 2:**

```
Input: rooms = [[-1]]
Output: [[-1]]
```

**Example 3:**

```
Input: rooms = [[2147483647]]
Output: [[2147483647]]
```

**Example 4:**

```
Input: rooms = [[0]]
Output: [[0]]
```

**Constraints:**

*   `m == rooms.length`
*   `n == rooms[i].length`
*   `1 <= m, n <= 250`
*   `rooms[i][j]` is `-1`, `0`, or `2<sup>31</sup> - 1`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def wallsAndGates(self, rooms):
        if not rooms:
            return []
        # Initialize the queue with all 0s
        R, C = len(rooms), len(rooms[0])
        q = collections.deque()
        for r in range(R):
            for c in range(C):
                if rooms[r][c] == 0:
                    q.append((r, c))

        while q:
            r, c = q.popleft()
            for x, y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                if 0 <= r+x < R and 0 <= c+y < C and rooms[r+x][c+y] > rooms[r][c]:
                    rooms[r+x][c+y] = rooms[r][c] + 1
                    q.append((r+x, c+y))
        return rooms
```

### [339\. Nested List Weight Sum](https://leetcode.com/problems/nested-list-weight-sum/)

Difficulty: **Medium**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/)


You are given a nested list of integers `nestedList`. Each element is either an integer or a list whose elements may also be integers or other lists.

The **depth** of an integer is the number of lists that it is inside of. For example, the nested list `[1,[2,2],[[3],2],1]` has each integer's value set to its **depth**.

Return _the sum of each integer in_ `nestedList` _multiplied by its **depth**_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/14/nestedlistweightsumex1.png)

```
Input: nestedList = [[1,1],2,[1,1]]
Output: 10
Explanation: Four 1's at depth 2, one 2 at depth 1\. 1*2 + 1*2 + 2*1 + 1*2 + 1*2 = 10.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/14/nestedlistweightsumex2.png)

```
Input: nestedList = [1,[4,[6]]]
Output: 27
Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3\. 1*1 + 4*2 + 6*3 = 27.
```

**Example 3:**

```
Input: nestedList = [0]
Output: 0
```

**Constraints:**

*   `1 <= nestedList.length <= 50`
*   The values of the integers in the nested list is in the range `[-100, 100]`.
*   The maximum **depth** of any integer is less than or equal to `50`.


#### Solution

Language: **Python**

```python
# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger(object):
#    def __init__(self, value=None):
#        """
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        """
#
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def add(self, elem):
#        """
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        """
#
#    def setInteger(self, value):
#        """
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """

class Solution(object):
    def depthSum(self, nestedList):
        """
        :type nestedList: List[NestedInteger]
        :rtype: int
        """
        depth, result = 1, 0
        while nestedList:
            result += depth * sum([x.getInteger() for x in nestedList if x.isInteger() ])
            nestedList = sum([x.getList() for x in nestedList if not x.isInteger()], [])
            depth += 1
        return result
```

### [1197\. Minimum Knight Moves](https://leetcode.com/problems/minimum-knight-moves/)

Difficulty: **Medium**  

Related Topics: [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/)


In an **infinite** chess board with coordinates from `-infinity` to `+infinity`, you have a **knight** at square `[0, 0]`.

A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.

![](https://assets.leetcode.com/uploads/2018/10/12/knight.png)

Return _the minimum number of steps needed to move the knight to the square_ `[x, y]`. It is guaranteed the answer exists.

**Example 1:**

```
Input: x = 2, y = 1
Output: 1
Explanation: [0, 0]  [2, 1]
```

**Example 2:**

```
Input: x = 5, y = 5
Output: 4
Explanation: [0, 0]  [2, 1]  [4, 2]  [3, 4]  [5, 5]
```

**Constraints:**

*   `-300 <= x, y <= 300`
*   `0 <= |x| + |y| <= 300`


#### Solution

Language: **Python**

```python
class Solution:
    def minKnightMoves(self, x: int, y: int) -> int:
        # the offsets in the eight directions
        offsets = [(1, 2), (2, 1), (2, -1), (1, -2),
                   (-1, -2), (-2, -1), (-2, 1), (-1, 2)]

        def bfs(x, y):
            visited = set()
            queue = deque([(0, 0)])
            steps = 0

            while queue:
                curr_level_cnt = len(queue)
                # iterate through the current level
                for i in range(curr_level_cnt):
                    curr_x, curr_y = queue.popleft()
                    if (curr_x, curr_y) == (x, y):
                        return steps

                    for offset_x, offset_y in offsets:
                        next_x, next_y = curr_x + offset_x, curr_y + offset_y
                        if (next_x, next_y) not in visited:
                            visited.add((next_x, next_y))
                            queue.append((next_x, next_y))

                # move on to the next level
                steps += 1

        return bfs(x, y)
```

### [126\. Word Ladder II :fire:](https://leetcode.com/problems/word-ladder-ii/)

Difficulty: **Hard**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Backtracking](https://leetcode.com/tag/backtracking/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/)


A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s<sub style="display: inline;">1</sub> -> s<sub style="display: inline;">2</sub> -> ... -> s<sub style="display: inline;">k</sub>` such that:

*   Every adjacent pair of words differs by a single letter.
*   Every `s<sub style="display: inline;">i</sub>` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
*   `s<sub style="display: inline;">k</sub> == endWord`

Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return _all the **shortest transformation sequences** from_ `beginWord` _to_ `endWord`_, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words_ `[beginWord, s<sub style="display: inline;">1</sub>, s<sub style="display: inline;">2</sub>, ..., s<sub style="display: inline;">k</sub>]`.

**Example 1:**

```
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
Explanation: There are 2 shortest transformation sequences:
"hit" -> "hot" -> "dot" -> "dog" -> "cog"
"hit" -> "hot" -> "lot" -> "log" -> "cog"
```

**Example 2:**

```
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
Output: []
Explanation: The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.
```

**Constraints:**

*   `1 <= beginWord.length <= 5`
*   `endWord.length == beginWord.length`
*   `1 <= wordList.length <= 1000`
*   `wordList[i].length == beginWord.length`
*   `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.
*   `beginWord != endWord`
*   All the words in `wordList` are **unique**.


#### Solution

Language: **Python**

* Time: `O(N * 26 * W^2 + A)`, where `N <= 1000` is number of words in `wordList`, `W <= 5` is length of each words, `A` is total number of sequences.
    * BFS costs `O(E + V)`, where `E` is number of edges, `V` is number of vertices.
    * Because words need to be existed in the `wordList`, so there is total `N` words, it's also the number of vertices.
    * To find neighbors for a word, it costs `O(26 * W * W)`, in the worst case, we have to find the neighbors of `N` words, so there is total `O(N * 26 * W^2)` edges.
* Space: `O(N*W + A)`


```python
from collections import defaultdict
from string import ascii_lowercase

def findLadders(beginWord, endWord, wordList):
    wordSet = set(wordList)  # to check if a word is existed in the wordSet, in O(1)
    wordSet.discard(beginWord)

    def neighbors(word):
        for i in range(len(word)):  # change every possible single letters and check if it's in wordSet
            for c in ascii_lowercase:
                newWord = word[:i] + c + word[i + 1:]
                if newWord in wordSet:
                    yield newWord

    level = {}
    level[beginWord] = [[beginWord]]  # level[word] is all possible sequence paths which start from beginWord and end at `word`.
    while level:
        nextLevel = defaultdict(list)
        for word, paths in level.items():
            if word == endWord:
                return paths  # return all shortest sequence paths
            for nei in neighbors(word):
                for path in paths:
                    nextLevel[nei].append(path + [nei])  # form new paths with `nei` word at the end
        wordSet -= set(nextLevel.keys())  # remove visited words to prevent loops
        level = nextLevel  # move to new level

    return []

findLadders(beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"])
```

### [127\. Word Ladder](https://leetcode.com/problems/word-ladder/)

Difficulty: **Hard**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/)


A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s<sub style="display: inline;">1</sub> -> s<sub style="display: inline;">2</sub> -> ... -> s<sub style="display: inline;">k</sub>` such that:

*   Every adjacent pair of words differs by a single letter.
*   Every `s<sub style="display: inline;">i</sub>` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
*   `s<sub style="display: inline;">k</sub> == endWord`

Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return _the **number of words** in the **shortest transformation sequence** from_ `beginWord` _to_ `endWord`_, or_ `0` _if no such sequence exists._

**Example 1:**

```
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5
Explanation: One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.
```

**Example 2:**

```
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
Output: 0
Explanation: The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.
```

**Constraints:**

*   `1 <= beginWord.length <= 10`
*   `endWord.length == beginWord.length`
*   `1 <= wordList.length <= 5000`
*   `wordList[i].length == beginWord.length`
*   `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.
*   `beginWord != endWord`
*   All the words in `wordList` are **unique**.


#### Solution

Language: **Python**

```python
def ladderLength(beginWord, endWord, wordList):
    step = 0
    curr = [beginWord]
    visited = [beginWord]
    while curr:
        next_level = []
        for word in curr:
            if word == endWord:
                return step + 1
            for i in range(len(word)):
                for letter in [chr(j) for j in range(ord('a'), ord('z')+1)]:
                    word_candidate = word[: i] + letter + word[i + 1: ]
                    if word_candidate in wordList and word_candidate not in visited:
                        visited.append(word_candidate)
                        next_level.append(word_candidate)
        step += 1
        curr = next_level
    return -1                    

beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]
ladderLength(beginWord, endWord, wordList)
```

* Breadth first search in the worst case might go to each of the NN words. For each word, we need to examine M possible intermediate words/combinations. Notice, we have used the substring operation to find each of the combination. Thus, M combinations take O({M} ^ 2) time.
* Each word in the word list would have MM intermediate combinations. To create the all_combo_dict dictionary we save an intermediate word as the key and its corresponding original words as the value. Note, for each of M intermediate words we save the original word of length M. This simply means, for every word we would need a space of {M}^2.
```python
class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        wordList = set(wordList) #avoid TLE
        q = collections.deque([(beginWord, 1)])
        visited = set()
        letterList = 'abcdefghijklnopqrstuvwxyz'  #'abcd...zbeginWord'
        while q:
            word, length = q.popleft()
            if word == endWord:
                return length
            for i in range(len(word)):
                for ch in letterList:
                    new_word = word[:i] + ch + word[i+1:]
                    if new_word in wordList and new_word not in visited:
                        q.append((new_word, length + 1))
                        visited.add(new_word)
        return 0
```

### [102\. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, return _the level order traversal of its nodes' values_. (i.e., from left to right, level by level).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Example 3:**

```
Input: root = []
Output: []
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 2000]`.
*   `-1000 <= Node.val <= 1000`


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        result = []
        curr = [root]
        while curr:
            next_level = []
            curr_level = []
            for node in curr:
                curr_level.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            result.append(curr_level)
            curr = next_level
        return result
```

### [815\. Bus Routes :fire:](https://leetcode.com/problems/bus-routes/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/)


You are given an array `routes` representing bus routes where `routes[i]` is a bus route that the `i<sup>th</sup>` bus repeats forever.

*   For example, if `routes[0] = [1, 5, 7]`, this means that the `0<sup>th</sup>` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.

You will start at the bus stop `source` (You are not on any bus initially), and you want to go to the bus stop `target`. You can travel between bus stops by buses only.

Return _the least number of buses you must take to travel from_ `source` _to_ `target`. Return `-1` if it is not possible.

**Example 1:**

```
Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6
Output: 2
Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.
```

**Example 2:**

```
Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
Output: -1
```

**Constraints:**

*   `1 <= routes.length <= 500`.
*   `1 <= routes[i].length <= 10<sup>5</sup>`
*   All the values of `routes[i]` are **unique**.
*   `sum(routes[i].length) <= 10<sup>5</sup>`
*   `0 <= routes[i][j] < 10<sup>6</sup>`
*   `0 <= source, target < 10<sup>6</sup>`


#### Solution

Language: **Python**

```python
# T: N * N * b_bar (Let NN denote the number of buses, and b_ib  i be the number of stops on the iith bus.)
# S:
def numBusesToDestination(routes, source, target):
    stop2bus = collections.defaultdict(set) #keyvalue
    for i,route in enumerate(routes):#i
        for j in route: #j
            stop2bus[j].add(i)

    queue = [(source,0)] #BFS,0source0
    visited_stop = set([source]) #setiterable
    for cur_stop,bus_num in queue: #queue
        if cur_stop == target:
            return bus_num
        for bus in stop2bus[cur_stop]:#cur_stop
            for stop in routes[bus]:#
                if stop not in visited_stop:#
                    queue.append((stop,bus_num+1)) #queue
                    visited_stop.add(stop)#stop
            #routes[bus] = [] #routes[bus]
    return -1

routes = [[1,2,7],[3,6,7]]; source = 1; target = 6
numBusesToDestination(routes, source, target)
```

### [1376\. Time Needed to Inform All Employees :rainbow:](https://leetcode.com/problems/time-needed-to-inform-all-employees/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/)


A company has `n` employees with a unique ID for each employee from `0` to `n - 1`. The head of the company is the one with `headID`.

Each employee has one direct manager given in the `manager` array where `manager[i]` is the direct manager of the `i-th` employee, `manager[headID] = -1`. Also, it is guaranteed that the subordination relationships have a tree structure.

The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.

The `i-th` employee needs `informTime[i]` minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).

Return _the number of minutes_ needed to inform all the employees about the urgent news.

**Example 1:**

```
Input: n = 1, headID = 0, manager = [-1], informTime = [0]
Output: 0
Explanation: The head of the company is the only employee in the company.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/02/27/graph.png)

```
Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]
Output: 1
Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.
The tree structure of the employees in the company is shown.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2020/02/28/1730_example_3_5.PNG)

```
Input: n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1]
Output: 21
Explanation: The head has id = 6\. He will inform employee with id = 5 in 1 minute.
The employee with id = 5 will inform the employee with id = 4 in 2 minutes.
The employee with id = 4 will inform the employee with id = 3 in 3 minutes.
The employee with id = 3 will inform the employee with id = 2 in 4 minutes.
The employee with id = 2 will inform the employee with id = 1 in 5 minutes.
The employee with id = 1 will inform the employee with id = 0 in 6 minutes.
Needed time = 1 + 2 + 3 + 4 + 5 + 6 = 21.
```

**Example 4:**

```
Input: n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]
Output: 3
Explanation: The first minute the head will inform employees 1 and 2.
The second minute they will inform employees 3, 4, 5 and 6.
The third minute they will inform the rest of employees.
```

**Example 5:**

```
Input: n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914]
Output: 1076
```

**Constraints:**

*   `1 <= n <= 10<sup>5</sup>`
*   `0 <= headID < n`
*   `manager.length == n`
*   `0 <= manager[i] < n`
*   `manager[headID] == -1`
*   `informTime.length == n`
*   `0 <= informTime[i] <= 1000`
*   `informTime[i] == 0` if employee `i` has no subordinates.
*   It is **guaranteed** that all the employees can be informed.


#### Solution

Language: **Python**

* Solution 1: Top down DFS
* `dfs` find out the time needed for each employees.
* The time for a manager = `max(manager's employees) + informTime[manager]`
* Time `O(N)`, Space `O(N)`

```python
from collections import defaultdict, deque

def numOfMinutes(n, headID, manager, informTime):
    rst = 0
    childs = defaultdict(list)
    for idx, parent in enumerate(manager):
        childs[parent].append(idx)

    q = deque([(headID, informTime[headID])])
    while q:
        cur_id, cur_time = q.popleft()
        # calculate max
        rst = max(rst, cur_time)
        for child in childs[cur_id]:
            q.append((child, cur_time + informTime[child]))
    return rst

n = 6; headID = 2; manager = [2,2,-1,2,2,2]; informTime = [0,0,1,0,0,0]
```

### [1293\. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Matrix](https://leetcode.com/tag/matrix/)


You are given an `m x n` integer matrix `grid` where each cell is either `0` (empty) or `1` (obstacle). You can move up, down, left, or right from and to an empty cell in **one step**.

Return _the minimum number of **steps** to walk from the upper left corner_ `(0, 0)` _to the lower right corner_ `(m - 1, n - 1)` _given that you can eliminate **at most**_ `k` _obstacles_. If it is not possible to find such walk return `-1`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg)

```
Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
Output: 6
Explanation:
The shortest path without eliminating any obstacle is 10.
The shortest path with one obstacle elimination at position (3,2) is 6\. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg)

```
Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1
Output: -1
Explanation: We need to eliminate at least two obstacles to find such a walk.
```

**Constraints:**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 40`
*   `1 <= k <= m * n`
*   `grid[i][j]` is either `0` **or** `1`.
*   `grid[0][0] == grid[m - 1][n - 1] == 0`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/solution/)
```Python
class Solution:
    def shortestPath(self, grid: List[List[int]], k: int) -> int:
        rows, cols = len(grid), len(grid[0])
        target = (rows - 1, cols - 1)

        # if we have sufficient quotas to eliminate the obstacles in the worst case,
        # then the shortest distance is the Manhattan distance
        if k >= rows + cols - 2:
            return rows + cols - 2

        # (row, col, remaining quota to eliminate obstacles)
        state = (0, 0, k)
        # (steps, state)
        queue = deque([(0, state)])
        seen = set([state])

        while queue:
            steps, (row, col, k) = queue.popleft()

            # we reach the target here
            if (row, col) == target:
                return steps

            # explore the four directions in the next step
            for new_row, new_col in [(row, col + 1), (row + 1, col), (row, col - 1), (row - 1, col)]:
                # if (new_row, new_col) is within the grid boundaries
                if (0 <= new_row < rows) and (0 <= new_col < cols):
                    new_eliminations = k - grid[new_row][new_col]
                    new_state = (new_row, new_col, new_eliminations)
                    # add the next move in the queue if it qualifies
                    if new_eliminations >= 0 and new_state not in seen:
                        seen.add(new_state)
                        queue.append((steps + 1, new_state))

        # did not reach the target
        return -1
```

### [864\. Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/)

Difficulty: **Hard**  

Related Topics: [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/)


You are given an `m x n` grid `grid` where:

*   `'.'` is an empty cell.
*   `'#'` is a wall.
*   `'@'` is the starting point.
*   Lowercase letters represent keys.
*   Uppercase letters represent locks.

You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.

If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.

For some `<font face="monospace" style="display: inline;">1 <= k <= 6</font>`, there is exactly one lowercase and one uppercase letter of the first `k` letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.

Return _the lowest number of moves to acquire all keys_. If it is impossible, return `-1`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg)

```
Input: grid = ["@.a.#","###.#","b.A.B"]
Output: 8
Explanation: Note that the goal is to obtain all the keys not to open all the locks.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg)

```
Input: grid = ["@..aA","..B#.","....b"]
Output: 6
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg)

```
Input: grid = ["@Aa"]
Output: -1
```

**Constraints:**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 30`
*   `grid[i][j]` is either an English letter, `'.'`, `'#'`, or `'@'`.
*   The number of keys in the grid is in the range `[1, 6]`.
*   Each key in the grid is **unique**.
*   Each key in the grid has a matching lock.


#### Solution

Language: **Python**

* [](https://buptwc.github.io/2018/07/09/leetcode-865-Shortest-Path-to-Get-All-keys/)

1. @keynumOfKey
2. `(i,j,step,key,collectedkey)`:
    1. i,j,`step`bfs
    2. `key``'abcdef.@'`key
    3. `collectedkey`key`collectedkey = numOfKey`
3. visitedvisited(i,j,key)key

* T: O(m * n * 2 ** keys = m * n * 64)
* S: O(m * n * 2 ** keys)
```python
class Solution(object):
    def shortestPathAllKeys(self, grid):
        """
        :type grid: List[str]
        :rtype: int
        """
        n, m = len(grid), len(grid[0])
        numOfKeys = 0
        direc = [[0,1],[0,-1],[1,0],[-1,0]]
        visited = set()

        for i in range(n):
            for j in range(m):
                if grid[i][j] == '@':
                    starti = i
                    startj = j
                elif grid[i][j] in "abcdef":
                    numOfKeys += 1

        deque = collections.deque()
        deque.append([starti, startj, 0, ".@abcdef", 0])

        while deque:
            i, j, steps, keys, collectedKeys = deque.popleft()

            if grid[i][j] in "abcdef" and grid[i][j].upper() not in keys:
                keys += grid[i][j].upper()
                collectedKeys += 1

            if collectedKeys == numOfKeys:
                return steps

            for x, y in direc:
                ni = i+x
                nj = j+y
                if 0<=ni<n and 0<=nj<m and grid[ni][nj] in keys:
                    if (ni, nj, keys) not in visited:
                        visited.add((ni,nj,keys))
                        deque.append([ni, nj, steps + 1, keys, collectedKeys])

        return -1
```

### [515\. Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, return _an array of the largest value in each row_ of the tree **(0-indexed)**.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg)

```
Input: root = [1,3,2,5,3,null,9]
Output: [1,3,9]
```

**Example 2:**

```
Input: root = [1,2,3]
Output: [1,3]
```

**Example 3:**

```
Input: root = [1]
Output: [1]
```

**Example 4:**

```
Input: root = [1,null,2]
Output: [1,2]
```

**Example 5:**

```
Input: root = []
Output: []
```

**Constraints:**

*   The number of nodes in the tree will be in the range `[0, 10<sup>4</sup>]`.
*   `-2<sup>31</sup> <= Node.val <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

```Python
class Solution(object):
    def largestValues(self, root):
        ans = []
        if root is None:
            return ans
        queue  = [root]
        while queue:
            ans.append(max(x.val for x in queue))
            new_queue = []
            for node in queue:
                if node.left:
                    new_queue.append(node.left)
                if node.right:
                    new_queue.append(node.right)
            queue = new_queue
        return ans
```

### [1091\. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `n x n` binary matrix `grid`, return _the length of the shortest **clear path** in the matrix_. If there is no clear path, return `-1`.

A **clear path** in a binary matrix is a path from the **top-left** cell (i.e., `(0, 0)`) to the **bottom-right** cell (i.e., `(n - 1, n - 1)`) such that:

*   All the visited cells of the path are `0`.
*   All the adjacent cells of the path are **8-directionally** connected (i.e., they are different and they share an edge or a corner).

The **length of a clear path** is the number of visited cells of this path.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/18/example1_1.png)

```
Input: grid = [[0,1],[1,0]]
Output: 2
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/18/example2_1.png)

```
Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
Output: 4
```

**Example 3:**

```
Input: grid = [[1,0,0],[1,1,0],[1,1,0]]
Output: -1
```

**Constraints:**

*   `n == grid.length`
*   `n == grid[i].length`
*   `1 <= n <= 100`
*   `grid[i][j] is 0 or 1`


#### Solution

Language: **Python**

```Python
def shortestPathBinaryMatrix(grid):
	n = len(grid)
	if grid[0][0] or grid[n-1][n-1]:
		return -1
	q = [(0, 0, 1)]
	grid[0][0] = 1
	for i, j, d in q:
		if i == n-1 and j == n-1: return d
		for x, y in ((i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)):
			if 0 <= x < n and 0 <= y < n and not grid[x][y]:
				grid[x][y] = 1
				q.append((x, y, d+1))
	return -1
```

### [797\. All Paths From Source to Target](https://leetcode.com/problems/all-paths-from-source-to-target/)

Difficulty: **Medium**  

Related Topics: [Backtracking](https://leetcode.com/tag/backtracking/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Graph](https://leetcode.com/tag/graph/)


Given a directed acyclic graph (**DAG**) of `n` nodes labeled from `0` to `n - 1`, find all possible paths from node `0` to node `n - 1` and return them in **any order**.

The graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`).

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)

```
Input: graph = [[1,2],[3],[3],[]]
Output: [[0,1,3],[0,2,3]]
Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg)

```
Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]
Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
```

**Example 3:**

```
Input: graph = [[1],[]]
Output: [[0,1]]
```

**Example 4:**

```
Input: graph = [[1,2,3],[2],[3],[]]
Output: [[0,1,2,3],[0,2,3],[0,3]]
```

**Example 5:**

```
Input: graph = [[1,3],[2],[3],[]]
Output: [[0,1,2,3],[0,3]]
```

**Constraints:**

*   `n == graph.length`
*   `2 <= n <= 15`
*   `0 <= graph[i][j] < n`
*   `graph[i][j] != i` (i.e., there will be no self-loops).
*   All the elements of `graph[i]` are **unique**.
*   The input graph is **guaranteed** to be a **DAG**.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/all-paths-from-source-to-target/solution/)

```python
class Solution(object):
    def allPathsSourceTarget(self, graph):
        """
        :type graph: List[List[int]]
        :rtype: List[List[int]]
        """
        n = len(graph)
        res = []
        paths = [[0]]
        while paths:
            next_level = []
            for path in paths:
                if path[-1] == n - 1:
                    res.append(path)
                    continue
                for node in graph[path[-1]]:
                    next_level.append(path + [node])
            paths = next_level
        return res
```

### [490\. The Maze](https://leetcode.com/problems/the-maze/)

Difficulty: **Medium**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Graph](https://leetcode.com/tag/graph/)


There is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

Given the `m x n` `maze`, the ball's `start` position and the `destination`, where `start = [start<sub style="display: inline;">row</sub>, start<sub style="display: inline;">col</sub>]` and `destination = [destination<sub style="display: inline;">row</sub>, destination<sub style="display: inline;">col</sub>]`, return `true` if the ball can stop at the destination, otherwise return `false`.

You may assume that **the borders of the maze are all walls** (see examples).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/31/maze1-1-grid.jpg)

```
Input: maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [4,4]
Output: true
Explanation: One possible way is : left -> down -> left -> down -> right -> down -> right.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/31/maze1-2-grid.jpg)

```
Input: maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [3,2]
Output: false
Explanation: There is no way for the ball to stop at the destination. Notice that you can pass through the destination but you cannot stop there.
```

**Example 3:**

```
Input: maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], start = [4,3], destination = [0,1]
Output: false
```

**Constraints:**

*   `m == maze.length`
*   `n == maze[i].length`
*   `1 <= m, n <= 100`
*   `maze[i][j]` is `0` or `1`.
*   `start.length == 2`
*   `destination.length == 2`
*   `0 <= start<sub style="display: inline;">row</sub>, destination<sub style="display: inline;">row</sub> <= m`
*   `0 <= start<sub style="display: inline;">col</sub>, destination<sub style="display: inline;">col</sub> <= n`
*   Both the ball and the destination exist in an empty space, and they will not be in the same position initially.
*   The maze contains **at least 2 empty spaces**.


#### Solution

Language: **Python**

```python
class Solution(object):
    def hasPath(self, maze, start, destination):
        """
        :type maze: List[List[int]]
        :type start: List[int]
        :type destination: List[int]
        :rtype: bool
        """
        Q = [start]
        n = len(maze)
        m = len(maze[0])
        dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))

        while Q:
            # Use Q.pop() as DFS or Q.popleft() with deque from collections library for better performance. Kudos to @whglamrock
            i, j = Q.pop(0)
            maze[i][j] = 2

            if i == destination[0] and j == destination[1]:
                return True

            for x, y in dirs:
                row = i + x
                col = j + y
                while 0 <= row < n and 0 <= col < m and maze[row][col] != 1:
                    row += x
                    col += y
                row -= x
                col -= y
                if maze[row][col] == 0:
                    Q.append([row, col])

        return False
```

### [909\. Snakes and Ladders](https://leetcode.com/problems/snakes-and-ladders/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Matrix](https://leetcode.com/tag/matrix/)


You are given an `n x n` integer matrix `board` where the cells are labeled from `1` to `n<sup>2</sup>` in a starting from the bottom left of the board (i.e. `board[n - 1][0]`) and alternating direction each row.

You start on square `1` of the board. In each move, starting from square `curr`, do the following:

*   Choose a destination square `next` with a label in the range `[curr + 1, min(curr + 6, n<sup>2</sup>)]`.
    *   This choice simulates the result of a standard **6-sided die roll**: i.e., there are always at most 6 destinations, regardless of the size of the board.
*   If `next` has a snake or ladder, you **must** move to the destination of that snake or ladder. Otherwise, you move to `next`.
*   The game ends when you reach the square `n<sup>2</sup>`.

A board square on row `r` and column `c` has a snake or ladder if `board[r][c] != -1`. The destination of that snake or ladder is `board[r][c]`. Squares `1` and `n<sup>2</sup>` do not have a snake or ladder.

Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do **not** follow the subsequent snake or ladder.

*   For example, suppose the board is `[[-1,4],[-1,3]]`, and on the first move, your destination square is `2`. You follow the ladder to square `3`, but do **not** follow the subsequent ladder to `4`.

Return _the least number of moves required to reach the square_ `n<sup>2</sup>`_. If it is not possible to reach the square, return_ `-1`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/09/23/snakes.png)

```
Input: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
Output: 4
Explanation:
In the beginning, you start at square 1 (at row 5, column 0).
You decide to move to square 2 and must take the ladder to square 15.
You then decide to move to square 17 and must take the snake to square 13.
You then decide to move to square 14 and must take the ladder to square 35.
You then decide to move to square 36, ending the game.
This is the lowest possible number of moves to reach the last square, so return 4.
```

**Example 2:**

```
Input: board = [[-1,-1],[-1,3]]
Output: 1
```

**Constraints:**

*   `n == board.length == board[i].length`
*   `2 <= n <= 20`
*   `grid[i][j]` is either `-1` or in the range `[1, n<sup>2</sup>]`.
*   The squares labeled `1` and `n<sup>2</sup>` do not have any ladders or snakes.


#### Solution

Language: **Python**

```python
class Solution(object):
    def snakesAndLadders(self, board):
        """
        :type board: List[List[int]]
        :rtype: int
        """
        n = len(board)

        # create d
        count, is_reverse, d = 1, 0, {}
        for i in range(n - 1, -1, -1):
            for j in range(n):
                col = j if not is_reverse else n - 1 - j
                d[count] = (i, col)
                count += 1
            is_reverse = (is_reverse + 1) % 2

       # bfs
        dq = collections.deque()
        dq.append([1, 0])
        visited = set()
        visited.add(1)
        while dq:
            cur, step = dq.popleft()
            if cur == n ** 2:
                return step
            start, end = cur + 1, min(cur + 6, n ** 2)
            for next in range(start, end + 1):
                if next in visited:
                    continue
                row, col = d[next]
                if board[row][col]  == -1:
                    dq.append([next, step + 1])
                else:
                    dq.append([board[row][col], step + 1])
                visited.add(next)
        return -1
```

## Depth-first Search
### [301\. Remove Invalid Parentheses :fire:](https://leetcode.com/problems/remove-invalid-parentheses/)

Difficulty: **Hard**  

Related Topics: [String](https://leetcode.com/tag/string/), [Backtracking](https://leetcode.com/tag/backtracking/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/)


Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.

Return _all the possible results_. You may return the answer in **any order**.

**Example 1:**

```
Input: s = "()())()"
Output: ["(())()","()()()"]
```

**Example 2:**

```
Input: s = "(a)())()"
Output: ["(a())()","(a)()()"]
```

**Example 3:**

```
Input: s = ")("
Output: [""]
```

**Constraints:**

*   `1 <= s.length <= 25`
*   `s` consists of lowercase English letters and parentheses `'('` and `')'`.
*   There will be at most `20` parentheses in `s`.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/remove-invalid-parentheses/discuss/696750/Python-Backtracking-solution-detailed-explanation)
```Python
class Solution:
    def removeInvalidParentheses(self, s):
        ## RC ##
        ## APPROACH : BACK-TRACKING ##
        ## Similar to Leetcode 32. Longest Valid Parentheses ##
        ## LOGIC ##
        #   1. use stack to find invalid left and right braces.
        #   2. if its close brace at index i , you can remove it directly to make it valid and also you can also remove any of the close braces before that i.e in the range [0,i-1]
        #   3. similarly for open brace, left over at index i, you can remove it or any other open brace after that i.e [i+1, end]
        #   4. if left over braces are more than 1 say 2 close braces here, you need to make combinations of all 2 braces before that index and find valid parentheses.
        #   5. so, we count left and right invalid braces and do backtracking removing them

       ## TIME COMPLEXITY : O(2^N) ## (each brace has 2 options: exits or to be removed)
       ## SPACE COMPLEXITY : O(N) ##

        def isValid(s):
            stack = []
            for i in range(len(s)):
                if( s[i] == '(' ):
                    stack.append( (i,'(') )
                elif( s[i] == ')' ):
                    if(stack and stack[-1][1] == '('):
                        stack.pop()
                    else:
                        stack.append( (i,')') )         # pushing invalid close braces also
            return len(stack) == 0, stack


        def dfs( s, left, right):
            visited.add(s)
            if left == 0 and right == 0 and isValid(s)[0]:  res.append(s)
            for i, ch in enumerate(s):
                if ch != '(' and ch != ')': continue                                    # if it is any other char ignore.
                if (ch == '(' and left == 0) or (ch == ')' and right == 0): continue    # if left == 0 then removing '(' will only cause imbalance. Hence, skip.
                if s[:i] + s[i+1:] not in visited:
                    dfs( s[:i] + s[i+1:], left - (ch == '('), right - (ch == ')') )

        stack = isValid(s)[1]
        lc = sum([1 for val in stack if val[1] == "("]) # num of left braces
        rc = len(stack) - lc

        res, visited = [], set()
        dfs(s, lc, rc)
        return res
```

### [938\. Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` node of a binary search tree and two integers `low` and `high`, return _the sum of values of all nodes with a value in the **inclusive** range_ `[low, high]`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg)

```
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
Output: 32
Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg)

```
Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
Output: 23
Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 2 * 10<sup>4</sup>]`.
*   `1 <= Node.val <= 10<sup>5</sup>`
*   `1 <= low <= high <= 10<sup>5</sup>`
*   All `Node.val` are **unique**.


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def rangeSumBST(self, root, low, high):
        """
        :type root: TreeNode
        :type low: int
        :type high: int
        :rtype: int
        """
        if not root:
            return 0
        self.result = 0
        def dfs(root, low, high):
            if not root:
                return None
            if low <= root.val <= high:
                self.result += root.val
            if low < root.val:
                dfs(root.left, low, high)
            if high > root.val:
                dfs(root.right, low, high)
        dfs(root, low, high)
        return self.result
```

### [140\. Word Break II](https://leetcode.com/problems/word-break-ii/)

Difficulty: **Hard**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Backtracking](https://leetcode.com/tag/backtracking/), [Trie](https://leetcode.com/tag/trie/), [Memoization](https://leetcode.com/tag/memoization/)


Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**.

**Note** that the same word in the dictionary may be reused multiple times in the segmentation.

**Example 1:**

```
Input: s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
Output: ["cats and dog","cat sand dog"]
```

**Example 2:**

```
Input: s = "pineapplepenapple", wordDict = ["apple","pen","applepen","pine","pineapple"]
Output: ["pine apple pen apple","pineapple pen apple","pine applepen apple"]
Explanation: Note that you are allowed to reuse a dictionary word.
```

**Example 3:**

```
Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: []
```

**Constraints:**

*   `1 <= s.length <= 20`
*   `1 <= wordDict.length <= 1000`
*   `1 <= wordDict[i].length <= 10`
*   `s` and `wordDict[i]` consist of only lowercase English letters.
*   All the strings of `wordDict` are **unique**.


#### Solution

Language: **Python**


```python
def wordBreak(s, wordDict):
    if not s:
        return []
    result = []
    dfs(s, wordDict, '', result)
    return result

def dfs(s, wordDict, curr, result):
    if not s:
        result.append(curr[1: ])
        return
    for i in range(1, 1 + len(s)):
        if s[: i] in wordDict:
            dfs(s[i: ], wordDict, curr + ' ' + s[: i], result)


s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]    
wordBreak(s, wordDict)         
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
wordBreak(s, wordDict)         
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
wordBreak(s, wordDict)         
```

### [257\. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)

Difficulty: **Easy**  

Related Topics: [String](https://leetcode.com/tag/string/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, return _all root-to-leaf paths in **any order**_.

A **leaf** is a node with no children.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

```
Input: root = [1,2,3,null,5]
Output: ["1->2->5","1->3"]
```

**Example 2:**

```
Input: root = [1]
Output: ["1"]
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 100]`.
*   `-100 <= Node.val <= 100`


#### Solution

Language: **Python**


```python
def binaryTreePaths(root):
    if not root:
        return []
    result = []
    dfs(root, result, str(root.val))
    return result

def dfs(root, result, path):
    if root.left is None and root.right is None:
        result.append(path)
    if root.left:
        dfs(root.left, result, path + '->' + str(root.left.val))    
    if root.right:
        dfs(root.right, result, path + '->' + str(root.right.val))    

root = Node(3,
            left = Node(9),
            right = Node(20,
                         left = Node(15),
                         right = Node(7)
                         )
            )
root.pretty_print()
binaryTreePaths(root)
```

### [529\. Minesweeper](https://leetcode.com/problems/minesweeper/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Matrix](https://leetcode.com/tag/matrix/)


Let's play the minesweeper game (, )!

You are given an `m x n` char matrix `board` representing the game board where:

*   `'M'` represents an unrevealed mine,
*   `'E'` represents an unrevealed empty square,
*   `'B'` represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),
*   digit (`'1'` to `'8'`) represents how many mines are adjacent to this revealed square, and
*   `'X'` represents a revealed mine.

You are also given an integer array `click` where `click = [click<sub style="display: inline;">r</sub>, click<sub style="display: inline;">c</sub>]` represents the next click position among all the unrevealed squares (`'M'` or `'E'`).

Return _the board after revealing this position according to the following rules_:

1.  If a mine `'M'` is revealed, then the game is over. You should change it to `'X'`.
2.  If an empty square `'E'` with no adjacent mines is revealed, then change it to a revealed blank `'B'` and all of its adjacent unrevealed squares should be revealed recursively.
3.  If an empty square `'E'` with at least one adjacent mine is revealed, then change it to a digit (`'1'` to `'8'`) representing the number of adjacent mines.
4.  Return the board when no more squares will be revealed.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png)

```
Input: board = [["E","E","E","E","E"],["E","E","M","E","E"],["E","E","E","E","E"],["E","E","E","E","E"]], click = [3,0]
Output: [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_2.png)

```
Input: board = [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]], click = [1,2]
Output: [["B","1","E","1","B"],["B","1","X","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
```

**Constraints:**

*   `m == board.length`
*   `n == board[i].length`
*   `1 <= m, n <= 50`
*   `board[i][j]` is either `'M'`, `'E'`, `'B'`, or a digit from `'1'` to `'8'`.
*   `click.length == 2`
*   `0 <= click<sub style="display: inline;">r</sub> < m`
*   `0 <= click<sub style="display: inline;">c</sub> < n`
*   `board[click<sub style="display: inline;">r</sub>][click<sub style="display: inline;">c</sub>]` is either `'M'` or `'E'`.


#### Solution

Language: **Python**

```python
def updateBoard(board, click):
    m, n = len(board), len(board[0])
    (i, j), directions = click, [[-1, 0], [1, 0], [0, -1], [0, 1], [1, 1], [-1, -1], [-1, 1], [1, -1]]
    if 0 <= i < m and 0 <= j < n:
        if board[i][j] == 'M':
            board[i][j] = 'X'
        elif board[i][j] == 'E':
            num = sum([board[i + r][j + c] == 'M' for r, c in directions if 0 <= i + r < m and 0 <= j + c < n])
            if num > 0:
                board[i][j] = str(num)
            else:
                board[i][j] = 'B'
                for r, c in directions:
                    updateBoard(board, [i + r, j + c])            
    return board

board = [["E","E","E","E","E"],["E","E","M","E","E"],["E","E","E","E","E"],["E","E","E","E","E"]]
click = [3,0]
updateBoard(board, click)

board = [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
click = [1,2]
updateBoard(board, click)
```

### [695\. Max Area of Island](https://leetcode.com/problems/max-area-of-island/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Matrix](https://leetcode.com/tag/matrix/)


You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

The **area** of an island is the number of cells with a value `1` in the island.

Return _the maximum **area** of an island in_ `grid`. If there is no island, return `0`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)

```
Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
```

**Example 2:**

```
Input: grid = [[0,0,0,0,0,0,0,0]]
Output: 0
```

**Constraints:**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 50`
*   `grid[i][j]` is either `0` or `1`.


#### Solution

Language: **Python**

```python
def maxAreaOfIsland(grid):
    ans, n, m = 0, len(grid), len(grid[0])        
    for i in range(n):
        for j in range(m):
            if grid[i][j]:
                ans = max(ans, trav(i, j, m, n))
    return ans

def trav(i, j, m, n):
    if i < 0 or j < 0 or i >= n or j >= m or grid[i][j] == 0:
        return 0
    grid[i][j] = 0
    return 1 + trav(i-1, j, m, n) + trav(i, j-1, m, n) + trav(i+1, j, m, n) + trav(i, j+1, m, n)

grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
maxAreaOfIsland(grid)            
```

### [129\. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


You are given the `root` of a binary tree containing digits from `0` to `9` only.

Each root-to-leaf path in the tree represents a number.

*   For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.

Return _the total sum of all root-to-leaf numbers_. Test cases are generated so that the answer will fit in a **32-bit** integer.

A **leaf** node is a node with no children.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)

```
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)

```
Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 1000]`.
*   `0 <= Node.val <= 9`
*   The depth of the tree will not exceed `10`.


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def sumNumbers(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(node, carry):

            carry = carry * 10 + node.val
            if not node.left and not node.right:
                self.count += carry
                return
            if node.left:
                dfs(node.left, carry)
            if node.right:
                dfs(node.right, carry)
        self.count = 0
        dfs(root, 0)
        return self.count
```

### [111\. Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

**Note:** A leaf is a node with no children.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: 2
```

**Example 2:**

```
Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 10<sup>5</sup>]`.
*   `-1000 <= Node.val <= 1000`


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def minDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root: return 0
        left = self.minDepth(root.left)
        right = self.minDepth(root.right)
        if not left:
            return right + 1
        if not right:
            return left + 1
        return 1 + min(left, right)

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def minDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        dq = collections.deque()
        dq.append([root, 1])
        while dq:
            node, height = dq.popleft()
            if not node.left and not node.right:
                return height
            if node.left:
                dq.append([node.left, height + 1])
            if node.right:
                dq.append([node.right, height + 1])            
```

### [130\. Surrounded Regions :rainbow:](https://leetcode.com/problems/surrounded-regions/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `m x n` matrix `board` containing `'X'` and `'O'`, _capture all regions that are 4-directionally surrounded by_ `'X'`.

A region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

```
Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
```

**Example 2:**

```
Input: board = [["X"]]
Output: [["X"]]
```

**Constraints:**

*   `m == board.length`
*   `n == board[i].length`
*   `1 <= m, n <= 200`
*   `board[i][j]` is `'X'` or `'O'`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        ROWS, COLS = len(board), len(board[0])
        
        def capture(r, c):
            if (r < 0 or c < 0 or r == ROWS or c == COLS
                or board[r][c] != "O"):
                return
            board[r][c] = "T"
            capture(r + 1, c)
            capture(r - 1, c)
            capture(r, c + 1)
            capture(r, c - 1)
        
        # 1. (DFS) Capture unsurrounded regions (O -> T)
        for r in range(ROWS):
            for c in range(COLS):
                if (board[r][c] == "O" and
                    (r in [0, ROWS - 1] or c in [0, COLS - 1])):
                    capture(r, c)
        
        # 2. Capture surrounded regions (O -> X)
        for r in range(ROWS):
            for c in range(COLS):
                if board[r][c] == "O":
                    board[r][c] = "X"
                    
        # 3. Uncapture unsurrounded regions (T -> O)
        for r in range(ROWS):
            for c in range(COLS):
                if board[r][c] == "T":
                    board[r][c] = "O"
                    
```

## Backtracking
### [78\. Subsets](https://leetcode.com/problems/subsets/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/)


Given an integer array `nums` of **unique** elements, return _all possible subsets (the power set)_.

The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

**Example 1:**

```
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**Example 2:**

```
Input: nums = [0]
Output: [[],[0]]
```

**Constraints:**

*   `1 <= nums.length <= 10`
*   `-10 <= nums[i] <= 10`
*   All the numbers of `nums` are **unique**.


#### Solution

Language: **Python**

```python
def subsets(nums):
    if not subsets:
        return []
    result = []
    dfs(nums, 0, [], result)
    return result    

def dfs(nums, start, curr, result):
    result.append(curr[:])

    for i in range(start, len(nums)):
        curr.append(nums[i])
        dfs(nums, i + 1, curr, result)
        curr.pop()

subsets(nums = [1,2,3])
```

### [90\. Subsets II :fire:](https://leetcode.com/problems/subsets-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/)


Given an integer array `nums` that may contain duplicates, return _all possible subsets (the power set)_.

The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

**Example 1:**

```
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
```

**Example 2:**

```
Input: nums = [0]
Output: [[],[0]]
```

**Constraints:**

*   `1 <= nums.length <= 10`
*   `-10 <= nums[i] <= 10`


#### Solution

Language: **Python**


```python
def dfs(nums, start, cur, res):
    res.append(cur[:])
    for i in range(start, len(nums)):

        if i != start and nums[i] == nums[i-1]:
            continue

        cur.append(nums[i])
        dfs(nums, i + 1, cur, res)
        cur.pop()

def subsetsWithDup(nums):
    if nums is None:
        return []

    result = []
    nums.sort()
    dfs(nums, 0, [], result)
    return result

if __name__ == "__main__":
    subsetsWithDup([1,2,2])
```

### [22\. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Backtracking](https://leetcode.com/tag/backtracking/)


Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.

**Example 1:**

```
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
```

**Example 2:**

```
Input: n = 1
Output: ["()"]
```

**Constraints:**

*   `1 <= n <= 8`


#### Solution

Language: **Python**

```python
class Solution(object):
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        def backtrack(open_p, close_p, cur):
            if open_p == close_p == n:
                res.append(cur)
                return

            if open_p < n:
                backtrack(open_p + 1, close_p, cur + '(')

            if close_p < open_p:
                backtrack(open_p, close_p + 1, cur + ')')

        res = []
        backtrack(0, 0, '')
        return res
```

### [79\. Word Search](https://leetcode.com/problems/word-search/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `m x n` grid of characters `board` and a string `word`, return `true` _if_ `word` _exists in the grid_.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false
```

**Constraints:**

*   `m == board.length`
*   `n = board[i].length`
*   `1 <= m, n <= 6`
*   `1 <= word.length <= 15`
*   `board` and `word` consists of only lowercase and uppercase English letters.

**Follow up:** Could you use search pruning to make your solution faster with a larger `board`?


#### Solution

Language: **Python**

```python
def exist(board, word):
    visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))]

    for i in xrange(len(board)):
        for j in xrange(len(board[0])):
            if existRecu(board, word, 0, i, j, visited):
                return True
    return False

def existRecu(board, word, cur, i, j, visited):
    if cur == len(word):
        return True

    if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[cur]:
        return False

    visited[i][j] = True
    result = existRecu(board, word, cur + 1, i + 1, j, visited) or existRecu(board, word, cur + 1, i - 1, j, visited) or existRecu(board, word, cur + 1, i, j + 1, visited) or existRecu(board, word, cur + 1, i, j - 1, visited)
    visited[i][j] = False
    return result

board = ["ABCE",
         "SFCS",
         "ADEE"]
exist(board, "ABCCED")
exist(board, "SFCS")
exist(board, "ABCB")

def exist(self, board, word):
    if not board:
        return False
    for i in xrange(len(board)):
        for j in xrange(len(board[0])):
            if self.dfs(board, i, j, word):
                return True
    return False

# check whether can find word, start at (i,j) position    
def dfs(self, board, i, j, word):
    if len(word) == 0: # all the characters are checked
        return True
    if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or word[0]!=board[i][j]:
        return False
    tmp = board[i][j]  # first character is found, check the remaining part
    board[i][j] = "#"  # avoid visit agian
    # check whether can find "word" along one direction
    res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \
    or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:])
    board[i][j] = tmp
    return res
```

### [93\. Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Backtracking](https://leetcode.com/tag/backtracking/)


A **valid IP address** consists of exactly four integers separated by single dots. Each integer is between `0` and `255` (**inclusive**) and cannot have leading zeros.

*   For example, `"0.1.2.201"` and `"192.168.1.1"` are **valid** IP addresses, but `"0.011.255.245"`, `"192.168.1.312"` and `"192.168@1.1"` are **invalid** IP addresses.

Given a string `s` containing only digits, return _all possible valid IP addresses that can be formed by inserting dots into_ `s`. You are **not** allowed to reorder or remove any digits in `s`. You may return the valid IP addresses in **any** order.

**Example 1:**

```
Input: s = "25525511135"
Output: ["255.255.11.135","255.255.111.35"]
```

**Example 2:**

```
Input: s = "0000"
Output: ["0.0.0.0"]
```

**Example 3:**

```
Input: s = "1111"
Output: ["1.1.1.1"]
```

**Example 4:**

```
Input: s = "010010"
Output: ["0.10.0.10","0.100.1.0"]
```

**Example 5:**

```
Input: s = "101023"
Output: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

**Constraints:**

*   `0 <= s.length <= 20`
*   `s` consists of digits only.


#### Solution

Language: **Python**

```python
def restoreIpAddresses(s):
    if not s:
        return
    result = []
    dfs(s, '', result)
    return result

def dfs(s, cur, result):
    if not s and len(cur[: -1].split('.')) == 4:
        result.append(cur[: -1])
        return
    for i in range(1, len(s) + 1):
        if not s[: i].isdigit() or not 0 <= int(s[: i]) <= 255 or len(s[: i]) > 1 and s[: i][0] == '0':
            continue
        dfs(s[i: ], cur + s[: i] + '.' , result)

restoreIpAddresses(s = "25525511135")   
restoreIpAddresses(s = "0000")   
restoreIpAddresses(s = "1111")   
restoreIpAddresses(s = "010010")   
restoreIpAddresses(s = "101023")   
```

### [46\. Permutations](https://leetcode.com/problems/permutations/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/)


Given an array `nums` of distinct integers, return _all the possible permutations_. You can return the answer in **any order**.

**Example 1:**

```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**Example 2:**

```
Input: nums = [0,1]
Output: [[0,1],[1,0]]
```

**Example 3:**

```
Input: nums = [1]
Output: [[1]]
```

**Constraints:**

*   `1 <= nums.length <= 6`
*   `-10 <= nums[i] <= 10`
*   All the integers of `nums` are **unique**.


#### Solution

Language: **Python**

```python
def permute(nums):
    if not nums:
        return []
    result = []
    dfs(nums, [], result)
    return result

def dfs(nums, curr, result):
    if len(curr) == len(nums):
        result.append(curr[:])
    for num in nums:
        if num in curr:
            continue
        curr.append(num)
        dfs(nums, curr, result)
        curr.pop()

permute([1,2,3])
```

### [47\. Permutations II :fire:](https://leetcode.com/problems/permutations-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/)


Given a collection of numbers, `nums`, that might contain duplicates, return _all possible unique permutations **in any order**._

**Example 1:**

```
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**Example 2:**

```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**Constraints:**

*   `1 <= nums.length <= 8`
*   `-10 <= nums[i] <= 10`


#### Solution

Language: **Python**

```python
def permuteUnique(nums):
    nums.sort()
    result = []
    used = [False] * len(nums)
    permuteUniqueRecu(result, used, [], nums)
    return result

def permuteUniqueRecu(result, used, cur, nums):
    if len(cur) == len(nums):
        result.append(cur[:])
        return

    for i in xrange(len(nums)):
        if used[i]:
            continue
        if i > 0 and used[i-1] and nums[i-1] == nums[i]:
            continue
        used[i] = True
        cur.append(nums[i])
        permuteUniqueRecu(result, used, cur, nums)
        used[i] = False
        cur.pop()

permuteUnique([1,1,2])

def permuteUnique(nums):
    res = []
    cur = []
    count = {n: 0 for n in nums}
    for n in nums:
        count[n] += 1

    def dfs():
        if len(cur) == len(nums):
            res.append(cur.copy())
            return

        for n in count:
            if count[n] > 0:
                cur.append(n)
                count[n] -= 1
                dfs()
                count[n] += 1
                cur.pop()

permuteUnique([1,1,2])
```

### [17\. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Backtracking](https://leetcode.com/tag/backtracking/)


Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

**Example 1:**

```
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**Example 2:**

```
Input: digits = ""
Output: []
```

**Example 3:**

```
Input: digits = "2"
Output: ["a","b","c"]
```

**Constraints:**

*   `0 <= digits.length <= 4`
*   `digits[i]` is a digit in the range `['2', '9']`.


#### Solution

Language: **Python**

```python
digit2letters = {
                '2': "abc",
                '3': "def",
                '4': "ghi",
                '5': "jkl",
                '6': "mno",
                '7': "pqrs",
                '8': "tuv",
                '9': "wxyz"
                }
def letterCombinations(digits):
    if not digits:
        return []
    result = []
    dfs(digits, '', result)
    return result

def dfs(digits, curr, result):
    if not digits:
        result.append(curr[:])
        return
    for c in digit2letters[digits[0]]:
        dfs(digits[1: ], curr + c, result)

letterCombinations('23')
```

### [39\. Combination Sum](https://leetcode.com/problems/combination-sum/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/)


Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**.

The **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

It is **guaranteed** that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.

**Example 1:**

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7\. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
```

**Example 2:**

```
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
```

**Example 3:**

```
Input: candidates = [2], target = 1
Output: []
```

**Example 4:**

```
Input: candidates = [1], target = 1
Output: [[1]]
```

**Example 5:**

```
Input: candidates = [1], target = 2
Output: [[1,1]]
```

**Constraints:**

*   `1 <= candidates.length <= 30`
*   `1 <= candidates[i] <= 200`
*   All elements of `candidates` are **distinct**.
*   `1 <= target <= 500`


#### Solution

Language: **Python**

```python
def combinationSum(candidates, target):
    if not candidates:
        return []
    result = []
    dfs(candidates, target, [], result)
    return result

def dfs(candidates, target, curr, result):
    s = sum(curr)
    if s == target:
        result.append(curr[:])
        return
    elif s > target:
        return
    else:
        for i, num in enumerate(candidates):
            dfs(candidates[i: ], target, curr + [num], result)

combinationSum(candidates = [2,3,6,7], target = 7)    
combinationSum(candidates = [2,3,5], target = 8)    
```

### [40\. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/)


Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.

Each number in `candidates` may only be used **once** in the combination.

**Note:** The solution set must not contain duplicate combinations.

**Example 1:**

```
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

**Example 2:**

```
Input: candidates = [2,5,2,1,2], target = 5
Output:
[
[1,2,2],
[5]
]
```

**Constraints:**

*   `1 <= candidates.length <= 100`
*   `1 <= candidates[i] <= 50`
*   `1 <= target <= 30`


#### Solution

Language: **Python**

```python
class Solution(object):
    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        def dfs(candidates, target, curr, result):
            s = sum(curr)
            if s == target:
                result.append(curr[:])
                return
            elif s > target:
                return
            else:
                for i, num in enumerate(candidates):
                    if i > 0 and candidates[i] == candidates[i - 1]:
                        continue
                    dfs(candidates[i + 1: ], target, curr + [num], result)

        if not candidates:
            return []
        candidates.sort()
        result = []
        dfs(candidates, target, [], result)
        return result


```

### [254\. Factor Combinations](https://leetcode.com/problems/factor-combinations/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/)


Numbers can be regarded as the product of their factors.

*   For example, `8 = 2 x 2 x 2 = 2 x 4`.

Given an integer `n`, return _all possible combinations of its factors_. You may return the answer in **any order**.

**Note** that the factors should be in the range `[2, n - 1]`.

**Example 1:**

```
Input: n = 1
Output: []
```

**Example 2:**

```
Input: n = 12
Output: [[2,6],[3,4],[2,2,3]]
```

**Example 3:**

```
Input: n = 37
Output: []
```

**Example 4:**

```
Input: n = 32
Output: [[2,16],[4,8],[2,2,8],[2,4,4],[2,2,2,4],[2,2,2,2,2]]
```

**Constraints:**

*   `1 <= n <= 10<sup>7</sup>`


#### Solution

Language: **Python**

```python
def getFactors(n):
    result = []
    dfs(result, [], n, 2)
    return result

def dfs(result, cur, n, factor):
    if len(cur) > 1 and n == 1:
        result.append(cur[:])
        return
    for num in range(factor, n + 1):
        if n % num == 0:
            cur.append(num)
            dfs(result, cur, n // num, num)
            cur.pop()
getFactors(8)
```
### [37\. Sudoku Solver :fire:](https://leetcode.com/problems/sudoku-solver/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/), [Matrix](https://leetcode.com/tag/matrix/)


Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy **all of the following rules**:

1.  Each of the digits `1-9` must occur exactly once in each row.
2.  Each of the digits `1-9` must occur exactly once in each column.
3.  Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.

The `'.'` character indicates empty cells.

**Example 1:**

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

```
Input: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
Explanation: The input board is shown above and the only valid solution is shown below:

```

**Constraints:**

*   `board.length == 9`
*   `board[i].length == 9`
*   `board[i][j]` is a digit or `'.'`.
*   It is **guaranteed** that the input board has only one solution.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/sudoku-solver/solution/)
```Python
def check(x, y, board):
    tmp = board[x][y]
    board[x][y] = '.'
    for row in range(9):
        if board[row][y] == tmp:
            return False
    for col in range(9):
        if board[x][col] == tmp:
            return False
    for row in range(3):
        for col in range(3):
            if board[(x / 3) * 3 + row][(y / 3) * 3 + col] == tmp:
                return False
    board[x][y] = tmp
    return True

def dfs(board):
    # Go to next empty space
    for row in range(9):
        for col in range(9):
            # Try all options, backtracking if not work
            if board[row][col] == '.':
                for char in '123456789':
                    board[row][col] = char
                    if check(row, col, board) and dfs(board):
                        return True
                    board[row][col] = '.'
                return False
    return True

def solveSudoku(board):
    dfs(board)
    return board

if __name__ == '__main__':
  board = [
    ["5","3",".",".","7",".",".",".","."],
    ["6",".",".","1","9","5",".",".","."],
    [".","9","8",".",".",".",".","6","."],
    ["8",".",".",".","6",".",".",".","3"],
    ["4",".",".","8",".","3",".",".","1"],
    ["7",".",".",".","2",".",".",".","6"],
    [".","6",".",".",".",".","2","8","."],
    [".",".",".","4","1","9",".",".","5"],
    [".",".",".",".","8",".",".","7","9"]]
    solveSudoku(board)
```

### [1774\. Closest Dessert Cost](https://leetcode.com/problems/closest-dessert-cost/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Backtracking](https://leetcode.com/tag/backtracking/)


You would like to make dessert and are preparing to buy the ingredients. You have `n` ice cream base flavors and `m` types of toppings to choose from. You must follow these rules when making your dessert:

*   There must be **exactly one** ice cream base.
*   You can add **one or more** types of topping or have no toppings at all.
*   There are **at most two** of **each type** of topping.

You are given three inputs:

*   `baseCosts`, an integer array of length `n`, where each `baseCosts[i]` represents the price of the `i<sup>th</sup>` ice cream base flavor.
*   `toppingCosts`, an integer array of length `m`, where each `toppingCosts[i]` is the price of **one** of the `i<sup>th</sup>` topping.
*   `target`, an integer representing your target price for dessert.

You want to make a dessert with a total cost as close to `target` as possible.

Return _the closest possible cost of the dessert to_ `target`. If there are multiple, return _the **lower** one._

**Example 1:**

```
Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10
Output: 10
Explanation: Consider the following combination (all 0-indexed):
- Choose base 1: cost 7
- Take 1 of topping 0: cost 1 x 3 = 3
- Take 0 of topping 1: cost 0 x 4 = 0
Total: 7 + 3 + 0 = 10.
```

**Example 2:**

```
Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18
Output: 17
Explanation: Consider the following combination (all 0-indexed):
- Choose base 1: cost 3
- Take 1 of topping 0: cost 1 x 4 = 4
- Take 2 of topping 1: cost 2 x 5 = 10
- Take 0 of topping 2: cost 0 x 100 = 0
Total: 3 + 4 + 10 + 0 = 17\. You cannot make a dessert with a total cost of 18.
```

**Example 3:**

```
Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9
Output: 8
Explanation: It is possible to make desserts with cost 8 and 10\. Return 8 as it is the lower cost.
```

**Constraints:**

*   `n == baseCosts.length`
*   `m == toppingCosts.length`
*   `1 <= n, m <= 10`
*   `1 <= baseCosts[i], toppingCosts[i] <= 10<sup>4</sup>`
*   `1 <= target <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def closestCost(self, baseCosts, toppingCosts, target):
        """
        :type baseCosts: List[int]
        :type toppingCosts: List[int]
        :type target: int
        :rtype: int
        """
        def dfs(cur, target, toppingCosts):
            if abs(cur - target) < abs(self.ans - target):
                    self.ans = cur
            if cur > target:
                return                
            else:
                for i, topping in enumerate(toppingCosts):
                    dfs(cur+0*topping, target, toppingCosts[i+1: ])
                    dfs(cur+1*topping, target, toppingCosts[i+1: ])
                    dfs(cur+2*topping, target, toppingCosts[i+1: ])


        self.ans = float('inf')
        for cost in baseCosts:
            dfs(cost, target, toppingCosts)

        return self.ans
```

### [131\. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Backtracking](https://leetcode.com/tag/backtracking/)


Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return all possible palindrome partitioning of `s`.

A **palindrome** string is a string that reads the same backward as forward.

**Example 1:**

```
Input: s = "aab"
Output: [["a","a","b"],["aa","b"]]
```

**Example 2:**

```
Input: s = "a"
Output: [["a"]]
```

**Constraints:**

*   `1 <= s.length <= 16`
*   `s` contains only lowercase English letters.


#### Solution

Language: **Python**

```python
class Solution:
    def partition(self, s):
        res = []
        self.dfs(s, [], res)
        return res

    def dfs(self, s, path, res):
        if not s:
            res.append(path)
            return
        for i in range(1, len(s)+1):
            if self.isPal(s[:i]):
                self.dfs(s[i:], path+[s[:i]], res)

    def isPal(self, s):
        return s == s[::-1]
```

### [1849\. Splitting a String Into Descending Consecutive Values](https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Backtracking](https://leetcode.com/tag/backtracking/)


You are given a string `s` that consists of only digits.

Check if we can split `s` into **two or more non-empty substrings** such that the **numerical values** of the substrings are in **descending order** and the **difference** between numerical values of every two **adjacent** **substrings** is equal to `1`.

*   For example, the string `s = "0090089"` can be split into `["0090", "089"]` with numerical values `[90,89]`. The values are in descending order and adjacent values differ by `1`, so this way is valid.
*   Another example, the string `s = "001"` can be split into `["0", "01"]`, `["00", "1"]`, or `["0", "0", "1"]`. However all the ways are invalid because they have numerical values `[0,1]`, `[0,1]`, and `[0,0,1]` respectively, all of which are not in descending order.

Return `true` _if it is possible to split_ `s` _as described above__, or_ `false` _otherwise._

A **substring** is a contiguous sequence of characters in a string.

**Example 1:**

```
Input: s = "1234"
Output: false
Explanation: There is no valid way to split s.
```

**Example 2:**

```
Input: s = "050043"
Output: true
Explanation: s can be split into ["05", "004", "3"] with numerical values [5,4,3].
The values are in descending order with adjacent values differing by 1.
```

**Example 3:**

```
Input: s = "9080701"
Output: false
Explanation: There is no valid way to split s.
```

**Constraints:**

*   `1 <= s.length <= 20`
*   `s` only consists of digits.


#### Solution

Language: **Python**

```python
class Solution(object):
    def splitString(self, s):
        """
        :type s: str
        :rtype: bool
        """
        def dfs(index, prev):
            if index == len(s):
                return True
            for j in range(index, len(s)):
                candidate = int(s[index: j + 1])
                if candidate + 1 == prev and dfs(j + 1, candidate):
                    return True
            return False

        for i in range(len(s) - 1):
            start = int(s[ :i + 1])
            if dfs(i + 1, start):
                return True
        return False
```

### [698\. Partition to K Equal Sum Subsets :fire:](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Backtracking](https://leetcode.com/tag/backtracking/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/), [Memoization](https://leetcode.com/tag/memoization/), [Bitmask](https://leetcode.com/tag/bitmask/)


Given an integer array `nums` and an integer `k`, return `true` if it is possible to divide this array into `k` non-empty subsets whose sums are all equal.

**Example 1:**

```
Input: nums = [4,3,2,3,5,2,1], k = 4
Output: true
Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
```

**Example 2:**

```
Input: nums = [1,2,3,4], k = 3
Output: false
```

**Constraints:**

*   `1 <= k <= nums.length <= 16`
*   `1 <= nums[i] <= 10<sup>4</sup>`
*   The frequency of each element is in the range `[1, 4]`.


#### Solution

Language: **Python**

I think that the worst time complexitiy is O(n*2^n). Because for each bucket, we have to check whether one specific subset of the nums array can be put into it. But as we have visited some of the numbers, and doing some optimization, like sorting the array or pruning, the time complexitiy will be much smaller than the worst case.
```python
class Solution(object):
    def canPartitionKSubsets(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        total = sum(nums)
        div, rem = divmod(total, k)
        if rem != 0:
            return False
        nums.sort(reverse = True)   
        target = [div] * k
        def dfs(target, k, index, nums):
            if index == len(nums):
                return True
            num = nums[index]
            for j in range(k):
                if target[j] - num >= 0:
                    target[j] -= num
                    if dfs(target, k, index + 1, nums):
                        return True
                    target[j] += num

        return dfs(target, k, 0, nums)

class Solution(object):
    def canPartitionKSubsets(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        target = sum(nums) / k
        used = [False] * len(nums)

        def backtrack(i, k, subsetSum):
            if k == 0:
                return True
            if subsetSum == target:
                return backtrack(0, k - 1, 0)

            for j in range(i, len(nums)):
                if used[j] and subsetSum + nums[j] > target:
                    continue
                used[j] = True
                if backtrack(j + 1, k, subsetSum + nums[j]):
                    return True
                used[j] = False
            return False
        return backtrack(0, k, 0)
```

### [332\. Reconstruct Itinerary :rainbow:](https://leetcode.com/problems/reconstruct-itinerary/)

Difficulty: **Hard**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Graph](https://leetcode.com/tag/graph/), [Eulerian Circuit](https://leetcode.com/tag/eulerian-circuit/)


You are given a list of airline `tickets` where `tickets[i] = [from<sub style="display: inline;">i</sub>, to<sub style="display: inline;">i</sub>]` represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.

All of the tickets belong to a man who departs from `"JFK"`, thus, the itinerary must begin with `"JFK"`. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.

*   For example, the itinerary `["JFK", "LGA"]` has a smaller lexical order than `["JFK", "LGB"]`.

You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)

```
Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg)

```
Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"] but it is larger in lexical order.
```

**Constraints:**

*   `1 <= tickets.length <= 300`
*   `tickets[i].length == 2`
*   `from<sub style="display: inline;">i</sub>.length == 3`
*   `to<sub style="display: inline;">i</sub>.length == 3`
*   `from<sub style="display: inline;">i</sub>` and `to<sub style="display: inline;">i</sub>` consist of uppercase English letters.
*   `from<sub style="display: inline;">i</sub> != to<sub style="display: inline;">i</sub>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def findItinerary(self, tickets):
        """
        :type tickets: List[List[str]]
        :rtype: List[str]
        """
        adj = { u:collections.deque() for u, v in tickets }
        res = ["JFK"]

        tickets.sort()
        for u, v in tickets:
            adj[u].append(v)

        def dfs(cur):
            if len(res) == len(tickets) + 1:
                return True
            if cur not in adj:
                return False

            temp = list(adj[cur])
            for v in temp:
                adj[cur].popleft()
                res.append(v)
                if dfs(v):
                    return res
                res.pop()
                adj[cur].append(v)
            return False        
        dfs("JFK")
        return res

# my sol: not ac
class Solution(object):
    def findItinerary(self, tickets):
        """
        :type tickets: List[List[str]]
        :rtype: List[str]
        """
        def dfs(node, count, cur):
            if count == 0:
                res.append(cur[:])
                return

            for nei in graph[node]:
                graph[node].remove(nei)
                nei_count = count if graph[node] else count - 1
                dfs(nei, nei_count, cur + [nei])                
                graph[node].add(nei)



        graph = collections.defaultdict(set)
        for start, end in tickets:
            graph[start].add(end)

        res = []
        dfs('JFK', len(graph), ['JFK'])
        return sorted(res)[0]
```

### [1239\. Maximum Length of a Concatenated String with Unique Characters](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/), [Backtracking](https://leetcode.com/tag/backtracking/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/)


You are given an array of strings `arr`. A string `s` is formed by the **concatenation** of a **subsequence** of `arr` that has **unique characters**.

Return _the **maximum** possible length_ of `s`.

A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

**Example 1:**

```
Input: arr = ["un","iq","ue"]
Output: 4
Explanation: All the valid concatenations are:
- ""
- "un"
- "iq"
- "ue"
- "uniq" ("un" + "iq")
- "ique" ("iq" + "ue")
Maximum length is 4.
```

**Example 2:**

```
Input: arr = ["cha","r","act","ers"]
Output: 6
Explanation: Possible longest valid concatenations are "chaers" ("cha" + "ers") and "acters" ("act" + "ers").
```

**Example 3:**

```
Input: arr = ["abcdefghijklmnopqrstuvwxyz"]
Output: 26
Explanation: The only string in arr has all 26 characters.
```

**Constraints:**

*   `1 <= arr.length <= 16`
*   `1 <= arr[i].length <= 26`
*   `arr[i]` contains only lowercase English letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def maxLength(self, arr):
        """
        :type arr: List[str]
        :rtype: int
        """
        def is_overlap(s1, s2):
            set1 = set(s1)
            for ch in s2:
                if ch in set1:
                    return True
            return False
        
        def is_unique(s):
            d = {}
            for ch in s:
                d[ch] = d.get(ch, 0) + 1
                if d[ch] > 1:
                    return False
            return True
        
        def dfs(index, cur):
            self.size = max(self.size, len(cur))
            for i in range(index, len(arr)):
                if is_overlap(cur, arr[i]) or not is_unique(arr[i]):
                    continue
                #print(index, arr[index], cur)
                dfs(i + 1, cur + arr[i])
                
        self.size = 0
        dfs(0, '')
        return self.size
```

### [77\. Combinations](https://leetcode.com/problems/combinations/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/)


Given two integers `n` and `k`, return _all possible combinations of_ `k` _numbers out of the range_ `[1, n]`.

You may return the answer in **any order**.

**Example 1:**

```
Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**Example 2:**

```
Input: n = 1, k = 1
Output: [[1]]
```

**Constraints:**

*   `1 <= n <= 20`
*   `1 <= k <= n`


#### Solution

Language: **Python**

```python
class Solution(object):
    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
        def dfs(start, cur):
            if len(cur) == k:
                res.append(cur[:])
                return
            for i in range(start, n + 1):
                dfs(i + 1, cur + [i])
        
        res = []
        dfs(1, [])
        return res
```

### [51\. N-Queens :fire:](https://leetcode.com/problems/n-queens/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/)


The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Given an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.

Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
Input: n = 4
Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
```

**Example 2:**

```
Input: n = 1
Output: [["Q"]]
```

**Constraints:**

*   `1 <= n <= 9`


#### Solution

Language: **Python**

```python
class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        col = set()
        posDiag = set() # (r + c)
        negDiag = set() # (r - c)
        
        res = []
        board = [["."] * n for i in range(n)]
        def backtrack(r):
            if r == n:
                copy = ["".join(row) for row in board]
                res.append(copy)
                return
            
            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue
                
                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = "Q"
                
                backtrack(r + 1)
                
                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "."
        backtrack(0)
        return res
```

## Dynamic Programming
### [139\. Word Break](https://leetcode.com/problems/word-break/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Trie](https://leetcode.com/tag/trie/), [Memoization](https://leetcode.com/tag/memoization/)


Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.

**Note** that the same word in the dictionary may be reused multiple times in the segmentation.

**Example 1:**

```
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
```

**Example 2:**

```
Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
```

**Example 3:**

```
Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
```

**Constraints:**

*   `1 <= s.length <= 300`
*   `1 <= wordDict.length <= 1000`
*   `1 <= wordDict[i].length <= 20`
*   `s` and `wordDict[i]` consist of only lowercase English letters.
*   All the strings of `wordDict` are **unique**.


#### Solution

Language: **Python**

```python
class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        n = len(s)
        dp = [0] * (n + 1)
        dp[0] = 1
        for j in range(n + 1):
            for i in range(j):
                if dp[i] == 1 and s[i: j] in wordDict:
                    dp[j] = 1
        return dp[-1]
```

### [10\. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)

Difficulty: **Hard**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Recursion](https://leetcode.com/tag/recursion/)


Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:

*   `'.'` Matches any single character.
*   `'*'` Matches zero or more of the preceding element.

The matching should cover the **entire** input string (not partial).

**Example 1:**

```
Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
```

**Example 2:**

```
Input: s = "aa", p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
```

**Example 3:**

```
Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
```

**Example 4:**

```
Input: s = "aab", p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
```

**Example 5:**

```
Input: s = "mississippi", p = "mis*is*p*."
Output: false
```

**Constraints:**

*   `1 <= s.length <= 20`
*   `1 <= p.length <= 30`
*   `s` contains only lowercase English letters.
*   `p` contains only lowercase English letters, `'.'`, and `'*'`.
*   It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.


#### Solution

Language: **Python**

* [](https://blog.csdn.net/L141210113/article/details/87925786)
```python
class Solution:
    def isMatch(self, s, p):
        if len(p) == 0: return len(s) == 0
        flag = len(s) != 0 and p[0] in {s[0], '.'}
        if len(p) >=2 and p[1] == '*':
            return (flag and self.isMatch(s[1:], p) or (self.isMatch(s, p[2:])))
        else:
            return flag and self.isMatch(s[1:], p[1:])


class Solution:
    def isMatch(self, s, p):
        #Falsedp[i][j]s[0->i]  p[0->j]
        dp=[[False for i in range(len(p)+1)] for j in range(len(s)+1)]
        #sp
        dp[0][0]=True
        #s** : s=''; p = 'a*'
        for i in range(1,len(p)+1):
            dp[0][i] = p[i-1] == '*' and dp[0][i-2] and i>1

        for i in range(1,len(s)+1):
            for j in range(1,len(p)+1):
                #p'*'**s*s
                #//**dp[i-1][j]

                if p[j-1]=='*':
                    dp[i][j]=dp[i][j-2] or (dp[i-1][j] and (s[i-1]==p[j-2] or p[j-2]=='.'))
                #*and
                else:
                    dp[i][j] = dp[i-1][j-1] and (p[j-1] == '.' or p[j-1] == s[i-1])
        #s[0->len(s)]  p[0->len(p)]
        return dp[len(s)][len(p)]
```

### [121\. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


You are given an array `prices` where `prices[i]` is the price of a given stock on the `i<sup>th</sup>` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

Return _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.

**Example 1:**

```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

**Example 2:**

```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
```

**Constraints:**

*   `1 <= prices.length <= 10<sup>5</sup>`
*   `0 <= prices[i] <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
def maxProfit(prices):
    max_profit = 0
    min_price = prices[0]
    for price in prices[1:]:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit

maxProfit([7,1,5,3,6,4])  
maxProfit([7,6,4,3,1])
```

### [188\. Best Time to Buy and Sell Stock IV :fire:](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `i<sup>th</sup>` day, and an integer `k`.

Find the maximum profit you can achieve. You may complete at most `k` transactions.

**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

**Example 1:**

```
Input: k = 2, prices = [2,4,1]
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
```

**Example 2:**

```
Input: k = 2, prices = [3,2,6,5,0,3]
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4\. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
```

**Constraints:**

*   `0 <= k <= 100`
*   `0 <= prices.length <= 1000`
*   `0 <= prices[i] <= 1000`


#### Solution

Language: **Python3**

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        @lru_cache(maxsize=None)
        def recursion(day: int, canBuy: bool, currNumTrans: int) -> int:
            if day >= len(prices):
                return 0
            if currNumTrans >= k:
                return 0
            
            buyOnTheDay = sellOnTheDay = 0
            if canBuy:
                buyOnTheDay = -prices[day] + recursion(day + 1, False, currNumTrans)
            else:
                sellOnTheDay = prices[day] + recursion(day + 1, True, currNumTrans + 1)
            doNothing = recursion(day + 1, canBuy, currNumTrans)
            
            return max(buyOnTheDay, sellOnTheDay, doNothing)
        
        return recursion(0, True, 0)
```

### [91\. Decode Ways :rainbow:](https://leetcode.com/problems/decode-ways/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

To **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `"11106"` can be mapped into:

*   `"AAJF"` with the grouping `(1 1 10 6)`
*   `"KJF"` with the grouping `(11 10 6)`

Note that the grouping `(1 11 06)` is invalid because `"06"` cannot be mapped into `'F'` since `"6"` is different from `"06"`.

Given a string `s` containing only digits, return _the **number** of ways to **decode** it_.

The answer is guaranteed to fit in a **32-bit** integer.

**Example 1:**

```
Input: s = "12"
Output: 2
Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).
```

**Example 2:**

```
Input: s = "226"
Output: 3
Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
```

**Example 3:**

```
Input: s = "0"
Output: 0
Explanation: There is no character that is mapped to a number starting with 0.
The only valid mappings with 0 are 'J' -> "10" and 'T' -> "20", neither of which start with 0.
Hence, there are no valid ways to decode this since all digits need to be mapped.
```

**Example 4:**

```
Input: s = "06"
Output: 0
Explanation: "06" cannot be mapped to "F" because of the leading zero ("6" is different from "06").
```

**Constraints:**

*   `1 <= s.length <= 100`
*   `s` contains only digits and may contain leading zero(s).


#### Solution

Language: **Python**

```python
class Solution(object):
    def numDecodings(self, s):
        dp = {len(s): 1}

        for i in range(len(s) - 1, -1, -1):
            if s[i] == '0':
                dp[i] = 0
            else:
                dp[i] = dp[i + 1]
            if i + 1 < len(s) and (s[i] == '1' or s[i] == '2' and s[i + 1] in '0123456'):
                dp[i] += dp[i + 2]
        return dp[0]

        dp = {len(s): 1}

        def dfs(i):
            if i in dp:
                return dp[i]
            if s[i] == '0':
                return 0
            res = dfs(i + 1)
            if i + 1 < len(s) and (s[i] == '1' or s[i] == '2' and s[i + 1] in '0123456'):
                res += dfs(i + 2)
            dp[i] = res
            return res
        return dfs(0)
```

* [](https://www.youtube.com/watch?v=OjEHST4SXfE&ab_channel=HuaHua)
```python
class Solution(object):
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int
        """
        n = len(s)
        dp = [0] * (n + 1)
        dp[0] = 1
        for i in range(1, n + 1):
            if s[i - 1] != '0':
                dp[i] += dp[i - 1]
            if i > 1 and '09' < s[i-2:i] < '27':
                dp[i] += dp[i - 2]
        return dp[-1]

# sol-2: DFS O(2^n)
def numDecodings(s):
    if not s:
        return 0
    result = []
    dfs(s, [], result)
    return len(result)

def dfs(s, curr, result):
    if not s:
        result.append(curr[:])
        return

    for i in range(1, len(s) + 1):
        if 0 < int(s[: i]) < 27:
            curr.append(s[: i])
            dfs(s[i: ], curr, result)
            curr.pop()

numDecodings('12')
numDecodings('226')
```

### [1027\. Longest Arithmetic Subsequence :fire:](https://leetcode.com/problems/longest-arithmetic-subsequence/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Binary Search](https://leetcode.com/tag/binary-search/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given an array `nums` of integers, return the **length** of the longest arithmetic subsequence in `nums`.

Recall that a _subsequence_ of an array `nums` is a list `nums[i<sub style="display: inline;">1</sub>], nums[i<sub style="display: inline;">2</sub>], ..., nums[i<sub style="display: inline;">k</sub>]` with `0 <= i<sub style="display: inline;">1</sub> < i<sub style="display: inline;">2</sub> < ... < i<sub style="display: inline;">k</sub> <= nums.length - 1`, and that a sequence `seq` is _arithmetic_ if `seq[i+1] - seq[i]` are all the same value (for `0 <= i < seq.length - 1`).

**Example 1:**

```
Input: nums = [3,6,9,12]
Output: 4
Explanation:
The whole array is an arithmetic sequence with steps of length = 3.
```

**Example 2:**

```
Input: nums = [9,4,7,2,10]
Output: 3
Explanation:
The longest arithmetic subsequence is [4,7,10].
```

**Example 3:**

```
Input: nums = [20,1,15,3,10,5,8]
Output: 4
Explanation:
The longest arithmetic subsequence is [20,15,10,5].
```

**Constraints:**

*   `2 <= nums.length <= 1000`
*   `0 <= nums[i] <= 500`


#### Solution

Language: **Python**

```python
def longestArithSeqLength(self, A):
    dp = defaultdict(dict)
    longest = 1

    for i in range(1, N):
        for j in range(i):
            diff = nums[i] - nums[j]
            if diff not in dp[j]:
                dp[i][diff] = 2
            else:
                dp[i][diff] = dp[j][diff] + 1
            longest = max(longest, dp[i][diff])
    return longest

longestArithSeqLength(nums = [3,6,9,12])
longestArithSeqLength(nums = [9,4,7,2,10])
longestArithSeqLength(nums = [20,1,15,3,10,5,8])
```

### [647\. Palindromic Substrings :fire:](https://leetcode.com/problems/palindromic-substrings/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given a string `s`, return _the number of **palindromic substrings** in it_.

A string is a **palindrome** when it reads the same backward as forward.

A **substring** is a contiguous sequence of characters within the string.

**Example 1:**

```
Input: s = "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
```

**Example 2:**

```
Input: s = "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
```

**Constraints:**

*   `1 <= s.length <= 1000`
*   `s` consists of lowercase English letters.


#### Solution

Language: **Python**

```python
def countSubstrings(s):
    n = len(s)
    count = 0
    dp = [[False] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = True
        for j in range(i):
            if i - j == 1:
                dp[j][i] = s[j] == s[i]
            if i - j > 1:
                dp[j][i] = s[j] == s[i] and dp[j + 1][i - 1]
    return sum([sum(item) for item in dp])

countSubstrings('abc')
countSubstrings('aaa')

def countSubstrings(s):

    global result
    result = 0

    def expandFromCenter(i, j):
        global result
        while 0 <= i < len(s) and 0 <= j < len(s) and s[i] == s[j]:                
            result += 1
            i -= 1
            j += 1        

    for idx in range(len(s)):
        expandFromCenter(idx, idx) # odd expansion
        expandFromCenter(idx, idx+1) # even expansion

    return result
```

### [416\. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given a **non-empty** array `nums` containing **only positive integers**, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

**Example 1:**

```
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
```

**Example 2:**

```
Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
```

**Constraints:**

*   `1 <= nums.length <= 200`
*   `1 <= nums[i] <= 100`


#### Solution

Language: **Python**

* [](https://labuladong.gitee.io/algo/3/25/81/)

```python
class Solution:
    def canPartition(self, nums):
        @cache
        def subsetSum(s, i):
            if s == 0: return True
            if i >= len(nums) or s < 0: return False
            return subsetSum(s-nums[i], i+1) or subsetSum(s, i+1)
        total_sum = sum(nums)
        return total_sum & 1 == 0 and subsetSum(total_sum // 2, 0)

class Solution:
    def canPartition(self, nums):
        total_sum = sum(nums)
        if total_sum & 1: return False
        half_sum = total_sum // 2
        dp = [True] + [False]*half_sum
        for num in nums:
            for j in range(half_sum, num-1, -1):
                dp[j] |= dp[j-num]
        return dp[half_sum]
```

### [53\. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return _its sum_.

A **subarray** is a **contiguous** part of an array.

**Example 1:**

```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

**Example 2:**

```
Input: nums = [1]
Output: 1
```

**Example 3:**

```
Input: nums = [5,4,-1,7,8]
Output: 23
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`

**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.


#### Solution

Language: **Python**

`dp`  `dp[i]` 
```python
def maxSubArray(nums):
    cum_sum = 0
    pre_sum = []
    nums = [0] + nums
    for num in nums:
        cum_sum += num
        pre_sum.append(cum_sum)

    result = float('-inf')       
    for j in range(len(pre_sum)):
        for i in range(j):
            result = max(result, pre_sum[j] - pre_sum[i])
    return result
maxSubArray([-2,1,-3,4,-1,2,1,-5,4])


# sol-2: O(n)
def maxSubArray(nums):
    dp = [0] * (len(nums))
    dp[0] = nums[0]
    result = nums[0]
    for i in range(1, len(nums)):
        dp[i] = max(dp[i - 1] + nums[i], nums[i])
        result = max(result, dp[i])
        print dp
    return result

maxSubArray([-2,1,-3,4,-1,2,1,-5,4])
```

### [5\. Longest Palindromic Substring :rainbow:](https://leetcode.com/problems/longest-palindromic-substring/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given a string `s`, return _the longest palindromic substring_ in `s`.

**Example 1:**

```
Input: s = "babad"
Output: "bab"
Note: "aba" is also a valid answer.
```

**Example 2:**

```
Input: s = "cbbd"
Output: "bb"
```

**Example 3:**

```
Input: s = "a"
Output: "a"
```

**Example 4:**

```
Input: s = "ac"
Output: "a"
```

**Constraints:**

*   `1 <= s.length <= 1000`
*   `s` consist of only digits and English letters.


#### Solution

Language: **Python**

```python
class Solution(object):

    def longestPalindrome(self, s):
        if len(set(s)) == 1: return s
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        result = ''
        for i in range(n - 1, -1, -1):#for j in range(n):
            dp[i][i] = True
            result = s[i]
        for i in range(n - 1, -1, -1):#for j in range(n):
            for j in range(i + 1, n): #for i in range(j, -1, -1):
                if j == i + 1:
                    dp[i][j] = s[i] == s[j]
                if j > i + 1:
                    dp[i][j] = s[i] == s[j] and dp[i + 1][j - 1]

                if dp[i][j] and j - i + 1 > len(result):
                    result = s[i: j + 1]
        return result

class Solution(object):
    def longestPalindrome(self, s):
        res = ""
        for i in xrange(len(s)):
            # odd case, like "aba"
            tmp = self.helper(s, i, i)
            if len(tmp) > len(res):
                res = tmp
            # even case, like "abba"
            tmp = self.helper(s, i, i+1)
            if len(tmp) > len(res):
                res = tmp
        return res

    # get the longest palindrome, l, r are the middle indexes   
    # from inner to outer
    def helper(self, s, l, r):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            l -= 1; r += 1
        return s[l+1:r]
```

### [44\. Wildcard Matching :rainbow:](https://leetcode.com/problems/wildcard-matching/)

Difficulty: **Hard**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Greedy](https://leetcode.com/tag/greedy/), [Recursion](https://leetcode.com/tag/recursion/)


Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:

*   `'?'` Matches any single character.
*   `'*'` Matches any sequence of characters (including the empty sequence).

The matching should cover the **entire** input string (not partial).

**Example 1:**

```
Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
```

**Example 2:**

```
Input: s = "aa", p = "*"
Output: true
Explanation: '*' matches any sequence.
```

**Example 3:**

```
Input: s = "cb", p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.
```

**Example 4:**

```
Input: s = "adceb", p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".
```

**Example 5:**

```
Input: s = "acdcb", p = "a*c?b"
Output: false
```

**Constraints:**

*   `0 <= s.length, p.length <= 2000`
*   `s` contains only lowercase English letters.
*   `p` contains only lowercase English letters, `'?'` or `'*'`.


#### Solution

Language: **Python**

```python
class Solution:
    def isMatch(self, s, p):
        dp = [[False for _ in range(len(p)+1)] for i in range(len(s)+1)]
        dp[0][0] = True
        for j in range(1, len(p)+1):
            if p[j-1] != '*':
                break
            dp[0][j] = True

        for i in range(1, len(s)+1):
            for j in range(1, len(p)+1):
                if p[j-1] in {s[i-1], '?'}:
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] == '*':
                    dp[i][j] = dp[i-1][j-1] or dp[i-1][j] or dp[i][j-1]
        return dp[-1][-1]
```

### [72\. Edit Distance :rainbow:](https://leetcode.com/problems/edit-distance/)

Difficulty: **Hard**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.

You have the following three operations permitted on a word:

*   Insert a character
*   Delete a character
*   Replace a character

**Example 1:**

```
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
```

**Example 2:**

```
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

**Constraints:**

*   `0 <= word1.length, word2.length <= 500`
*   `word1` and `word2` consist of lowercase English letters.


#### Solution

Language: **Python**

```python
def minDistance(word1, word2):
    L1, L2 = len(word1), len(word2)
    dp = [[0] * (L2 + 1) for _ in range(L1 + 1)]
    for i in range(L1 + 1):
        dp[i][0] = i
    for j in range(L2 + 1):
        dp[0][j] = j
    for i in range(1, L1 + 1):
        for j in range(1, L2 + 1):
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
    return dp[L1][L2]

minDistance(word1 = "horse", word2 = "ros")
minDistance(word1 = "abcbe", word2 = "abbbb")
```

### [70\. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)

Difficulty: **Easy**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Memoization](https://leetcode.com/tag/memoization/)


You are climbing a staircase. It takes `n` steps to reach the top.

Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

**Example 1:**

```
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1\. 1 step + 1 step
2\. 2 steps
```

**Example 2:**

```
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1\. 1 step + 1 step + 1 step
2\. 1 step + 2 steps
3\. 2 steps + 1 step
```

**Constraints:**

*   `1 <= n <= 45`


#### Solution

Language: **Python**

* [Python 3 || Solution: Comparison 3 approaches](https://leetcode.com/problems/climbing-stairs/discuss/1504370/Python-3-oror-Solution%3A-Comparison-3-approaches)
```python
# sol 1
def climbStairs(self, n):
    if n < 1: return 0
    prev, curr = 1, 2
    for _ in range(1, n):
        prev, curr = curr, prev + curr
    return prev

# sol2
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [1,1] + [0]*(n-1)
        for i in range(2, n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[-1]

# sol 3
class Solution:
    def climbStairs(self, n: int, mem={1:1,2:2,3:3}) -> int:
        if n in mem:
            return mem[n]
        mem[n] = self.climbStairs(n-1, mem) + self.climbStairs(n-2, mem)
        return mem[n]
```

### [746\. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


You are given an integer array `cost` where `cost[i]` is the cost of `i<sup>th</sup>` step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index `0`, or the step with index `1`.

Return _the minimum cost to reach the top of the floor_.

**Example 1:**

```
Input: cost = [10,15,20]
Output: 15
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.
```

**Example 2:**

```
Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
Explanation: You will start at index 0.
- Pay 1 and climb two steps to reach index 2.
- Pay 1 and climb two steps to reach index 4.
- Pay 1 and climb two steps to reach index 6.
- Pay 1 and climb one step to reach index 7.
- Pay 1 and climb two steps to reach index 9.
- Pay 1 and climb one step to reach the top.
The total cost is 6.
```

**Constraints:**

*   `2 <= cost.length <= 1000`
*   `0 <= cost[i] <= 999`


#### Solution

Language: **Python**

```python
class Solution(object):
    def minCostClimbingStairs(self, cost):
        """
        :type cost: List[int]
        :rtype: int
        """
        n = len(cost)
        dp = [0] * (n + 1)
        
        for i in range(2, n + 1):
            step1 = cost[i - 1] + dp[i - 1]
            step2 = cost[i - 2] + dp[i - 2]
            dp[i] = min(step1, step2)
        
        return dp[-1]

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        def minimum_cost(i):
            # Base case, we are allowed to start at either step 0 or step 1
            if i <= 1:
                return 0

            # Check if we have already calculated minimum_cost(i)
            if i in memo:
                return memo[i]

            # If not, cache the result in our hash map and return it
            down_one = cost[i - 1] + minimum_cost(i - 1)
            down_two = cost[i - 2] + minimum_cost(i - 2)
            memo[i] = min(down_one, down_two)
            return memo[i]

        memo = {}
        return minimum_cost(len(cost))
```

### [256\. Paint House](https://leetcode.com/problems/paint-house/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.

*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...

Return _the minimum cost to paint all houses_.

**Example 1:**

```
Input: costs = [[17,2,17],[16,16,5],[14,3,19]]
Output: 10
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.
Minimum cost: 2 + 5 + 3 = 10.
```

**Example 2:**

```
Input: costs = [[7,6,2]]
Output: 2
```

**Constraints:**

*   `costs.length == n`
*   `costs[i].length == 3`
*   `1 <= n <= 100`
*   `1 <= costs[i][j] <= 20`


#### Solution

Language: **Python**

```python
def minCost(costs):
    if not costs:
        return 0
    n = len(costs)
    for i in xrange(1, n):
        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])
    return min(costs[n - 1])

costs = [[17,2,17],[16,16,5],[14,3,19]]
minCost(costs)
```

### [265\. Paint House II](https://leetcode.com/problems/paint-house-ii/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


There are a row of `n` houses, each house can be painted with one of the `k` colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by an `n x k` cost matrix costs.

*   For example, `costs[0][0]` is the cost of painting house `0` with color `0`; `costs[1][2]` is the cost of painting house `1` with color `2`, and so on...

Return _the minimum cost to paint all houses_.

**Example 1:**

```
Input: costs = [[1,5,3],[2,9,4]]
Output: 5
Explanation:
Paint house 0 into color 0, paint house 1 into color 2\. Minimum cost: 1 + 4 = 5;
Or paint house 0 into color 2, paint house 1 into color 0\. Minimum cost: 3 + 2 = 5.
```

**Example 2:**

```
Input: costs = [[1,3],[2,4]]
Output: 5
```

**Constraints:**

*   `costs.length == n`
*   `costs[i].length == k`
*   `1 <= n <= 100`
*   `2 <= k <= 20`
*   `1 <= costs[i][j] <= 20`

**Follow up:** Could you solve it in `O(nk)` runtime?


#### Solution

Language: **Python**

```python
class Solution(object):
    def minCostII(self, costs):
        """
        :type costs: List[List[int]]
        :rtype: int
        """
        if not costs:
            return 0
        n = len(costs)
        k = len(costs[0])
        for i in range(1, n):
            for j in range(k):
                costs[i][j] += min([costs[i - 1][t] for t in range(k) if t != j])
        return min(costs[n - 1])


class Solution(object):
    def minCostII(self, costs):
        """
        :type costs: List[List[int]]
        :rtype: int
        """
        if not costs: return 0
        n, k = len(costs), len(costs[0])
        for i in xrange(1, n):
            min1 = min(costs[i-1])
            idx = costs[i-1].index(min1)
            min2 = min(costs[i-1][:idx] + costs[i-1][idx+1:])
            for j in xrange(k):
                if j == idx:
                    costs[i][j] += min2
                else:
                    costs[i][j] += min1
        return min(costs[-1])
```
### [516\. Longest Palindromic Subsequence :rainbow:](https://leetcode.com/problems/longest-palindromic-subsequence/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given a string `s`, find _the longest palindromic **subsequence**'s length in_ `s`.

A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

**Example 1:**

```
Input: s = "bbbab"
Output: 4
Explanation: One possible longest palindromic subsequence is "bbbb".
```

**Example 2:**

```
Input: s = "cbbd"
Output: 2
Explanation: One possible longest palindromic subsequence is "bb".
```

**Constraints:**

*   `1 <= s.length <= 1000`
*   `s` consists only of lowercase English letters.


#### Solution

Language: **Python**

* [](https://mp.weixin.qq.com/s/zNai1pzXHeB2tQE6AdOXTA)

```python
def longestPalindromeSubseq(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2 # a****a
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) # ab****b; a****ab;  i  j 

    return dp[0][n - 1]
longestPalindromeSubseq('bbbcb')
longestPalindromeSubseq('cbbd')
```

### [322\. Coin Change :fire:](https://leetcode.com/problems/coin-change/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/)


You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.

Return _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.

You may assume that you have an infinite number of each kind of coin.

**Example 1:**

```
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
```

**Example 2:**

```
Input: coins = [2], amount = 3
Output: -1
```

**Example 3:**

```
Input: coins = [1], amount = 0
Output: 0
```

**Example 4:**

```
Input: coins = [1], amount = 1
Output: 1
```

**Example 5:**

```
Input: coins = [1], amount = 2
Output: 2
```

**Constraints:**

*   `1 <= coins.length <= 12`
*   `1 <= coins[i] <= 2<sup>31</sup> - 1`
*   `0 <= amount <= 10<sup>4</sup>`


#### Solution

Language: **Python**

* [Python | DP & BFS (Beats 94%) | Simple Solutions](https://leetcode.com/problems/coin-change/discuss/1521067/Python-or-DP-and-BFS-(Beats-94)-or-Simple-Solutions)

```python
class Solution:
    def recur(self, coins, amount, lookup):
        if amount not in lookup:
            if amount == 0:
                return 0
            minCoins = sys.maxsize
            for coin in coins:
                if amount-coin >= 0:
                    minCoins = min(minCoins, 1 + self.recur(coins, amount-coin, lookup))
            lookup[amount] = minCoins
        return lookup[amount]

    def coinChange(self, coins: List[int], amount: int) -> int:
        minCoins = self.recur(coins, amount, {})
        return minCoins if minCoins != sys.maxsize else -1
```

### [518\. Coin Change 2 :fire:](https://leetcode.com/problems/coin-change-2/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.

Return _the number of combinations that make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `0`.

You may assume that you have an infinite number of each kind of coin.

The answer is **guaranteed** to fit into a signed **32-bit** integer.

**Example 1:**

```
Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**Example 2:**

```
Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
```

**Example 3:**

```
Input: amount = 10, coins = [10]
Output: 1
```

**Constraints:**

*   `1 <= coins.length <= 300`
*   `1 <= coins[i] <= 5000`
*   All the values of `coins` are **unique**.
*   `0 <= amount <= 5000`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/coin-change-2/discuss/675096/Python-O(amount-*-N)-simple-dp-explained-(updated))
* [](https://labuladong.gitee.io/algo/3/26/94/)

```python
def change(amount, coins):
    combination = [0] * (amount + 1)
    combination[0] = 1
    for coin in coins:
        for i in range(1, amount + 1):
            if coin <= i:
                combination[i] += combination[i - coin]
    return combination[amount]


if __name__ == '__main__':
    change(5, [1, 2, 5])

class Solution(object):
    def change(self, amount, coins):
        """
        :type amount: int
        :type coins: List[int]
        :rtype: int
        """
        def dfs(amount, idx):
            if (amount, idx) in memo:
                return memo[(amount, idx)]

            if amount == 0:
                return 1

            cnt = 0
            for i in range(idx, len(coins)):
                if amount - coins[i] >= 0:
                    cnt += dfs(amount - coins[i], i)

            memo[(amount, idx)] = cnt
            return cnt

        if not coins:
            if amount == 0:
                return 1
            return 0
        memo = {}
        coins.sort()
        return dfs(amount, 0)

class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        # MEMOIZATION
        # Time: O(n*m)
        # Memory: O(n*m)
        cache = {}      

        def dfs(i, a):
            if a == amount:
                return 1
            if a > amount:
                return 0
            if i == len(coins):
                return 0
            if (i, a) in cache:
                return cache[(i, a)]

            cache[(i, a)] = dfs(i, a + coins[i]) + dfs(i + 1, a)
            return cache[(i, a)]

        return dfs(0, 0)


        # DYNAMIC PROGRAMMING
        # Time: O(n*m)
        # Memory: O(n*m)
        dp = [[0] * (len(coins) + 1) for i in range(amount + 1)]
        dp[0] = [1] * (len(coins) + 1)
        for a in range(1, amount + 1):
            for i in range(len(coins) - 1, -1, -1):
                dp[a][i] = dp[a][i + 1]
                if a - coins[i] >= 0:
                    dp[a][i] += dp[a - coins[i]][i]
        return dp[amount][0]


        # DYNAMIC PROGRAMMING
        # Time: O(n*m)
        # Memory: O(n) where n = amount
        dp = [0] * (amount + 1)
        dp[0] = 1
        for i in range(len(coins) - 1, -1, -1):
            nextDP = [0] * (amount + 1)
            nextDP[0] = 1

            for a in range(1, amount + 1):
                nextDP[a] =  dp[a]
                if a - coins[i] >= 0:
                    nextDP[a] += nextDP[a - coins[i]]
            dp = nextDP
        return dp[amount]
```


### [377\. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given an array of **distinct** integers `nums` and a target integer `target`, return _the number of possible combinations that add up to_ `target`.

The answer is **guaranteed** to fit in a **32-bit** integer.

**Example 1:**

```
Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
```

**Example 2:**

```
Input: nums = [9], target = 3
Output: 0
```

**Constraints:**

*   `1 <= nums.length <= 200`
*   `1 <= nums[i] <= 1000`
*   All the elements of `nums` are **unique**.
*   `1 <= target <= 1000`

**Follow up:** What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?


#### Solution

Language: **Python**

```python
class Solution(object):
    # https://www.daimajiaoliu.com/daima/479d4993b100409
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        dp = [0] * (target + 1)
        dp[0] = 1
        for i in xrange(1, target + 1):
            for num in nums:
                if i >= num:
                    dp[i] += dp[i - num]
        return dp.pop()
```

### [718\. Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Sliding Window](https://leetcode.com/tag/sliding-window/), [Rolling Hash](https://leetcode.com/tag/rolling-hash/), [Hash Function](https://leetcode.com/tag/hash-function/)


Given two integer arrays `nums1` and `nums2`, return _the maximum length of a subarray that appears in **both** arrays_.

**Example 1:**

```
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].
```

**Example 2:**

```
Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5
```

**Constraints:**

*   `1 <= nums1.length, nums2.length <= 1000`
*   `0 <= nums1[i], nums2[i] <= 100`


#### Solution

Language: **Python**

```python
class Solution(object):
    def findLength(self, A, B):
        memo = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]
        for i in range(len(A) - 1, -1, -1):
            for j in range(len(B) - 1, -1, -1):
                if A[i] == B[j]:
                    memo[i][j] = memo[i + 1][j + 1] + 1
        return max(max(row) for row in memo)
```

### [1143\. Longest Common Subsequence :rainbow:](https://leetcode.com/problems/longest-common-subsequence/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given two strings `text1` and `text2`, return _the length of their longest **common subsequence**._ If there is no **common subsequence**, return `0`.

A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

*   For example, `"ace"` is a subsequence of `"abcde"`.

A **common subsequence** of two strings is a subsequence that is common to both strings.

**Example 1:**

```
Input: text1 = "abcde", text2 = "ace"
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
```

**Example 2:**

```
Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
```

**Example 3:**

```
Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
```

**Constraints:**

*   `1 <= text1.length, text2.length <= 1000`
*   `text1` and `text2` consist of only lowercase English characters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def longestCommonSubsequence(self, text1, text2):
        """
        :type text1: str
        :type text2: str
        :rtype: int
        """
        n1, n2 = len(text1), len(text2)
        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        for i in range(n1 - 1, -1, - 1):
            for j in range(n2 - 1, -1, - 1):
                if text1[i] == text2[j]:
                    dp[i][j] = dp[i + 1][j + 1] + 1
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])
        return dp[0][0]


class Solution(object):
    def longestCommonSubsequence(self, text1, text2):
        """
        :type text1: str
        :type text2: str
        :rtype: int
        """
        n1, n2 = len(text1), len(text2)
        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j -1])
        return dp[n1][n2]
```

### [983\. Minimum Cost For Tickets :rainbow:](https://leetcode.com/problems/minimum-cost-for-tickets/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array `days`. Each day is an integer from `1` to `365`.

Train tickets are sold in **three different ways**:

*   a **1-day** pass is sold for `costs[0]` dollars,
*   a **7-day** pass is sold for `costs[1]` dollars, and
*   a **30-day** pass is sold for `costs[2]` dollars.

The passes allow that many days of consecutive travel.

*   For example, if we get a **7-day** pass on day `2`, then we can travel for `7` days: `2`, `3`, `4`, `5`, `6`, `7`, and `8`.

Return _the minimum number of dollars you need to travel every day in the given list of days_.

**Example 1:**

```
Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total, you spent $11 and covered all the days of your travel.
```

**Example 2:**

```
Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
Output: 17
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total, you spent $17 and covered all the days of your travel.
```

**Constraints:**

*   `1 <= days.length <= 365`
*   `1 <= days[i] <= 365`
*   `days` is in strictly increasing order.
*   `costs.length == 3`
*   `1 <= costs[i] <= 1000`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/minimum-cost-for-tickets/discuss/810749/Python-by-DP-w-Visualization)

```python
# Implementation by Bottom-up DP with iteration (i.e., tabulation method)

class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:

        # index of ticket
        _1day_pass, _7day_pass, _30day_pass = 0, 1, 2

        # set of travel days
        travel_days = set(days)

        # last travel day
        last_traverl_day = days[-1]

        # DP Table, record for minimum cost of ticket to travel
        dp_cost = [  0 for _ in range(last_traverl_day+1)]


        # Solve min cost by Dynamic Programming
        for day_i in range(1, last_traverl_day+1):


            if day_i not in travel_days:

                # today is not traveling day
                # no extra cost
                dp_cost[day_i] = dp_cost[day_i - 1]


            else:

                # today is traveling day
                # compute optimal cost by DP

                dp_cost[day_i] = min(   dp_cost[ day_i - 1 ]  + costs[ _1day_pass ],
                                        dp_cost[ max(day_i - 7, 0) ]  + costs[ _7day_pass ],
                                        dp_cost[ max(day_i - 30, 0) ] + costs[ _30day_pass ]     )


        # Cost on last travel day of this year is the answer
        return dp_cost[last_traverl_day]

# Implementaion by Top-down DP with recursion + memoization

class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:

        # to speed up element checking for days
        travel_days = set(days)

        # ---------------------------------------------------

        # use python built-in cache as memoization for DP
        @cache
        def dp(day_d):

            ## Base case
            if day_d == 0:

                # no cost on before traveling
                return 0

            ## General cases
            if day_d not in travel_days:

                # no extra cost on non-traverl day
                return dp(day_d-1)

            else:

                # compute minimal cost on travel day

                with_1_day_pass = dp( day_d-1 ) + costs[0]
                with_7_day_pass = dp( max( day_d - 7, 0) ) + costs[1]
                with_30_day_pass = dp( max( day_d - 30, 0) ) + costs[2]

                return min( with_1_day_pass, with_7_day_pass, with_30_day_pass)

        # ---------------------------------------------------
        last_travel_day = days[-1]

        return dp(last_travel_day)
```

### [213\. House Robber II](https://leetcode.com/problems/house-robber-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.

**Example 1:**

```
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
```

**Example 2:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 3:**

```
Input: nums = [1,2,3]
Output: 3
```

**Constraints:**

*   `1 <= nums.length <= 100`
*   `0 <= nums[i] <= 1000`


#### Solution

Language: **Python**

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        def helper(nums: List[int]) -> int:
            n = len(nums)
            if n == 1:
                return nums[0]
            dp = [0] * n
            dp[0] = nums[0]
            dp[1] = max(nums[1], nums[0])
            for i in range(2, n):
                dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
            return dp[-1]
        return max(helper(nums[1: ]), helper(nums[:-1]))
```

### [96\. Unique Binary Search Trees :fire:](https://leetcode.com/problems/unique-binary-search-trees/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Tree](https://leetcode.com/tag/tree/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given an integer `n`, return _the number of structurally unique **BST'**s (binary search trees) which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
Input: n = 3
Output: 5
```

**Example 2:**

```
Input: n = 1
Output: 1
```

**Constraints:**

*   `1 <= n <= 19`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/unique-binary-search-trees/discuss/703644/PythonEasy-DP-Solution-Explained-By-Someone-Who-Used-To-Struggle-To-Understand-DP)

```python
class Solution:
    def numTrees(self, n: int) -> int:
        self.table = [-1] * (n+1)
        self.table[0] = 1
        return self.numTreesRec(n)

    def numTreesRec(self, n):
        if self.table[n] != -1:
            return self.table[n]
        total = 0
        for m in range(n):
            total += (self.numTreesRec(n-1-m) * self.numTreesRec(m))
        self.table[n] = total
        return total
```

### [740\. Delete and Earn](https://leetcode.com/problems/delete-and-earn/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:

*   Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.

Return _the **maximum number of points** you can earn by applying the above operation some number of times_.

**Example 1:**

```
Input: nums = [3,4,2]
Output: 6
Explanation: You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.
```

**Example 2:**

```
Input: nums = [2,2,3,3,3,4]
Output: 9
Explanation: You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.
```

**Constraints:**

*   `1 <= nums.length <= 2 * 10<sup>4</sup>`
*   `1 <= nums[i] <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def deleteAndEarn(self, nums):
        count = collections.Counter(nums)
        prev = None
        avoid = using = 0
        for num in sorted(count):
            if num - 1 != prev:
                avoid, using = max(avoid, using), num * count[num] + max(avoid, using)
            else:
                avoid, using = max(avoid, using), num * count[num] + avoid
            prev = num
        return max(avoid, using)
```

### [343\. Integer Break](https://leetcode.com/problems/integer-break/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given an integer `n`, break it into the sum of `k` **positive integers**, where `k >= 2`, and maximize the product of those integers.

Return _the maximum product you can get_.

**Example 1:**

```
Input: n = 2
Output: 1
Explanation: 2 = 1 + 1, 1  1 = 1.
```

**Example 2:**

```
Input: n = 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3  3  4 = 36.
```

**Constraints:**

*   `2 <= n <= 58`


#### Solution

Language: **Python**

```python
class Solution(object):
    def integerBreak(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = {1: 1}

        def dfs(num):
            if num in dp:
                return dp[num]

            dp[num] = 0 if num == n else num
            for i in range(1, num):
                val = dfs(i) * dfs(num - i)
                dp[num] = max(dp[num], val)
            return dp[num]

        return dfs(n)
```

### [673\. Number of Longest Increasing Subsequence :fire:](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Binary Indexed Tree](https://leetcode.com/tag/binary-indexed-tree/), [Segment Tree](https://leetcode.com/tag/segment-tree/)


Given an integer array `nums`, return _the number of longest increasing subsequences._

**Notice** that the sequence has to be **strictly** increasing.

**Example 1:**

```
Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
```

**Example 2:**

```
Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.

```

**Constraints:**

*   `1 <= nums.length <= 2000`
*   `-10<sup>6</sup> <= nums[i] <= 10<sup>6</sup>`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/835323/Python-3-or-DP-or-Explanation)
```python
class Solution(object):
    def findNumberOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums: return 0
        n = len(nums)
        m, dp, cnt = 0, [1] * n, [1] * n
        for i in range(n):
            for j in range(i):
                if nums[j] < nums[i]:
                    if dp[i] < dp[j]+1: dp[i], cnt[i] = dp[j]+1, cnt[j]
                    elif dp[i] == dp[j]+1: cnt[i] += cnt[j]
            m = max(m, dp[i])                        
        return sum(c for l, c in zip(dp, cnt) if l == m)
```

### [97\. Interleaving String :rainbow:](https://leetcode.com/problems/interleaving-string/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an **interleaving** of `s1` and `s2`.

An **interleaving** of two strings `s` and `t` is a configuration where they are divided into **non-empty** substrings such that:

*   `s = s<sub style="display: inline;">1</sub> + s<sub style="display: inline;">2</sub> + ... + s<sub style="display: inline;">n</sub>`
*   `t = t<sub style="display: inline;">1</sub> + t<sub style="display: inline;">2</sub> + ... + t<sub style="display: inline;">m</sub>`
*   `|n - m| <= 1`
*   The **interleaving** is `s<sub style="display: inline;">1</sub> + t<sub style="display: inline;">1</sub> + s<sub style="display: inline;">2</sub> + t<sub style="display: inline;">2</sub> + s<sub style="display: inline;">3</sub> + t<sub style="display: inline;">3</sub> + ...` or `t<sub style="display: inline;">1</sub> + s<sub style="display: inline;">1</sub> + t<sub style="display: inline;">2</sub> + s<sub style="display: inline;">2</sub> + t<sub style="display: inline;">3</sub> + s<sub style="display: inline;">3</sub> + ...`

**Note:** `a + b` is the concatenation of strings `a` and `b`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

```
Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true
```

**Example 2:**

```
Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
Output: false
```

**Example 3:**

```
Input: s1 = "", s2 = "", s3 = ""
Output: true
```

**Constraints:**

*   `0 <= s1.length, s2.length <= 100`
*   `0 <= s3.length <= 200`
*   `s1`, `s2`, and `s3` consist of lowercase English letters.

**Follow up:** Could you solve it using only `O(s2.length)` additional memory space?


#### Solution

Language: **Python**

```python
class Solution(object):
    def isInterleave(self, s1, s2, s3):
        """
        :type s1: str
        :type s2: str
        :type s3: str
        :rtype: bool
        """
        if len(s1) + len(s2) != len(s3):
            return False
        
        dp = [ [False] * (len(s2) + 1) for i in range(len(s1) + 1)]
        dp[len(s1)][len(s2)] = True
        
        for i in range(len(s1), -1, -1):
            for j in range(len(s2), -1, -1):
                if i < len(s1) and s1[i] == s3[i + j] and dp[i + 1][j]:
                    dp[i][j] = True
                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:
                    dp[i][j] = True
        return dp[0][0]

class Solution(object):
    def isInterleave(self, s1, s2, s3):
        """
        :type s1: str
        :type s2: str
        :type s3: str
        :rtype: bool
        """
        dp = {}
        # k = i + j
        def dfs(i, j):
            if i == len(s1) and j == len(s2):
                return True
            if (i, j) in dp:
                return dp[(i, j)]

            if i < len(s1) and s1[i] == s3[i + j] and dfs(i + 1, j):
                return True
            if j < len(s2) and s2[j] == s3[i + j] and dfs(i, j + 1):
                return True

            dp[(i, j)] = False
            return dp[(i, j)]

        return dfs(0, 0)
```

### [115\. Distinct Subsequences :rainbow:](https://leetcode.com/problems/distinct-subsequences/)

Difficulty: **Hard**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given two strings `s` and `t`, return _the number of distinct subsequences of `s` which equals `t`_.

A string's **subsequence** is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters' relative positions. (i.e., `"ACE"` is a subsequence of `"ABCDE"` while `"AEC"` is not).

The test cases are generated so that the answer fits on a 32-bit signed integer.

**Example 1:**

```
Input: s = "rabbbit", t = "rabbit"
Output: 3
Explanation:
As shown below, there are 3 ways you can generate "rabbit" from S.
rabbbit
rabbbit
rabbbit
```

**Example 2:**

```
Input: s = "babgbag", t = "bag"
Output: 5
Explanation:
As shown below, there are 5 ways you can generate "bag" from S.
babgbag
babgbag
babgbag
babgbag
babgbag
```

**Constraints:**

*   `1 <= s.length, t.length <= 1000`
*   `s` and `t` consist of English letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def numDistinct(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: int
        """
        def dfs(i, j):
            if j == n:
                return 1
            if i == m:
                return 0
            if (i, j) in memo:
                return memo[(i, j)]
            
            count = 0
            if i < m and j < n and s[i] == t[j]:
                count += dfs(i + 1, j + 1)
            count += dfs(i + 1, j)
            
            memo[(i, j)] = count
            return count
            
            
        m, n = len(s), len(t)
        memo = {}
        return dfs(0, 0)
                
```

### [312\. Burst Balloons :fire:](https://leetcode.com/problems/burst-balloons/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.

If you burst the `i<sup>th</sup>` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.

Return _the maximum coins you can collect by bursting the balloons wisely_.

**Example 1:**

```
Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
```

**Example 2:**

```
Input: nums = [1,5]
Output: 10
```

**Constraints:**

*   `n == nums.length`
*   `1 <= n <= 300`
*   `0 <= nums[i] <= 100`


#### Solution

Language: **Python**

```python
class Solution(object):
    def maxCoins(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = [1] + nums + [1]
        dp = {}
        
        def dfs(l, r):
            if l > r:
                return 0
            if (l,  r) in dp:
                return dp[(l,  r)]
            
            dp[(l,  r)] = 0
            for i in range(l,  r + 1):
                coins = nums[l - 1] * nums[i] * nums[r + 1]
                coins += dfs(l, i - 1) + dfs(i + 1, r)
                dp[(l,  r)] = max(dp[(l,  r)], coins)
            
            return dp[(l,  r)]
        
        return dfs(1, len(nums) - 2)
```

### [894\. All Possible Full Binary Trees :rainbow:](https://leetcode.com/problems/all-possible-full-binary-trees/)

Difficulty: **Medium**  

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Tree](https://leetcode.com/tag/tree/), [Recursion](https://leetcode.com/tag/recursion/), [Memoization](https://leetcode.com/tag/memoization/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given an integer `n`, return _a list of all possible **full binary trees** with_ `n` _nodes_. Each node of each tree in the answer must have `Node.val == 0`.

Each element of the answer is the root node of one possible tree. You may return the final list of trees in **any order**.

A **full binary tree** is a binary tree where each node has exactly `0` or `2` children.

**Example 1:**

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png)

```
Input: n = 7
Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
```

**Example 2:**

```
Input: n = 3
Output: [[0,0,0]]
```

**Constraints:**

*   `1 <= n <= 20`


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def allPossibleFBT(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """
        dp = {}
        
        def backtrack(n):
            if n == 0:
                return []
            if n == 1:
                return [TreeNode()]
            if n in dp:
                return dp[n]
            
            res = []
            for l in range(n):
                r = n - 1 - l
                leftTree, rightTree = backtrack(l), backtrack(r)
                for t1 in leftTree:
                    for t2 in rightTree:
                        res.append(TreeNode(0, t1, t2))
            dp[n] = res
            return res
        
        return backtrack(n)
```

### [935\. Knight Dialer :fire:](https://leetcode.com/problems/knight-dialer/)

Difficulty: **Medium**  

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


The chess knight has a **unique movement**, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an **L**). The possible movements of chess knight are shown in this diagaram:

A chess knight can move as indicated in the chess diagram below:

![](https://assets.leetcode.com/uploads/2020/08/18/chess.jpg)

We have a chess knight and a phone pad as shown below, the knight **can only stand on a numeric cell** (i.e. blue cell).

![](https://assets.leetcode.com/uploads/2020/08/18/phone.jpg)

Given an integer `n`, return how many distinct phone numbers of length `n` we can dial.

You are allowed to place the knight **on any numeric cell** initially and then you should perform `n - 1` jumps to dial a number of length `n`. All jumps should be **valid** knight jumps.

As the answer may be very large, **return the answer modulo** `10<sup>9</sup> + 7`.

**Example 1:**

```
Input: n = 1
Output: 10
Explanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.
```

**Example 2:**

```
Input: n = 2
Output: 20
Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]
```

**Example 3:**

```
Input: n = 3131
Output: 136006598
Explanation: Please take care of the mod.
```

**Constraints:**

*   `1 <= n <= 5000`


#### Solution

Language: **Python**

```python
class Solution(object):
    def knightDialer(self, n):
        """
        :type n: int
        :rtype: int
        """
        lookup = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        def helper(curr, left):
            if left == 1: return 1
            if (curr, left) in memo: return memo[(curr, left)]

            res = 0
            for next in lookup[curr]:
                res += helper(next, left-1)

            memo[(curr, left)] = res
            return res

        # setup and recursive call
        memo = {}
        res = 0
        for i in range(10):
            res += helper(i, n)
        return res % (10**9 + 7)
```

## Divide and Conquer
### [282\. Expression Add Operators](https://leetcode.com/problems/expression-add-operators/)

Difficulty: **Hard**  

Related Topics: [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/), [Backtracking](https://leetcode.com/tag/backtracking/)


Given a string `num` that contains only digits and an integer `target`, return _**all possibilities** to insert the binary operators_ `'+'`_,_ `'-'`_, and/or_ `'*'` _between the digits of_ `num` _so that the resultant expression evaluates to the_ `target` _value_.

Note that operands in the returned expressions **should not** contain leading zeros.

**Example 1:**

```
Input: num = "123", target = 6
Output: ["1*2*3","1+2+3"]
Explanation: Both "1*2*3" and "1+2+3" evaluate to 6.
```

**Example 2:**

```
Input: num = "232", target = 8
Output: ["2*3+2","2+3*2"]
Explanation: Both "2*3+2" and "2+3*2" evaluate to 8.
```

**Example 3:**

```
Input: num = "105", target = 5
Output: ["1*0+5","10-5"]
Explanation: Both "1*0+5" and "10-5" evaluate to 5.
Note that "1-05" is not a valid expression because the 5 has a leading zero.
```

**Example 4:**

```
Input: num = "00", target = 0
Output: ["0*0","0+0","0-0"]
Explanation: "0*0", "0+0", and "0-0" all evaluate to 0.
Note that "00" is not a valid expression because the 0 has a leading zero.
```

**Example 5:**

```
Input: num = "3456237490", target = 9191
Output: []
Explanation: There are no expressions that can be created from "3456237490" to evaluate to 9191.
```

**Constraints:**

*   `1 <= num.length <= 10`
*   `num` consists of only digits.
*   `-2<sup>31</sup> <= target <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/expression-add-operators/discuss/71968/Clean-Python-DFS-with-comments)

```python
def addOperators(num, target):
    def dfs(remain, cur_str, cur, prev):
        if not remain and cur == target:
            res.append(cur_str)

        for i in range(1, len(remain) + 1):
            if i > 1 and remain[0] == '0': # avoid '0X' number case be counted
                return
            cur_num = remain[:i]    
            if len(cur_str) == 0:   # avoid generate str begin with +-*
                dfs(remain[i:], cur_num, int(cur_num), int(cur_num))
            else:

                dfs(remain[i:], cur_str + '+' + cur_num, cur + int(cur_num), int(cur_num))
                dfs(remain[i:], cur_str + '-' + cur_num, cur - int(cur_num), -int(cur_num))
                # need take extra care for '*' case, a+b*c = a+b-b+b*c
                dfs(remain[i:], cur_str+'*'+cur_num, cur-prev + prev*int(cur_num), prev*int(cur_num))

    res = []
    dfs(num, '', 0, 0)
    return res

addOperators(num = "232", target = 8)
```

### [4\. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/)


Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

**Example 1:**

```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
```

**Example 2:**

```
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
```

**Example 3:**

```
Input: nums1 = [0,0], nums2 = [0,0]
Output: 0.00000
```

**Example 4:**

```
Input: nums1 = [], nums2 = [1]
Output: 1.00000
```

**Example 5:**

```
Input: nums1 = [2], nums2 = []
Output: 2.00000
```

**Constraints:**

*   `nums1.length == m`
*   `nums2.length == n`
*   `0 <= m <= 1000`
*   `0 <= n <= 1000`
*   `1 <= m + n <= 2000`
*   `-10<sup>6</sup> <= nums1[i], nums2[i] <= 10<sup>6</sup>`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/1100698/Python3-Binary-Search-from-Tushar-Roy's-solution-video)
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if len(nums1) > len(nums2):
            return self.findMedianSortedArrays(nums2, nums1)

        l1, l2 = len(nums1), len(nums2)
        left, right = 0, l1
        while left <= right:
            position_x = (left + right) // 2
            position_y = (l1 + l2 + 1) // 2 - position_x

            max_left_x = nums1[position_x - 1] if position_x != 0 else float('-inf')
            max_left_y = nums2[position_y - 1] if position_y != 0 else float('-inf')

            min_right_x = nums1[position_x] if position_x < l1 else float('inf')
            min_right_y = nums2[position_y] if position_y < l2 else float('inf')

            if (max_left_x <= min_right_y and max_left_y <= min_right_x):
                # we found the partition
                if (l1 + l2) % 2 == 0:
                    return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2
                else:
                    return max(max_left_x, max_left_y)

            elif max_left_x > min_right_y:
                # we should move left
                right = position_x - 1

            else:
                left = position_x + 1

        return 0
```

## Recursion
### [247\. Strobogrammatic Number II](https://leetcode.com/problems/strobogrammatic-number-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/), [Recursion](https://leetcode.com/tag/recursion/)


Given an integer `n`, return all the **strobogrammatic numbers** that are of length `n`. You may return the answer in **any order**.

A **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).

**Example 1:**

```
Input: n = 2
Output: ["11","69","88","96"]
```

**Example 2:**

```
Input: n = 1
Output: ["0","1","8"]
```

**Constraints:**

*   `1 <= n <= 14`


#### Solution

Language: **Python**

```python
# not ac
def isStrobogrammatic(num):
    i, j = 0, len(num) - 1
    while i <= j:
        if num[i] not in mapping or num[j] not in mapping or not mapping[num[i]] == num[j]:
            return False
        else:
            i += 1
            j -= 1
    return True

def findStrobogrammatic(n):
    if n == 0:
        return []
    mapping = {'1': '1', '8': '8', '0': '0', '6': '9', '9': '6'}
    result = []
    dfs(n, '', result)
    return result

def dfs(n, cur, result):
    if len(cur) > n:
        return
    elif len(cur) == n:
        if isStrobogrammatic(cur) and 10 ** (n - 1) < int(cur) < 10 ** n:
            result.append(cur)
            return
    else:
        for s in mapping.keys():
            dfs(n, cur + s, result)

findStrobogrammatic(3)    
```

### [341\. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/)

Difficulty: **Medium**  

Related Topics: [Stack](https://leetcode.com/tag/stack/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Design](https://leetcode.com/tag/design/), [Queue](https://leetcode.com/tag/queue/), [Iterator](https://leetcode.com/tag/iterator/)


You are given a nested list of integers `nestedList`. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.

Implement the `NestedIterator` class:

*   `NestedIterator(List<NestedInteger> nestedList)` Initializes the iterator with the nested list `nestedList`.
*   `int next()` Returns the next integer in the nested list.
*   `boolean hasNext()` Returns `true` if there are still some integers in the nested list and `false` otherwise.

Your code will be tested with the following pseudocode:

```
initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
```

If `res` matches the expected flattened list, then your code will be judged as correct.

**Example 1:**

```
Input: nestedList = [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].
```

**Example 2:**

```
Input: nestedList = [1,[4,[6]]]
Output: [1,4,6]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].
```

**Constraints:**

*   `1 <= nestedList.length <= 500`
*   The values of the integers in the nested list is in the range `[-10<sup>6</sup>, 10<sup>6</sup>]`.


#### Solution

Language: **Python**

```python
from collections import deque

class NestedIterator():
    def __init__(self, nestedList):
        self.queue = deque(self.flatten(nestedList))

    def flatten(self, lis):
        new_lis = []
        for item in lis:
            if type(item) == type([]):
                new_lis.extend(self.flatten(item))
            else:
                new_lis.append(item)
        return new_lis

    def next(self):
        return self.queue.popleft()

    def hasNext(self):
        return len(self.queue) > 0

# Your NestedIterator object will be instantiated and called as such:
i, v = NestedIterator(nestedList = [1,[4,[6]]]), []
while i.hasNext(): v.append(i.next())
```

```python
# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger(object):
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """

class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        def flatten_list(nested_list):
            for nested_integer in nested_list:
                if nested_integer.isInteger():
                    self._integers.append(nested_integer.getInteger())
                else:
                    flatten_list(nested_integer.getList())
        self._integers = []
        self._position = -1 # Pointer to previous returned.
        flatten_list(nestedList)

    def next(self) -> int:
        self._position += 1
        return self._integers[self._position]

    def hasNext(self) -> bool:
        return self._position + 1 < len(self._integers)
```

### [50\. Pow(x, n)](https://leetcode.com/problems/powx-n/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Recursion](https://leetcode.com/tag/recursion/)


Implement , which calculates `x` raised to the power `n` (i.e., `x<sup>n</sup>`).

**Example 1:**

```
Input: x = 2.00000, n = 10
Output: 1024.00000
```

**Example 2:**

```
Input: x = 2.10000, n = 3
Output: 9.26100
```

**Example 3:**

```
Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
```

**Constraints:**

*   `-100.0 < x < 100.0`
*   `-2<sup>31</sup> <= n <= 2<sup>31</sup>-1`
*   `-10<sup>4</sup> <= x<sup>n</sup> <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
def pow(x, n):
    if n == 0:
        return 1
    elif n == 1:
        return x
    elif n < 0:
        return 1 / pow(x, -n)
    else:
        division, carry  = divmod(n, 2)
        half = pow(x, division)
        return half * half if carry == 0 else half * half * x

pow(x = 2.00000, n = 10)
pow(x = 2.10000, n = 3)
pow(x = 2.00000, n = -2)
```

### [486\. Predict the Winner :rainbow:](https://leetcode.com/problems/predict-the-winner/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Math](https://leetcode.com/tag/math/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Recursion](https://leetcode.com/tag/recursion/), [Game Theory](https://leetcode.com/tag/game-theory/)


You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.

Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of `0`. At each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) which reduces the size of the array by `1`. The player adds the chosen number to their score. The game ends when there are no more elements in the array.

Return `true` if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return `true`. You may assume that both players are playing optimally.

**Example 1:**

```
Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2\.
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5\. If player 2 chooses 5, then player 1 will be left with 1 (or 2).
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5\.
Hence, player 1 will never be the winner and you need to return false.
```

**Example 2:**

```
Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1\. Then player 2 has to choose between 5 and 7\. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
```

**Constraints:**

*   `1 <= nums.length <= 20`
*   `0 <= nums[i] <= 10<sup>7</sup>`


#### Solution

Language: **Python**

```python
# Complexity, Time: O(2^n), Space: O(n)
# Complexity, Time: O(n^2), Space: O(n^2) with memo; The entire memomemo array of size nnxnn is filled only once. Here, nn refers to the size of numsnums array.

def PredictTheWinner(nums):

    def helper(i, j):
        if i >  j:
            return 0

        if (i, j) in memo:
            return memo[(i, j)]

        score = max(nums[j] - helper(i, j-1), nums[i] - helper(i+1, j))
        memo[(i, j)] = score

        return score

    memo = {}      

    return helper(0, len(nums)-1) >=0

PredictTheWinner(nums = [1,5,2])
```

### [18\. 4Sum :fire:](https://leetcode.com/problems/4sum/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Sorting](https://leetcode.com/tag/sorting/)


Given an array `nums` of `n` integers, return _an array of all the **unique** quadruplets_ `[nums[a], nums[b], nums[c], nums[d]]` such that:

*   `0 <= a, b, c, d < n`
*   `a`, `b`, `c`, and `d` are **distinct**.
*   `nums[a] + nums[b] + nums[c] + nums[d] == target`

You may return the answer in **any order**.

**Example 1:**

```
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**Example 2:**

```
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
```

**Constraints:**

*   `1 <= nums.length <= 200`
*   `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`
*   `-10<sup>9</sup> <= target <= 10<sup>9</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        nums.sort()
        res = []

        def k_sum(nums, k, target, arr, start_idx):
            if k == 2:
                two_sum(nums, arr, k, start_idx, target)
                return
            for i in range(start_idx, len(nums) - k + 1):
                if i > start_idx and nums[i] == nums[i - 1]:
                    continue
                k_sum(nums, k - 1, target - nums[i], arr + [nums[i]], i + 1)

        def two_sum(nums, arr, k, start_idx, target):
            left = start_idx
            right = len(nums) - 1

            while left < right:
                total = nums[left] + nums[right]
                if total == target:
                    res.append(arr + [nums[left], nums[right]])
                    left += 1
                    right -= 1

                    while left < right and nums[left] == nums[left - 1]:
                        left += 1  # skip same element to avoid duplicate quadruplets
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1  # skip same element to avoid duplicate quadruplets
                elif total < target:
                    left += 1
                else:
                    right -= 1

        k_sum(nums, 4, target, [], 0)
        return res
```

## Memoization
### [494\. Target Sum :rainbow:](https://leetcode.com/problems/target-sum/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Backtracking](https://leetcode.com/tag/backtracking/)


You are given an integer array `nums` and an integer `target`.

You want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.

*   For example, if `nums = [2, 1]`, you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `"+2-1"`.

Return the number of different **expressions** that you can build, which evaluates to `target`.

**Example 1:**

```
Input: nums = [1,1,1,1,1], target = 3
Output: 5
Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**Example 2:**

```
Input: nums = [1], target = 1
Output: 1
```

**Constraints:**

*   `1 <= nums.length <= 20`
*   `0 <= nums[i] <= 1000`
*   `0 <= sum(nums[i]) <= 1000`
*   `-1000 <= target <= 1000`


#### Solution

Language: **Python**

```python
class Solution(object):
    def findTargetSumWays(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        dp = {} # (index, total) -> # of ways

        def backtrack(i, total):
            if i == len(nums):
                return 1 if total == target else 0
            if (i, total) in dp:
                return dp[(i, total)]

            dp[(i, total)] = (backtrack(i + 1, total + nums[i]) +
                              backtrack(i + 1, total - nums[i]))  
            return dp[(i, total)]
        return backtrack(0, 0)
```

### [464\. Can I Win](https://leetcode.com/problems/can-i-win/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/), [Memoization](https://leetcode.com/tag/memoization/), [Game Theory](https://leetcode.com/tag/game-theory/), [Bitmask](https://leetcode.com/tag/bitmask/)


In the "100 game" two players take turns adding, to a running total, any integer from `1` to `10`. The player who first causes the running total to **reach or exceed** 100 wins.

What if we change the game so that players **cannot** re-use integers?

For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.

Given two integers `maxChoosableInteger` and `desiredTotal`, return `true` if the first player to move can force a win, otherwise, return `false`. Assume both players play **optimally**.

**Example 1:**

```
Input: maxChoosableInteger = 10, desiredTotal = 11
Output: false
Explanation:
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.
```

**Example 2:**

```
Input: maxChoosableInteger = 10, desiredTotal = 0
Output: true
```

**Example 3:**

```
Input: maxChoosableInteger = 10, desiredTotal = 1
Output: true
```

**Constraints:**

*   `1 <= maxChoosableInteger <= 20`
*   `0 <= desiredTotal <= 300`


#### Solution

Language: **Python**

* Complexity, Time: `O(n!)`
* Complexity, Time: `O(n * 2^n)` with `seen_key`

```python
def canIWin(maxChoosableInteger, desiredTotal):

    def can_win(choices, remainder):
        # if the largest choice exceeds the remainder, then we can win!
        if choices[-1] >= remainder:
            return True

        # if we have seen this exact scenario play out, then we know the outcome
        seen_key = tuple(choices)
        if seen_key in seen:
            return seen[seen_key]

        # we haven't won yet.. it's the next player's turn.
        for index in range(len(choices)):
            if not can_win(choices[:index] + choices[index + 1:], remainder - choices[index]):
                seen[seen_key] = True
                return True

        # uh-oh if we got here then next player won all permutations, we can't force their hand
        # actually, they were able to force our hand :(
        seen[seen_key] = False
        return False

    seen = {}

    # let's do some quick checks before we journey through the tree of permutations
    summed_choices = (maxChoosableInteger + 1) * maxChoosableInteger / 2

    # if all the choices added up are less then the total, no-one can win
    if summed_choices < desiredTotal:
        return False

    # if the sum matches desiredTotal exactly then you win if there's an odd number of turns
    if summed_choices == desiredTotal:
	    return maxChoosableInteger % 2

    # slow: time to go through the tree of permutations
    choices = list(range(1, maxChoosableInteger + 1))

    return can_win(choices, desiredTotal)


maxChoosableInteger = 3; desiredTotal = 4
```

### [688\. Knight Probability in Chessboard](https://leetcode.com/problems/knight-probability-in-chessboard/)

Difficulty: **Medium**  

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


On an `n x n` chessboard, a knight starts at the cell `(row, column)` and attempts to make exactly `k` moves. The rows and columns are **0-indexed**, so the top-left cell is `(0, 0)`, and the bottom-right cell is `(n - 1, n - 1)`.

A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.

![](https://assets.leetcode.com/uploads/2018/10/12/knight.png)

Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.

The knight continues moving until it has made exactly `k` moves or has moved off the chessboard.

Return _the probability that the knight remains on the board after it has stopped moving_.

**Example 1:**

```
Input: n = 3, k = 2, row = 0, column = 0
Output: 0.06250
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.
```

**Example 2:**

```
Input: n = 1, k = 0, row = 0, column = 0
Output: 1.00000
```

**Constraints:**

*   `1 <= n <= 25`
*   `0 <= k <= 100`
*   `0 <= row, column <= n`


#### Solution

Language: **Python**

```python
class Solution(object):
    def knightProbability(self, N, K, r, c):
        """
        :type N: int
        :type K: int
        :type r: int
        :type c: int
        :rtype: float
        """
        # O(K*n^2) worst case, keep adding the probability of getting out of the board.
        moves = [(1,2),(-1,2),(1,-2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]
        memo, out_board_p = {(r, c): 1}, 0
        # for each step we will create a new dict to record the onboard coordinates and their probabilities.
        for step in range(K):
            next_memo = collections.defaultdict(int)
            for (i, j), prob in memo.items():
                for d in moves:
                    di, dj = i+d[0], j+d[1]
                    # if the next step is on the board, we record it for next step's calculation
                    if 0<=di<N and 0<=dj<N:
                        next_memo[(di,dj)] += prob * 0.125
                    # if the next step is not on the board, we sum it to our accumulate probability of out-board.
                    else:
                        out_board_p += prob * 0.125
            memo = next_memo
        # the on-board prob = 1 - the accumulate out board prob
        return 1-out_board_p
```

### [329\. Longest Increasing Path in a Matrix :rainbow:](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/)

Difficulty: **Hard**  

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Graph](https://leetcode.com/tag/graph/), [Topological Sort](https://leetcode.com/tag/topological-sort/), [Memoization](https://leetcode.com/tag/memoization/)


Given an `m x n` integers `matrix`, return _the length of the longest increasing path in_ `matrix`.

From each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)

```
Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg)

```
Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
```

**Example 3:**

```
Input: matrix = [[1]]
Output: 1
```

**Constraints:**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= m, n <= 200`
*   `0 <= matrix[i][j] <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

```python
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        DIR = [0, 1, 0, -1, 0]
        m, n = len(matrix), len(matrix[0])

        @lru_cache(None)
        def dfs(r, c):
            ans = 1
            for i in range(4):
                nr, nc = r + DIR[i], c + DIR[i+1]
                if nr < 0 or nr == m or nc < 0 or nc == n or matrix[nr][nc] <= matrix[r][c]: continue  # Out of bound or not greater
                ans = max(ans, dfs(nr, nc) + 1)
            return ans

        ans = 0
        for r in range(m):
            for c in range(n):
                ans = max(ans, dfs(r, c))
        return ans

class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        ROWS, COLS = len(matrix), len(matrix[0])
        dp = {} # (r, c) -> LIP

        def dfs(r, c, prevVal):
            if (r < 0 or r == ROWS or
                c < 0 or c == COLS or
                matrix[r][c] <= prevVal):
                return 0
            if (r, c) in dp:
                return dp[(r, c)]

            res = 1
            res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))
            res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))
            res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))
            res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))
            dp[(r, c)] = res
            return res

        for r in range(ROWS):
            for c in range(COLS):
                dfs(r, c, -1)
        return max(dp.values())
```

### [1463\. Cherry Pickup II](https://leetcode.com/problems/cherry-pickup-ii/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Matrix](https://leetcode.com/tag/matrix/)


You are given a `rows x cols` matrix `grid` representing a field of cherries where `grid[i][j]` represents the number of cherries that you can collect from the `(i, j)` cell.

You have two robots that can collect cherries for you:

*   **Robot #1** is located at the **top-left corner** `(0, 0)`, and
*   **Robot #2** is located at the **top-right corner** `(0, cols - 1)`.

Return _the maximum number of cherries collection using both robots by following the rules below_:

*   From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`.
*   When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.
*   When both robots stay in the same cell, only one takes the cherries.
*   Both robots cannot move outside of the grid at any moment.
*   Both robots should reach the bottom row in `grid`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png)

```
Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
Output: 24
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.
Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.
Total of cherries: 12 + 12 = 24.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png)

```
Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
Output: 28
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.
Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.
Total of cherries: 17 + 11 = 28.
```

**Constraints:**

*   `rows == grid.length`
*   `cols == grid[i].length`
*   `2 <= rows, cols <= 70`
*   `0 <= grid[i][j] <= 100`


#### Solution

Language: **Python**

```python
class Solution(object):
    def cherryPickup(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        m, n = len(grid), len(grid[0])
        dq = collections.deque()
        dq.append([(0, 0, grid[0][0]), (0, n - 1, grid[0][n - 1])])
        count = 0
        while dq:
            r1, r2 = dq.popleft()
            curr = r1[2] + r2[2]
            count = max(curr, count)
            i_r1, j_r1 = r1[0], r1[1]
            i_r2, j_r2 = r2[0], r2[1]
            for ni_r1, nj_r1 in [(i_r1 + 1, j_r1 - 1), (i_r1 + 1, j_r1), (i_r1 + 1, j_r1 + 1)]:
                for ni_r2, nj_r2 in [(i_r2 + 1, j_r2 - 1), (i_r2 + 1, j_r2), (i_r2 + 1, j_r2 + 1)]:
                    if 0 <= ni_r1 < m and 0 <= nj_r1 < n and 0 <= ni_r2 < m and 0 <= nj_r2 < n and nj_r1 != nj_r2:      
                        r1_state = (ni_r1, nj_r1, r1[2] + grid[ni_r1][nj_r1])
                        r2_state = (ni_r2, nj_r2, r2[2] + grid[ni_r2][nj_r2])
                        cur = [r1_state, r2_state]
                        #print cur
                        dq.append(cur)
        return count
```

```Python
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        @lru_cache(None)
        def dp(row, col1, col2):
            if col1 < 0 or col1 >= n or col2 < 0 or col2 >= n:
                return -inf
            # current cell
            result = 0
            result += grid[row][col1]
            if col1 != col2:
                result += grid[row][col2]
            # transition
            if row != m-1:
                result += max(dp(row+1, new_col1, new_col2)
                              for new_col1 in [col1, col1+1, col1-1]
                              for new_col2 in [col2, col2+1, col2-1])
            return result

        return dp(0, 0, n-1)
```

### [1770\. Maximum Score from Performing Multiplication Operations](https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


You are given two integer arrays `nums` and `multipliers`of size `n` and `m` respectively, where `n >= m`. The arrays are **1-indexed**.

You begin with a score of `0`. You want to perform **exactly** `m` operations. On the `i<sup>th</sup>` operation **(1-indexed)**, you will:

*   Choose one integer `x` from **either the start or the end** of the array `nums`.
*   Add `multipliers[i] * x` to your score.
*   Remove `x` from the array `nums`.

Return _the **maximum** score after performing_ `m` _operations._

**Example 1:**

```
Input: nums = [1,2,3], multipliers = [3,2,1]
Output: 14
Explanation: An optimal solution is as follows:
- Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.
- Choose from the end, [1,2], adding 2 * 2 = 4 to the score.
- Choose from the end, [1], adding 1 * 1 = 1 to the score.
The total score is 9 + 4 + 1 = 14.
```

**Example 2:**

```
Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
Output: 102
Explanation: An optimal solution is as follows:
- Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.
- Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.
- Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.
- Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.
- Choose from the end, [-2,7], adding 7 * 6 = 42 to the score.
The total score is 50 + 15 - 9 + 4 + 42 = 102.
```

**Constraints:**

*   `n == nums.length`
*   `m == multipliers.length`
*   `1 <= m <= 10<sup>3</sup>`
*   `m <= n <= 10<sup>5</sup>`
*   `-1000 <= nums[i], multipliers[i] <= 1000`


#### Solution

Language: **Python3**

```python
class Solution:
    def maximumScore(self, nums: List[int], m: List[int]) -> int:
        #dfs + memo
        #dp
        @lru_cache(2000)
        def dfs(start, end, index):
            if index == len(m):
                return 0

            #pick left
            left = m[index] * nums[start] + dfs(start + 1, end, index + 1)
            #pick right
            right = m[index] * nums[end] + dfs(start, end - 1, index + 1)

            return max(right, left)

        return dfs(0, len(nums) - 1, 0)
```

### [120\. Triangle](https://leetcode.com/problems/triangle/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given a `triangle` array, return _the minimum path sum from top to bottom_.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.

**Example 1:**

```
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
```

**Example 2:**

```
Input: triangle = [[-10]]
Output: -10
```

**Constraints:**

*   `1 <= triangle.length <= 200`
*   `triangle[0].length == 1`
*   `triangle[i].length == triangle[i - 1].length + 1`
*   `-10<sup>4</sup> <= triangle[i][j] <= 10<sup>4</sup>`

**Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?

#### Solution

Language: **Python3**

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        @lru_cache(maxsize=None)
        def min_path(row, col):
            path = triangle[row][col]
            if row < len(triangle) - 1:
                path += min(min_path(row + 1, col), min_path(row + 1, col + 1))
            return path
        return min_path(0, 0)
```

### [309\. Best Time to Buy and Sell Stock with Cooldown :rainbow:](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


You are given an array `prices` where `prices[i]` is the price of a given stock on the `i<sup>th</sup>` day.

Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:

*   After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).

**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

**Example 1:**

```
Input: prices = [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
```

**Example 2:**

```
Input: prices = [1]
Output: 0
```

**Constraints:**

*   `1 <= prices.length <= 5000`
*   `0 <= prices[i] <= 1000`


#### Solution

Language: **Python**

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        dp = {} # key=(i, buying) val=max_profit
        
        def dfs(i, buying):
            if i >= len(prices):
                return 0
            if (i, buying) in dp:
                return dp[(i, buying)]
            
            if buying:
                buy = dfs(i + 1, not buying) - prices[i]
                cooldown = dfs(i + 1, buying)
                dp[(i, buying)] = max(buy, cooldown)
            else:
                sell = dfs(i + 2, not buying) + prices[i]
                cooldown = dfs(i + 1, buying)
                dp[(i, buying)] = max(sell, cooldown)
            return dp[(i, buying)]
        
        return dfs(0, True)
```

### [1911\. Maximum Alternating Subsequence Sum](https://leetcode.com/problems/maximum-alternating-subsequence-sum/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


The **alternating sum** of a **0-indexed** array is defined as the **sum** of the elements at **even** indices **minus** the **sum** of the elements at **odd** indices.

*   For example, the alternating sum of `[4,2,5,3]` is `(4 + 5) - (2 + 3) = 4`.

Given an array `nums`, return _the **maximum alternating sum** of any subsequence of_ `nums` _(after **reindexing** the elements of the subsequence)_.

A **subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,<u style="display: inline;">2</u>,3,<u style="display: inline;">7</u>,2,1,<u style="display: inline;">4</u>]` (the underlined elements), while `[2,4,2]` is not.

**Example 1:**

```
Input: nums = [4,2,5,3]
Output: 7
Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7.
```

**Example 2:**

```
Input: nums = [5,6,7,8]
Output: 8
Explanation: It is optimal to choose the subsequence [8] with alternating sum 8.
```

**Example 3:**

```
Input: nums = [6,2,1,2,4,5]
Output: 10
Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10.
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `1 <= nums[i] <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def maxAlternatingSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def dfs(index, is_add):
            if index == len(nums):
                return 0
            if (index, is_add) in memo:
                return memo[(index, is_add)]
            
            if is_add:
                res = max(nums[index] + dfs(index + 1, is_add - 1), dfs(index + 1, is_add))
            else:
                res = max(-nums[index] + dfs(index + 1, is_add + 1), dfs(index + 1, is_add))
            
            memo[(index, is_add)] = res
            return res
        
        memo = {}
        return dfs(0, 1)
```

### [1553\. Minimum Number of Days to Eat N Oranges](https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/)

Difficulty: **Hard**  

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Memoization](https://leetcode.com/tag/memoization/)


There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows:

*   Eat one orange.
*   If the number of remaining oranges `n` is divisible by `2` then you can eat `n / 2` oranges.
*   If the number of remaining oranges `n` is divisible by `3` then you can eat `2 * (n / 3)` oranges.

You can only choose one of the actions per day.

Given the integer `n`, return _the minimum number of days to eat_ `n` _oranges_.

**Example 1:**

```
Input: n = 10
Output: 4
Explanation: You have 10 oranges.
Day 1: Eat 1 orange,  10 - 1 = 9\.  
Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3\. (Since 9 is divisible by 3)
Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1\.
Day 4: Eat the last orange  1 - 1  = 0.
You need at least 4 days to eat the 10 oranges.
```

**Example 2:**

```
Input: n = 6
Output: 3
Explanation: You have 6 oranges.
Day 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3\. (Since 6 is divisible by 2).
Day 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1\. (Since 3 is divisible by 3)
Day 3: Eat the last orange  1 - 1  = 0.
You need at least 3 days to eat the 6 oranges.
```

**Constraints:**

*   `1 <= n <= 2 * 10<sup>9</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def minDays(self, n):
        """
        :type n: int
        :rtype: int
        """
        def dfs(remain):
            if remain == 0:
                return 0
            if remain < 0:
                return float('inf')
            if remain in memo:
                return memo[remain]
            
            
            res = 1 + dfs(remain - 1)
            if remain % 2 == 0:
                res = min(res, 1 + dfs(remain - remain / 2))
            if remain % 3 == 0:
                res = min(res, 1 + dfs(remain - 2 * remain / 3))
            memo[remain] = res
            return res
                    
        memo = {}
        return dfs(n)

```

## Math
### [273\. Integer to English Words :rainbow:](https://leetcode.com/problems/integer-to-english-words/)

Difficulty: **Hard**  

Related Topics: [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/), [Recursion](https://leetcode.com/tag/recursion/)


Convert a non-negative integer `num` to its English words representation.

**Example 1:**

```
Input: num = 123
Output: "One Hundred Twenty Three"
```

**Example 2:**

```
Input: num = 12345
Output: "Twelve Thousand Three Hundred Forty Five"
```

**Example 3:**

```
Input: num = 1234567
Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
```

**Example 4:**

```
Input: num = 1234567891
Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
```

**Constraints:**

*   `0 <= num <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

```python
class Solution(object):
    def __init__(self):
        self.lessThan20 = ["","One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten","Eleven","Twelve","Thirteen","Fourteen","Fifteen","Sixteen","Seventeen","Eighteen","Nineteen"]
        self.tens = ["","Ten","Twenty","Thirty","Forty","Fifty","Sixty","Seventy","Eighty","Ninety"]
        self.thousands = ["","Thousand","Million","Billion"]

    def numberToWords(self, num):
        if num == 0:
            return "Zero"
        res = ""
        for i in range(len(self.thousands)):
            if num % 1000 != 0:
                res = self.helper(num%1000) + self.thousands[i] + " " + res
            num /= 1000
        return res.strip()

    def helper(self, num):
        if num == 0:
            return ""
        elif num < 20:
            return self.lessThan20[num] + " "
        elif num < 100:
            return self.tens[num/10] + " " + self.helper(num%10)
        else:
            return self.lessThan20[num/100] + " Hundred " + self.helper(num%100)
```

### [67\. Add Binary](https://leetcode.com/problems/add-binary/)

Difficulty: **Easy**  

Related Topics: [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/), [Simulation](https://leetcode.com/tag/simulation/)


Given two binary strings `a` and `b`, return _their sum as a binary string_.

**Example 1:**

```
Input: a = "11", b = "1"
Output: "100"
```

**Example 2:**

```
Input: a = "1010", b = "1011"
Output: "10101"
```

**Constraints:**

*   `1 <= a.length, b.length <= 10<sup>4</sup>`
*   `a` and `b` consist only of `'0'` or `'1'` characters.
*   Each string does not contain leading zeros except for the zero itself.


#### Solution

Language: **Python**

```python
def addBinary (a, b):
    i = len(a) - 1
    j = len(b) - 1
    carry = 0
    result = ''
    while i >= 0 or j >= 0:
        if i >= 0:
            carry += int(a[i])
            i -= 1
        if j >= 0:
            carry += int(b[j])
            j -= 1
        carry, curr = divmod(carry, 2)
        result = str(curr) + result        
    if carry > 0:
        result = '1' + result
    return result

addBinary(a = "11", b = "1")
addBinary(a = "1010", b = "1011")
```

### [65\. Valid Number](https://leetcode.com/problems/valid-number/)

Difficulty: **Hard**  

Related Topics: [String](https://leetcode.com/tag/string/)


A **valid number** can be split up into these components (in order):

1.  A **decimal number** or an **integer**.
2.  (Optional) An `'e'` or `'E'`, followed by an **integer**.

A **decimal number** can be split up into these components (in order):

1.  (Optional) A sign character (either `'+'` or `'-'`).
2.  One of the following formats:
    1.  One or more digits, followed by a dot `'.'`.
    2.  One or more digits, followed by a dot `'.'`, followed by one or more digits.
    3.  A dot `'.'`, followed by one or more digits.

An **integer** can be split up into these components (in order):

1.  (Optional) A sign character (either `'+'` or `'-'`).
2.  One or more digits.

For example, all the following are valid numbers: `["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]`, while the following are not valid numbers: `["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]`.

Given a string `s`, return `true` _if_ `s` _is a **valid number**_.

**Example 1:**

```
Input: s = "0"
Output: true
```

**Example 2:**

```
Input: s = "e"
Output: false
```

**Example 3:**

```
Input: s = "."
Output: false
```

**Example 4:**

```
Input: s = ".1"
Output: true
```

**Constraints:**

*   `1 <= s.length <= 20`
*   `s` consists of only English letters (both uppercase and lowercase), digits (`0-9`), plus `'+'`, minus `'-'`, or dot `'.'`.


#### Solution

Language: **Python3**

```python
class Solution:
    def isNumber(s):
        seen_digit = seen_exponent = seen_dot =  False
        for i, c in enumerate(s):
            if c in ['E', 'e']:
                if seen_exponent or not seen_digit:
                    return False
                seen_exponent = True
                seen_digit = False
            elif c in ['+', '-']:
                if i > 0 and s[i-1] not in ['E', 'e']:
                    return False
            elif c == '.':
                if seen_dot or seen_exponent:
                    return False
                seen_dot = True
            elif c.isdigit():
                seen_digit = True
            else:
                False
        return seen_digit
```

### [398\. Random Pick Index](https://leetcode.com/problems/random-pick-index/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [Reservoir Sampling](https://leetcode.com/tag/reservoir-sampling/), [Randomized](https://leetcode.com/tag/randomized/)


Given an integer array `nums` with possible **duplicates**, randomly output the index of a given `target` number. You can assume that the given target number must exist in the array.

Implement the `Solution` class:

*   `Solution(int[] nums)` Initializes the object with the array `nums`.
*   `int pick(int target)` Picks a random index `i` from `nums` where `nums[i] == target`. If there are multiple valid i's, then each index should have an equal probability of returning.

**Example 1:**

```
Input
["Solution", "pick", "pick", "pick"]
[[[1, 2, 3, 3, 3]], [3], [1], [3]]
Output
[null, 4, 0, 2]

Explanation
Solution solution = new Solution([1, 2, 3, 3, 3]);
solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
solution.pick(1); // It should return 0\. Since in the array only nums[0] is equal to 1.
solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
```

**Constraints:**

*   `1 <= nums.length <= 2 * 10<sup>4</sup>`
*   `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`
*   `target` is an integer from `nums`.
*   At most `10<sup>4</sup>` calls will be made to `pick`.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/random-pick-index/discuss/88072/Simple-Reservoir-Sampling-solution)

```python
class Solution(object):

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.nums = nums

    def pick(self, target):
        """
        :type target: int
        :rtype: int
        """
        cnt = idx = 0
        for i, num in enumerate(self.nums):
            if num != target:
                continue
            if cnt == 0:
                idx = i
                cnt = 1
            else:
                # this random will already give me numbers
                # between 0 and cnt inclusive
                # so for 2nd number I am getting random number 0 and 1
                # so each having a probability of 1/2
                # similarly for three numbers it will be 1/3
                rnd = random.randint(0, cnt)
                if (rnd == cnt):
                    idx = i
                cnt += 1

        return idx
```

### [43\. Multiply Strings](https://leetcode.com/problems/multiply-strings/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/), [Simulation](https://leetcode.com/tag/simulation/)


Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.

**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.

**Example 1:**

```
Input: num1 = "2", num2 = "3"
Output: "6"
```

**Example 2:**

```
Input: num1 = "123", num2 = "456"
Output: "56088"
```

**Constraints:**

*   `1 <= num1.length, num2.length <= 200`
*   `num1` and `num2` consist of digits only.
*   Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.


#### Solution

Language: **Python**

```python
def multiply(num1, num2):
    n = len(num1)
    m = len(num2)
    result = 0
    for i in reversed(range(n)):
        for j in reversed(range(m)):
            result += int(num1[i]) * int(num2[j]) * 10 ** (n - i - 1) * 10 ** (m - j - 1)  
    return str(result)

multiply(num1 = "2", num2 = "3")
multiply(num1 = "123", num2 = "456")
```

### [319\. Bulb Switcher](https://leetcode.com/problems/bulb-switcher/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Brainteaser](https://leetcode.com/tag/brainteaser/)


There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.

On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `i<sup>th</sup>` round, you toggle every `i` bulb. For the `n<sup>th</sup>` round, you only toggle the last bulb.

Return _the number of bulbs that are on after `n` rounds_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg)

```
Input: n = 3
Output: 1
Explanation: At first, the three bulbs are [off, off, off].
After the first round, the three bulbs are [on, on, on].
After the second round, the three bulbs are [on, off, on].
After the third round, the three bulbs are [on, off, off].
So you should return 1 because there is only one bulb is on.
```

**Example 2:**

```
Input: n = 0
Output: 0
```

**Example 3:**

```
Input: n = 1
Output: 1
```

**Constraints:**

*   `0 <= n <= 10<sup>9</sup>`


#### Solution

Language: **Python**

```python
def bulbSwitch(n):
    nums = [1] * n
    for i in range(1, n):
        for j in range(n):
            if (j + 1) % (i + 1) == 0:
                if nums[j] == 1:
                    nums[j] = 0
                else:
                    nums[j] = 1
    return sum(nums)     
```

### [470\. Implement Rand10() Using Rand7()](https://leetcode.com/problems/implement-rand10-using-rand7/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Rejection Sampling](https://leetcode.com/tag/rejection-sampling/), [Randomized](https://leetcode.com/tag/randomized/), [Probability and Statistics](https://leetcode.com/tag/probability-and-statistics/)


Given the **API** `rand7()` that generates a uniform random integer in the range `[1, 7]`, write a function `rand10()` that generates a uniform random integer in the range `[1, 10]`. You can only call the API `rand7()`, and you shouldn't call any other API. Please **do not** use a language's built-in random API.

Each test case will have one **internal** argument `n`, the number of times that your implemented function `rand10()` will be called while testing. Note that this is **not an argument** passed to `rand10()`.

**Example 1:**

```
Input: n = 1
Output: [2]
```

**Example 2:**

```
Input: n = 2
Output: [2,8]
```

**Example 3:**

```
Input: n = 3
Output: [3,8,10]
```

**Constraints:**

*   `1 <= n <= 10<sup>5</sup>`

**Follow up:**

*   What is the for the number of calls to `rand7()` function?
*   Could you minimize the number of calls to `rand7()`?


#### Solution

Language: **Python**

```python
from random import randint

def rand7():
    return randint(1, 7)

def rand10():
    c = (rand7() - 1)*7 + rand7() - 1
    return rand10() if c >= 40 else (c % 10) + 1    
```

### [149\. Max Points on a Line](https://leetcode.com/problems/max-points-on-a-line/)

Difficulty: **Hard**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [Geometry](https://leetcode.com/tag/geometry/)


Given an array of `points` where `points[i] = [x<sub style="display: inline;">i</sub>, y<sub style="display: inline;">i</sub>]` represents a point on the **X-Y** plane, return _the maximum number of points that lie on the same straight line_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)

```
Input: points = [[1,1],[2,2],[3,3]]
Output: 3
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg)

```
Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4
```

**Constraints:**

*   `1 <= points.length <= 300`
*   `points[i].length == 2`
*   `-10<sup>4</sup> <= x<sub style="display: inline;">i</sub>, y<sub style="display: inline;">i</sub> <= 10<sup>4</sup>`
*   All the `points` are **unique**.


#### Solution

Language: **Python**

```python
import collections

def maxPoints(points):
    max_points = 0
    for i, start in enumerate(points):
        slope_count, same = collections.defaultdict(int), 1
        for j in xrange(i + 1, len(points)):
            end = points[j]
            if start[0] == end[0] and start[1] == end[1]:
                same += 1
            else:
                slope = float("inf")
                if start[0] - end[0] != 0:
                    slope = (start[1] - end[1]) * 1.0 / (start[0] - end[0])
                slope_count[slope] += 1

        # find current_max
        current_max = same
        for slope in slope_count:
            current_max = max(current_max, slope_count[slope] + same)
        # find global_max
        max_points = max(max_points, current_max)

    return max_points

if __name__ == "__main__":
    maxPoints([[1,1],[2,2],[3,3]])
```

### [7\. Reverse Integer](https://leetcode.com/problems/reverse-integer/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/)


Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-2<sup>31</sup>, 2<sup>31</sup> - 1]`, then return `0`.

**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**

**Example 1:**

```
Input: x = 123
Output: 321
```

**Example 2:**

```
Input: x = -123
Output: -321
```

**Example 3:**

```
Input: x = 120
Output: 21
```

**Example 4:**

```
Input: x = 0
Output: 0
```

**Constraints:**

*   `-2<sup>31</sup> <= x <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

```python
class Solution:
    # @return an integer
    def reverse(self, x):
        result = 0

        if x < 0:
            symbol = -1
            x = -x
        else:
            symbol = 1

        while x:
            result = result * 10 + x % 10
            x /= 10

        return 0 if result > pow(2, 31) else result * symbol
```

### [1344\. Angle Between Hands of a Clock](https://leetcode.com/problems/angle-between-hands-of-a-clock/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/)


Given two numbers, `hour` and `minutes`. Return the smaller angle (in degrees) formed between the `hour` and the `minute` hand.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/12/26/sample_1_1673.png)

```
Input: hour = 12, minutes = 30
Output: 165
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/12/26/sample_2_1673.png)

```
Input: hour = 3, minutes = 30
Output: 75
```

**Example 3:**

**![](https://assets.leetcode.com/uploads/2019/12/26/sample_3_1673.png)**

```
Input: hour = 3, minutes = 15
Output: 7.5
```

**Example 4:**

```
Input: hour = 4, minutes = 50
Output: 155
```

**Example 5:**

```
Input: hour = 12, minutes = 0
Output: 0
```

**Constraints:**

*   `1 <= hour <= 12`
*   `0 <= minutes <= 59`
*   Answers within `10^-5` of the actual value will be accepted as correct.


#### Solution

Language: **Python**

```Python
class Solution:
    def angleClock(self, hour: int, minutes: int) -> float:
        minutes_angle = minutes / 60 * 360
        hour_angle = hour / 12 * 360 + minutes_angle /12
        diff_angle = abs(minutes_angle - hour_angle)
        return min(diff_angle,  360 - diff_angle)
```


### [12\. Integer to Roman](https://leetcode.com/problems/integer-to-roman/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/)


Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.
*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.
*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.

Given an integer, convert it to a roman numeral.

**Example 1:**

```
Input: num = 3
Output: "III"
```

**Example 2:**

```
Input: num = 4
Output: "IV"
```

**Example 3:**

```
Input: num = 9
Output: "IX"
```

**Example 4:**

```
Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
```

**Example 5:**

```
Input: num = 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```

**Constraints:**

*   `1 <= num <= 3999`


#### Solution

Language: **Python**

```python
def intToRoman(x):
    nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    strings = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
    result = ''
    for i in range(len(nums)):
        while x >= nums[i]:
            x -= nums[i]
            result += strings[i]
    return result
```

### [13\. Roman to Integer](https://leetcode.com/problems/roman-to-integer/)

Difficulty: **Easy**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/)


Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.
*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.
*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.

Given a roman numeral, convert it to an integer.

**Example 1:**

```
Input: s = "III"
Output: 3
```

**Example 2:**

```
Input: s = "IV"
Output: 4
```

**Example 3:**

```
Input: s = "IX"
Output: 9
```

**Example 4:**

```
Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
```

**Example 5:**

```
Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```

**Constraints:**

*   `1 <= s.length <= 15`
*   `s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.
*   It is **guaranteed** that `s` is a valid roman numeral in the range `[1, 3999]`.


#### Solution

Language: **Python**

```python
def romanToInt(s):
    d = {"M": 1000, "D": 500, "C": 100, "L": 50, "X": 10, "V": 5, "I": 1}
    n = len(s)
    result = d[s[n - 1]]
    for i in range(n - 2, -1, -1):
        if d[s[i]] < d[s[i + 1]]:
            result -= d[s[i]]
        else:
            result += d[s[i]]
    return result

romanToInt("III")
romanToInt("IV")
romanToInt("IX")
romanToInt("LVIII")
romanToInt("MCMXCIV")
```

### [231\. Power of Two](https://leetcode.com/problems/power-of-two/)

Difficulty: **Easy**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/), [Recursion](https://leetcode.com/tag/recursion/)


Given an integer `n`, return _`true` if it is a power of two. Otherwise, return `false`_.

An integer `n` is a power of two, if there exists an integer `x` such that `n == 2<sup>x</sup>`.

**Example 1:**

```
Input: n = 1
Output: true
Explanation: 20 = 1
```

**Example 2:**

```
Input: n = 16
Output: true
Explanation: 24 = 16
```

**Example 3:**

```
Input: n = 3
Output: false
```

**Constraints:**

*   `-2<sup>31</sup> <= n <= 2<sup>31</sup> - 1`

**Follow up:** Could you solve it without loops/recursion?

#### Solution

Language: **Python**

```python
class Solution(object):
    def isPowerOfTwo(self, n):
        """
        :type n: int
        :rtype: bool
        """
        if not n:
            return False
        while n % 2 == 0:
            n /= 2
        return n == 1
```

### [1041\. Robot Bounded In Circle](https://leetcode.com/problems/robot-bounded-in-circle/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/), [Simulation](https://leetcode.com/tag/simulation/)


On an infinite plane, a robot initially stands at `(0, 0)` and faces north. The robot can receive one of three instructions:

*   `"G"`: go straight 1 unit;
*   `"L"`: turn 90 degrees to the left;
*   `"R"`: turn 90 degrees to the right.

The robot performs the `instructions` given in order, and repeats them forever.

Return `true` if and only if there exists a circle in the plane such that the robot never leaves the circle.

**Example 1:**

```
Input: instructions = "GGLLGG"
Output: true
Explanation: The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).
When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.
```

**Example 2:**

```
Input: instructions = "GG"
Output: false
Explanation: The robot moves north indefinitely.
```

**Example 3:**

```
Input: instructions = "GL"
Output: true
Explanation: The robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ...
```

**Constraints:**

*   `1 <= instructions.length <= 100`
*   `instructions[i]` is `'G'`, `'L'` or, `'R'`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def isRobotBounded(self, instructions):
        """
        :type instructions: str
        :rtype: bool
        """
        x, y, dx, dy = 0, 0, 0, 1
        for i in instructions:
            if i == 'R': dx, dy = dy, -dx
            if i == 'L': dx, dy = -dy, dx
            if i == 'G': x, y = x + dx, y + dy
        return (x, y) == (0, 0) or (dx, dy) != (0,1)

```

### [2013\. Detect Squares :rainbow:](https://leetcode.com/problems/detect-squares/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Design](https://leetcode.com/tag/design/), [Counting](https://leetcode.com/tag/counting/)


You are given a stream of points on the X-Y plane. Design an algorithm that:

*   **Adds** new points from the stream into a data structure. **Duplicate** points are allowed and should be treated as different points.
*   Given a query point, **counts** the number of ways to choose three points from the data structure such that the three points and the query point form an **axis-aligned square** with **positive area**.

An **axis-aligned square** is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.

Implement the `DetectSquares` class:

*   `DetectSquares()` Initializes the object with an empty data structure.
*   `void add(int[] point)` Adds a new point `point = [x, y]` to the data structure.
*   `int count(int[] point)` Counts the number of ways to form **axis-aligned squares** with point `point = [x, y]` as described above.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/09/01/image.png)

```
Input
["DetectSquares", "add", "add", "add", "count", "count", "add", "count"]
[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
Output
[null, null, null, null, 1, 0, null, 2]

Explanation
DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // return 1\. You can choose:
                               //   - The first, second, and third points
detectSquares.count([14, 8]);  // return 0\. The query point cannot form a square with any points in the data structure.
detectSquares.add([11, 2]);    // Adding duplicate points is allowed.
detectSquares.count([11, 10]); // return 2\. You can choose:
                               //   - The first, second, and third points
                               //   - The first, third, and fourth points
```

**Constraints:**

*   `point.length == 2`
*   `0 <= x, y <= 1000`
*   At most `3000` calls **in total** will be made to `add` and `count`.


#### Solution

Language: **Python**

```python
class DetectSquares(object):

    def __init__(self):
        self.ptsCount = defaultdict(int)
        self.pts = []

    def add(self, point):
        """
        :type point: List[int]
        :rtype: None
        """
        self.ptsCount[tuple(point)] += 1
        self.pts.append(point)
        
    def count(self, point):
        """
        :type point: List[int]
        :rtype: int
        """
        res = 0
        px, py = point
        for x, y in self.pts:      
            if (abs(py - y) != abs(px - x)) or x == px or y == py:
                continue
            res += self.ptsCount[(x, py)] * self.ptsCount[(px, y)]
        return res

# Your DetectSquares object will be instantiated and called as such:
# obj = DetectSquares()
# obj.add(point)
# param_2 = obj.count(point)
```

### [939\. Minimum Area Rectangle](https://leetcode.com/problems/minimum-area-rectangle/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [Geometry](https://leetcode.com/tag/geometry/), [Sorting](https://leetcode.com/tag/sorting/)


You are given an array of points in the **X-Y** plane `points` where `points[i] = [x<sub style="display: inline;">i</sub>, y<sub style="display: inline;">i</sub>]`.

Return _the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes_. If there is not any such rectangle, return `0`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/08/03/rec1.JPG)

```
Input: points = [[1,1],[1,3],[3,1],[3,3],[2,2]]
Output: 4
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/08/03/rec2.JPG)

```
Input: points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]
Output: 2
```

**Constraints:**

*   `1 <= points.length <= 500`
*   `points[i].length == 2`
*   `0 <= x<sub style="display: inline;">i</sub>, y<sub style="display: inline;">i</sub> <= 4 * 10<sup>4</sup>`
*   All the given points are **unique**.


#### Solution

Language: **Python3**

```python
class Solution:
    def minAreaRect(self, points: List[List[int]]) -> int:
        min_area = float('inf')
        pool = set()
        for x, y in points:
            pool.add((x, y))
        #print(pool)
        for x1, y1 in points:
            for x2, y2 in points:
                if x1 != x2 and y1 != y2:
                    if (x1, y2) in pool and (x2, y1) in pool:
                        area = abs(x1 - x2) * abs(y1 - y2)
                        min_area = min(area, min_area)
        return 0 if min_area == float('inf') else min_area
                    
```

## Bit Manipulation
### [136\. Single Number](https://leetcode.com/problems/single-number/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/)


Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

**Example 1:**

```
Input: nums = [2,2,1]
Output: 1
```

**Example 2:**

```
Input: nums = [4,1,2,1,2]
Output: 4
```

**Example 3:**

```
Input: nums = [1]
Output: 1
```

**Constraints:**

*   `1 <= nums.length <= 3 * 10<sup>4</sup>`
*   `-3 * 10<sup>4</sup> <= nums[i] <= 3 * 10<sup>4</sup>`
*   Each element in the array appears twice except for one element which appears only once.


#### Solution

Language: **Python**

```python
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        res = 0
        for num in nums:
            res = res ^ num
        return res
```

### [2002\. Maximum Product of the Length of Two Palindromic Subsequences :fire:](https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Backtracking](https://leetcode.com/tag/backtracking/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/), [Bitmask](https://leetcode.com/tag/bitmask/)


Given a string `s`, find two **disjoint palindromic subsequences** of `s` such that the **product** of their lengths is **maximized**. The two subsequences are **disjoint** if they do not both pick a character at the same index.

Return _the **maximum** possible **product** of the lengths of the two palindromic subsequences_.

A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is **palindromic** if it reads the same forward and backward.

**Example 1:**

![example-1](https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png)

```
Input: s = "leetcodecom"
Output: 9
Explanation: An optimal solution is to choose "ete" for the 1st subsequence and "cdc" for the 2nd subsequence.
The product of their lengths is: 3 * 3 = 9.
```

**Example 2:**

```
Input: s = "bb"
Output: 1
Explanation: An optimal solution is to choose "b" (the first character) for the 1st subsequence and "b" (the second character) for the 2nd subsequence.
The product of their lengths is: 1 * 1 = 1.
```

**Example 3:**

```
Input: s = "accbcaxxcxx"
Output: 25
Explanation: An optimal solution is to choose "accca" for the 1st subsequence and "xxcxx" for the 2nd subsequence.
The product of their lengths is: 5 * 5 = 25.
```

**Constraints:**

*   `2 <= s.length <= 12`
*   `s` consists of lowercase English letters only.


#### Solution

Language: **Python**

```python
class Solution(object):
    def maxProduct(self, s):
        """
        :type s: str
        :rtype: int
        """
        n = len(s)
        pali = {} # bitmask: length
        
        for mask in range(1, 1 << n): # 1 << n == 2 ** n
            substr = ''
            for i in range(n):
                if mask & (1 << i): # generate substring
                    substr += s[i]
            if substr == substr[::-1]: # handles Palindromic here
                pali[mask] = len(substr)
                
        res = 0
        for m1 in pali:
            for m2 in pali:
                if m1 & m2 == 0: # disjoint:
                    res = max(res, pali[m1] * pali[m2])
        return res
            
```

## Array
### [238\. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/)


Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`.

The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

You must write an algorithm that runs in `O(n)` time and without using the division operation.

**Example 1:**

```
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
```

**Example 2:**

```
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
```

**Constraints:**

*   `2 <= nums.length <= 10<sup>5</sup>`
*   `-30 <= nums[i] <= 30`
*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

**Follow up:** Can you solve the problem in `O(1) `extra space complexity? (The output array **does not** count as extra space for space complexity analysis.)


#### Solution

Language: **Python**

```python
# sol-2: O(n)
def productExceptSelf(nums):
    result = []
    n = len(nums)
    right = [1] * n
    left = [1] * n
    for i in range(n - 2, -1, -1):
        right[i] = right[i + 1] * nums[i + 1]
    for j in range(1, n):
        left[j] = left[j - 1] * nums[j - 1]
    for k in range(n):
        result.append(left[k] *  right[k])
    return result

productExceptSelf(nums = [1,2,3,4])
productExceptSelf(nums = [-1,1,0,-3,3])
```

### [31\. Next Permutation](https://leetcode.com/problems/next-permutation/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/)


Implement **next permutation**, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).

The replacement must be and use only constant extra memory.

**Example 1:**

```
Input: nums = [1,2,3]
Output: [1,3,2]
```

**Example 2:**

```
Input: nums = [3,2,1]
Output: [1,2,3]
```

**Example 3:**

```
Input: nums = [1,1,5]
Output: [1,5,1]
```

**Example 4:**

```
Input: nums = [1]
Output: [1]
```

**Constraints:**

*   `1 <= nums.length <= 100`
*   `0 <= nums[i] <= 100`


#### Solution

Language: **Python**

```python
def nextPermutation(nums):
    """
    :type nums: List[int]
    :rtype: None Do not return anything, modify nums in-place instead.
    """
    i = j = len(nums)-1
    while i > 0 and nums[i-1] >= nums[i]:
        i -= 1
    if i == 0:   # nums are in descending order
        nums.reverse()
        return nums
    k = i - 1    # find the last "ascending" position
    while nums[j] <= nums[k]:
        j -= 1
    print k, i, j
    nums[k], nums[j] = nums[j], nums[k]  
    l, r = k+1, len(nums)-1  # reverse the second part
    while l < r:
        nums[l], nums[r] = nums[r], nums[l]
        l +=1 ; r -= 1
    return nums

nextPermutation(nums = [1,2,3])
nextPermutation(nums = [3,2,1])
nextPermutation(nums = [1,1,5])
nextPermutation(nums = [1,4,3,2])
```

### [56\. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Sorting](https://leetcode.com/tag/sorting/)


Given an array of `intervals` where `intervals[i] = [start<sub style="display: inline;">i</sub>, end<sub style="display: inline;">i</sub>]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

**Constraints:**

*   `1 <= intervals.length <= 10<sup>4</sup>`
*   `intervals[i].length == 2`
*   `0 <= start<sub style="display: inline;">i</sub> <= end<sub style="display: inline;">i</sub> <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
def is_overlapped(interval_a, interval_b):
    return interval_a[0] <= interval_b[0] <= interval_a[1] or interval_b[0] <= interval_a[1] <= interval_b[1]

def merge_two_intervals(interval_a, interval_b):
    return [min(interval_a[0], interval_b[0]), max(interval_a[1], interval_b[1])]

def merge(intervals):
    intervals.sort(key = lambda x: x[0])
    stack = [intervals[0]]
    for interval in intervals[1:]:            
        if is_overlapped(stack[-1], interval):
            stack.append(merge_two_intervals(stack.pop(), interval))
        else:
            stack.append(interval)
    return stack

merge(intervals = [[2,6], [1,3],[8,10],[15,18]])
merge(intervals = [[1,4],[4,5]])
merge(intervals = [[1,4],[0,4]])
```

### [304\. Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Design](https://leetcode.com/tag/design/), [Matrix](https://leetcode.com/tag/matrix/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/)


Given a 2D matrix `matrix`, handle multiple queries of the following type:

*   Calculate the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.

Implement the NumMatrix class:

*   `NumMatrix(int[][] matrix)` Initializes the object with the integer matrix `matrix`.
*   `int sumRegion(int row1, int col1, int row2, int col2)` Returns the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg)

```
Input
["NumMatrix", "sumRegion", "sumRegion", "sumRegion"]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]
Output
[null, 8, 11, 12]

Explanation
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)
```

**Constraints:**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= m, n <= 200`
*   `-10<sup>5</sup> <= matrix[i][j] <= 10<sup>5</sup>`
*   `0 <= row1 <= row2 < m`
*   `0 <= col1 <= col2 < n`
*   At most `10<sup>4</sup>` calls will be made to `sumRegion`.


#### Solution

Language: **Python**

```python
class NumMatrix(object):
    def __init__(self, matrix):
        """
        :type matrix: List[List[int]]
        """
        if not matrix or not matrix[0]:
            M, N = 0, 0
        else:
            M, N = len(matrix), len(matrix[0])
        # 
        self.sumM = [[0] * (N + 1) for _ in range(M + 1)]
        for i in range(M):
            for j in range(N):
                self.sumM[i + 1][j + 1] = self.sumM[i][j + 1] + self.sumM[i + 1][j]  - self.sumM[i][j] + matrix[i][j]

    def sumRegion(self, row1, col1, row2, col2):
        """
        :type row1: int
        :type col1: int
        :type row2: int
        :type col2: int
        :rtype: int
        """
        return self.sumM[row2 + 1][col2 + 1] - self.sumM[row2 + 1][col1] - self.sumM[row1][col2 + 1] + self.sumM[row1][col1]

numMatrix = NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]])
numMatrix.sumRegion(2, 1, 4, 3)
numMatrix.sumRegion(1, 1, 2, 2)
numMatrix.sumRegion(1, 2, 2, 4)
```

### [1428\. Leftmost Column with at Least a One](https://leetcode.com/problems/leftmost-column-with-at-least-a-one/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Matrix](https://leetcode.com/tag/matrix/), [Interactive](https://leetcode.com/tag/interactive/)


_(This problem is an **interactive problem**.)_

A **row-sorted binary matrix** means that all elements are `0` or `1` and each row of the matrix is sorted in non-decreasing order.

Given a **row-sorted binary matrix** `binaryMatrix`, return _the index (0-indexed) of the **leftmost column** with a 1 in it_. If such an index does not exist, return `-1`.

**You can't access the Binary Matrix directly.** You may only access the matrix using a `BinaryMatrix` interface:

*   `BinaryMatrix.get(row, col)` returns the element of the matrix at index `(row, col)` (0-indexed).
*   `BinaryMatrix.dimensions()` returns the dimensions of the matrix as a list of 2 elements `[rows, cols]`, which means the matrix is `rows x cols`.

Submissions making more than `1000` calls to `BinaryMatrix.get` will be judged _Wrong Answer_. Also, any solutions that attempt to circumvent the judge will result in disqualification.

For custom testing purposes, the input will be the entire binary matrix `mat`. You will not have access to the binary matrix directly.

**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-5.jpg)**

```
Input: mat = [[0,0],[1,1]]
Output: 0
```

**Example 2:**

**![](https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-4.jpg)**

```
Input: mat = [[0,0],[0,1]]
Output: 1
```

**Example 3:**

**![](https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-3.jpg)**

```
Input: mat = [[0,0],[0,0]]
Output: -1
```

**Example 4:**

**![](https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-6.jpg)**

```
Input: mat = [[0,0,0,1],[0,0,1,1],[0,1,1,1]]
Output: 1
```

**Constraints:**

*   `rows == mat.length`
*   `cols == mat[i].length`
*   `1 <= rows, cols <= 100`
*   `mat[i][j]` is either `0` or `1`.
*   `mat[i]` is sorted in non-decreasing order.


#### Solution

Language: **Python**

```python
# """
# This is BinaryMatrix's API interface.
# You should not implement it, or speculate about its implementation
# """
#class BinaryMatrix(object):
#    def get(self, row, col):
#        """
#        :type row : int, col : int
#        :rtype int
#        """
#
#    def dimensions:
#        """
#        :rtype list[]
#        """
class Solution:
    def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:
        M, N = binaryMatrix.dimensions()

        r, c = 0, N - 1
        leftmost_col = -1
        while r < M and c >= 0:
            if binaryMatrix.get(r,c) == 1:
                leftmost_col = c
                c -= 1
            else:
                r += 1
        return leftmost_col
```

### [896\. Monotonic Array](https://leetcode.com/problems/monotonic-array/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/)


An array is **monotonic** if it is either monotone increasing or monotone decreasing.

An array `nums` is monotone increasing if for all `i <= j`, `nums[i] <= nums[j]`. An array `nums` is monotone decreasing if for all `i <= j`, `nums[i] >= nums[j]`.

Given an integer array `nums`, return `true` _if the given array is monotonic, or_ `false` _otherwise_.

**Example 1:**

```
Input: nums = [1,2,2,3]
Output: true
```

**Example 2:**

```
Input: nums = [6,5,4,4]
Output: true
```

**Example 3:**

```
Input: nums = [1,3,2]
Output: false
```

**Example 4:**

```
Input: nums = [1,2,4,5]
Output: true
```

**Example 5:**

```
Input: nums = [1,1,1]
Output: true
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def isMonotonic(self, A):
        increasing = decreasing = True

        for i in xrange(len(A) - 1):
            if A[i] > A[i+1]:
                increasing = False
            if A[i] < A[i+1]:
                decreasing = False

        return increasing or decreasing
```

### [42\. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Stack](https://leetcode.com/tag/stack/), [Monotonic Stack](https://leetcode.com/tag/monotonic-stack/)


Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

```
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
```

**Example 2:**

```
Input: height = [4,2,0,3,2,5]
Output: 9
```

**Constraints:**

*   `n == height.length`
*   `1 <= n <= 2 * 10<sup>4</sup>`
*   `0 <= height[i] <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
# no ac
def trap(height):
    if not height:
        return 0
    n = len(height)
    max_left = [0] * n
    max_right = [0] * n
    max_left[0] = height[0]
    max_left[-1] = height[-1]
    # i
    for i in range(1, n):
        max_left[i] = max(height[i], max_left[i - 1])
    for i in range(n - 2, -1, -1):
        max_right[i] = max(height[i], max_right[i + 1])
    res = 0
    for i in range(n):
        res += max(min(max_left[i], max_right[i]) - height[i], 0)
    return res

trap([0,1,0,2,1,0,1,3,2,1,2,1])
```

```python
def trap(nums):
    n = len(nums)
    h = nums[n - 1]
    maxh = [0] * n
    for i in range(n - 2, -1, -1):
        maxh[i] = h
        h = max(nums[i], h)

    h = nums[0]
    result = 0
    for j in range(1, n):
        h = max(h, nums[j])
        result += max(0, min(h, maxh[j]) - nums[j])
    return result

trap([0,1,0,2,1,0,1,3,2,1,2,1])
```

### [670\. Maximum Swap :rainbow:](https://leetcode.com/problems/maximum-swap/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [Greedy](https://leetcode.com/tag/greedy/)


You are given an integer `num`. You can swap two digits at most once to get the maximum valued number.

Return _the maximum valued number you can get_.

**Example 1:**

```
Input: num = 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.
```

**Example 2:**

```
Input: num = 9973
Output: 9973
Explanation: No swap.
```

**Constraints:**

*   `0 <= num <= 10<sup>8</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def maximumSwap(self, num):
        """
        :type num: int
        :rtype: int
        """
        A = map(int, str(num))
        last = {x: i for i, x in enumerate(A)}
        for i, x in enumerate(A):
            for d in xrange(9, x, -1):
                if last.get(d, None) > i:
                    A[i], A[last[d]] = A[last[d]], A[i]
                    return int("".join(map(str, A)))
        return num
```

### [348\. Design Tic-Tac-Toe :rainbow:](https://leetcode.com/problems/design-tic-tac-toe/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Design](https://leetcode.com/tag/design/), [Matrix](https://leetcode.com/tag/matrix/)


Assume the following rules are for the tic-tac-toe game on an `n x n` board between two players:

1.  A move is guaranteed to be valid and is placed on an empty block.
2.  Once a winning condition is reached, no more moves are allowed.
3.  A player who succeeds in placing `n` of their marks in a horizontal, vertical, or diagonal row wins the game.

Implement the `TicTacToe` class:

*   `TicTacToe(int n)` Initializes the object the size of the board `n`.
*   `int move(int row, int col, int player)` Indicates that the player with id `player` plays at the cell `(row, col)` of the board. The move is guaranteed to be a valid move.

**Example 1:**

```
Input
["TicTacToe", "move", "move", "move", "move", "move", "move", "move"]
[[3], [0, 0, 1], [0, 2, 2], [2, 2, 1], [1, 1, 2], [2, 0, 1], [1, 0, 2], [2, 1, 1]]
Output
[null, 0, 0, 0, 0, 0, 0, 1]

Explanation
TicTacToe ticTacToe = new TicTacToe(3);
Assume that player 1 is "X" and player 2 is "O" in the board.
ticTacToe.move(0, 0, 1); // return 0 (no one wins)
|X| | |
| | | |    // Player 1 makes a move at (0, 0).
| | | |

ticTacToe.move(0, 2, 2); // return 0 (no one wins)
|X| |O|
| | | |    // Player 2 makes a move at (0, 2).
| | | |

ticTacToe.move(2, 2, 1); // return 0 (no one wins)
|X| |O|
| | | |    // Player 1 makes a move at (2, 2).
| | |X|

ticTacToe.move(1, 1, 2); // return 0 (no one wins)
|X| |O|
| |O| |    // Player 2 makes a move at (1, 1).
| | |X|

ticTacToe.move(2, 0, 1); // return 0 (no one wins)
|X| |O|
| |O| |    // Player 1 makes a move at (2, 0).
|X| |X|

ticTacToe.move(1, 0, 2); // return 0 (no one wins)
|X| |O|
|O|O| |    // Player 2 makes a move at (1, 0).
|X| |X|

ticTacToe.move(2, 1, 1); // return 1 (player 1 wins)
|X| |O|
|O|O| |    // Player 1 makes a move at (2, 1).
|X|X|X|
```

**Constraints:**

*   `2 <= n <= 100`
*   player is `1` or `2`.
*   `0 <= row, col < n`
*   `(row, col)` are **unique** for each different call to `move`.
*   At most `n<sup>2</sup>` calls will be made to `move`.

**Follow-up:** Could you do better than `O(n<sup>2</sup>)` per `move()` operation?


#### Solution

Language: **Python**

```python
class TicTacToe:
    def __init__(self, n):
        self.n = n
        self.row = [0] * self.n
        self.col = [0] * self.n
        self.diag_left = 0
        self.diag_right = 0

    def move(self, row, col, player):
        if player == 1:
            point = 1
        else:
            point = -1

        self.row[row] += point
        self.col[col] += point
        if row == col:
            self.diag_left += point
        if row + col == self.n - 1:
            self.diag_right += point

        if self.n in [self.row[row], self.col[col], self.diag_left, self.diag_right]:
            return 1
        elif -self.n in [self.row[row], self.col[col], self.diag_left, self.diag_right]:
            return 2

toe = TicTacToe(3);

toe.move(0, 0, 1)
toe.move(0, 2, 2)
toe.move(2, 2, 1)
toe.move(1, 1, 2)
toe.move(2, 0, 1)
toe.move(1, 0, 2)
toe.move(2, 1, 1)
```    

### [419\. Battleships in a Board](https://leetcode.com/problems/battleships-in-a-board/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `m x n` matrix `board` where each cell is a battleship `'X'` or empty `'.'`, return _the number of the **battleships** on_ `board`.

**Battleships** can only be placed horizontally or vertically on `board`. In other words, they can only be made of the shape `1 x k` (`1` row, `k` columns) or `k x 1` (`k` rows, `1` column), where `k` can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/10/battelship-grid.jpg)

```
Input: board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]]
Output: 2
```

**Example 2:**

```
Input: board = [["."]]
Output: 0
```

**Constraints:**

*   `m == board.length`
*   `n == board[i].length`
*   `1 <= m, n <= 200`
*   `board[i][j]` is either `'.'` or `'X'`.

**Follow up:** Could you do it in one-pass, using only `O(1)` extra memory and without modifying the values `board`?


#### Solution

Language: **Python**

```python
def countBattleships(board):
    count = 0
    for i in range(len(board)):
        for j in range(len(board[0])):
            if board[i][j] == 'X':
                if i > 0 and board[i - 1][j] == 'X' or j > 0 and board[i][j - 1] == 'X':                
                    continue
                count += 1
    return count

countBattleships(board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]])
```

### [498\. Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Matrix](https://leetcode.com/tag/matrix/), [Simulation](https://leetcode.com/tag/simulation/)


Given an `m x n` matrix `mat`, return _an array of all the elements of the array in a diagonal order_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg)

```
Input: mat = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,4,7,5,3,6,8,9]
```

**Example 2:**

```
Input: mat = [[1,2],[3,4]]
Output: [1,2,3,4]
```

**Constraints:**

*   `m == mat.length`
*   `n == mat[i].length`
*   `1 <= m, n <= 10<sup>4</sup>`
*   `1 <= m * n <= 10<sup>4</sup>`
*   `-10<sup>5</sup> <= mat[i][j] <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def findDiagonalOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        result = [ ]
        dd = collections.defaultdict(list)
        if not matrix: return result
        # Step 1: Numbers are grouped by the diagonals.
        # Numbers in same diagonal have same value of row+col
        for i in range(0, len(matrix)):
            for j in range(0, len(matrix[0])):
                dd[i+j+1].append(matrix[i][j]) # starting indices from 1, hence i+j+1.
        # Step 2: Place diagonals in the result list.
        # But remember to reverse numbers in odd diagonals.
        for k in sorted(dd.keys()):
            if k%2==1: dd[k].reverse()
            result += dd[k]
        return result

findDiagonalOrder(mat = [[1,2,3],[4,5,6],[7,8,9]])
findDiagonalOrder(mat = [[1,2],[3,4]])
```

### [766\. Toeplitz Matrix](https://leetcode.com/problems/toeplitz-matrix/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `m x n` `matrix`, return _`true` if the matrix is Toeplitz. Otherwise, return `false`._

A matrix is **Toeplitz** if every diagonal from top-left to bottom-right has the same elements.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg)

```
Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
Output: true
Explanation:
In the above grid, the diagonals are:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
In each diagonal all elements are the same, so the answer is True.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg)

```
Input: matrix = [[1,2],[2,2]]
Output: false
Explanation:
The diagonal "[1, 2]" has different elements.
```

**Constraints:**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= m, n <= 20`
*   `0 <= matrix[i][j] <= 99`

**Follow up:**

*   What if the `matrix` is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?
*   What if the `matrix` is so large that you can only load up a partial row into the memory at once?


#### Solution

Language: **Python**

```python
def isToeplitzMatrix(matrix):
    m, n = len(matrix), len(matrix[0])
    for i in range(m):
        for j in range(n):
            next_i = i + 1
            next_j = j + 1
            if 0 <= next_i < m and 0 <= next_j < n and matrix[i][j] != matrix[next_i][next_j]:
                    return False
    return True

isToeplitzMatrix(matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]])
isToeplitzMatrix(matrix = [[1,2],[2,2]])    
```

### [674\. Longest Continuous Increasing Subsequence](https://leetcode.com/problems/longest-continuous-increasing-subsequence/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/)


Given an unsorted array of integers `nums`, return _the length of the longest **continuous increasing subsequence** (i.e. subarray)_. The subsequence must be **strictly** increasing.

A **continuous increasing subsequence** is defined by two indices `l` and `r` (`l < r`) such that it is `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` and for each `l <= i < r`, `nums[i] < nums[i + 1]`.

**Example 1:**

```
Input: nums = [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.
Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element
4.
```

**Example 2:**

```
Input: nums = [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2] with length 1\. Note that it must be strictly
increasing.
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>4</sup>`
*   `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`


#### Solution

Language: **Python**

```python
def lengthOfLIS(nums):
    if not nums:
        return 0
    local_max = 1
    global_max = 1

    for i in xrange(1, len(nums)):
        if nums[i] > nums[i - 1]:
            local_max += 1
            global_max = max(global_max, local_max)
        else:
            local_max = 1
    return global_max

lengthOfLIS([1,3,5,4,7])
lengthOfLIS([2,2,2,2,2])
```

### [73\. Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s, and return _the matrix_.

You must do it .

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)

```
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)

```
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

**Constraints:**

*   `m == matrix.length`
*   `n == matrix[0].length`
*   `1 <= m, n <= 200`
*   `-2<sup>31</sup> <= matrix[i][j] <= 2<sup>31</sup> - 1`

**Follow up:**

*   A straightforward solution using `O(mn)` space is probably a bad idea.
*   A simple improvement uses `O(m + n)` space, but still not the best solution.
*   Could you devise a constant space solution?


#### Solution

Language: **Python**


```python
# sol1: Time: O(M*N) Space: O(M + N)
def setZeros(matrix):
    n, m = len(matrix), len(matrix[0])
    row = [1] * n
    col = [1] * m

    # Store the rows and columns to be marked
    # as 1 in row[] and col[] arrays respectively
    for i in range(n) :
        for j in range(m) :
            if matrix[i][j] == 0:
                row[i] = 0
                col[j] = 0

    # Modify the input matrix matrix[] using the
    # above constructed row[] and col[] arrays
    for i in range(n) :
        for j in range(m):
            if row[i] == 0 or col[j] == 0:
                matrix[i][j] = 0

    return matrix

if __name__ == "__main__":
    matrix = [[0,1,2,0],
              [3,4,5,2],
              [1,3,1,5]]
    setZeros(matrix)
```

```python
# sol2: Time: O(M*N) Space: O(1)
def setZeros(matrix):
    # variables to check if there are any 1
    # in first row and column
    row_flag = False
    col_flag = False

    # updating the first row and col
    # if 1 is encountered
    for i in range(len(matrix)) :
        for j in range(len(matrix[0])) :
            if i == 0 and matrix[i][j] == 0:
                row_flag = True

            if j == 0 and matrix[i][j] == 0:
                col_flag = True

            if matrix[i][j] == 0:
                matrix[0][j] = 0
                matrix[i][0] = 0

    # Modify the input matrix mat[] using the
    # first row and first column of Matrix mat
    for i in range(1, len(matrix)) :
        for j in range(1, len(matrix[0])) :
            if matrix[0][j] == 0 or matrix[i][0] == 0:
                matrix[i][j] = 0

    # modify first row if there was any 1
    if row_flag == True:
        for j in range(len(matrix[0])):
            matrix[0][j] = 0

    # modify first col if there was any 1
    if col_flag == True:
        for i in range(len(matrix)) :
            matrix[i][0] = 0

    return matrix

if __name__ == "__main__":
    matrix = [[0,1,2,0],
              [3,4,5,2],
              [1,3,1,5]]
    setZeros(matrix)
```

### [152\. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return _the product_.

It is **guaranteed** that the answer will fit in a **32-bit** integer.

A **subarray** is a contiguous subsequence of the array.

**Example 1:**

```
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
```

**Example 2:**

```
Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
```

**Constraints:**

*   `1 <= nums.length <= 2 * 10<sup>4</sup>`
*   `-10 <= nums[i] <= 10`
*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.


#### Solution

Language: **Python**

```python
def maxProduct(nums):
    positive_max, negative_max = nums[0], nums[0]
    result = nums[0]
    for num in nums[1:]:
        positive_max, negative_max = max(num, positive_max * num, negative_max * num), min(num, positive_max * num, negative_max * num)
        result = max(result, positive_max)
    return result

if __name__ == "__main__":
    maxProduct([-4,-3,-2])
    maxProduct([2,3,-2,-4])
```

### [605\. Can Place Flowers](https://leetcode.com/problems/can-place-flowers/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/)


You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in **adjacent** plots.

Given an integer array `flowerbed` containing `0`'s and `1`'s, where `0` means empty and `1` means not empty, and an integer `n`, return _if_ `n` new flowers can be planted in the `flowerbed` without violating the no-adjacent-flowers rule.

**Example 1:**

```
Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
```

**Example 2:**

```
Input: flowerbed = [1,0,0,0,1], n = 2
Output: false
```

**Constraints:**

*   `1 <= flowerbed.length <= 2 * 10<sup>4</sup>`
*   `flowerbed[i]` is `0` or `1`.
*   There are no two adjacent flowers in `flowerbed`.
*   `0 <= n <= flowerbed.length`


#### Solution

Language: **Python**

```python
flowerbed = [1,0]; n = 1
def canPlaceFlowers(flowerbed, n):
    flowerbed.append(0)
    flowerbed.insert(0, 0)
    size = len(flowerbed)  
    for i in range(1, size - 1):
        if flowerbed[i - 1] == flowerbed[i] == flowerbed[i + 1] == 0:
            n -= 1; flowerbed[i] = 1
        if n == 0:
            return True
    return False

canPlaceFlowers([1,0], 1)
```

### [361\. Bomb Enemy :fire:](https://leetcode.com/problems/bomb-enemy/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `m x n` matrix `grid` where each cell is either a wall `'W'`, an enemy `'E'` or empty `'0'`, return _the maximum enemies you can kill using one bomb_. You can only place the bomb in an empty cell.

The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/27/bomb1-grid.jpg)

```
Input: grid = [["0","E","0","0"],["E","0","W","E"],["0","E","0","0"]]
Output: 3
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/27/bomb2-grid.jpg)

```
Input: grid = [["W","W","W"],["0","0","0"],["E","E","E"]]
Output: 1
```

**Constraints:**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 500`
*   `grid[i][j]` is either `'W'`, `'E'`, or `'0'`.


#### Solution

Language: **Python**

Time Complexity: O(WH(W+H))
```python
class Solution(object):
    def maxKilledEnemies(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        ## RC ##
		## APPROACH : DP ##
        ## LOGIC ##
        ## 1. For every "O" position, store enemies left to it, right to it, below it, above it
		## TIME COMPLEXICITY : O(5N) ##
		## SPACE COMPLEXICITY : O(N) ##

        if( not grid ): return 0
        n = len(grid)
        m = len(grid[0])
        # [0,0,0,0] => Number of enemies to ( Left, Right, Top, Bottom )
        dp = [ [[0,0,0,0] for __ in range(m)] for _ in range(n) ]

        # left to right
        for i in range(n):
            runningSum = 0
            for j in range(m):
                if( grid[i][j] == "E" ):
                    runningSum += 1
                elif( grid[i][j] == "W" ):
                    runningSum = 0
                else:
                    dp[i][j][0] = runningSum

        # right to left
        for i in range(n):
            runningSum = 0
            for j in range(m-1, -1, -1):
                if( grid[i][j] == "E" ):
                    runningSum += 1
                elif( grid[i][j] == "W" ):
                    runningSum = 0
                else:
                    dp[i][j][1] = runningSum

        # top to bottom
        for j in range(m):
            runningSum = 0
            for i in range(n):
                if( grid[i][j] == "E" ):
                    runningSum += 1
                elif( grid[i][j] == "W" ):
                    runningSum = 0
                else:
                    dp[i][j][2] = runningSum

        # bottom to top
        for j in range(m):
            runningSum = 0
            for i in range(n-1, -1, -1):
                if( grid[i][j] == "E" ):
                    runningSum += 1
                elif( grid[i][j] == "W" ):
                    runningSum = 0
                else:
                    dp[i][j][3] = runningSum

        ans = 0
        for i in range(n):
            for j in range(m):
                if(grid[i][j] == "0"):
                    ans = max( ans, sum(dp[i][j]) )
        return ans

class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -> int:
        if len(grid) == 0:
            return 0

        rows, cols = len(grid), len(grid[0])

        max_count = 0
        row_hits = 0
        col_hits = [0] * cols

        for row in range(0, rows):
            for col in range(0, cols):
                # reset the hits on the row, if necessary.
                if col == 0 or grid[row][col - 1] == 'W':
                    row_hits = 0
                    for k in range(col, cols):
                        if grid[row][k] == 'W':
                            # stop the scan when we hit the wall.
                            break
                        elif grid[row][k] == 'E':
                            row_hits += 1

                # reset the hits on the col, if necessary.
                if row == 0 or grid[row - 1][col] == 'W':
                    col_hits[col] = 0
                    for k in range(row, rows):
                        if grid[k][col] == 'W':
                            break
                        elif grid[k][col] == 'E':
                            col_hits[col] += 1

                # count the hits for each empty cell.
                if grid[row][col] == '0':
                    total_hits = row_hits + col_hits[col]
                    max_count = max(max_count, total_hits)

        return max_count
```

### [289\. Game of Life :fire:](https://leetcode.com/problems/game-of-life/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Matrix](https://leetcode.com/tag/matrix/), [Simulation](https://leetcode.com/tag/simulation/)


According to : "The **Game of Life**, also known simply as **Life**, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."

The board is made up of an `m x n` grid of cells, where each cell has an initial state: **live** (represented by a `1`) or **dead** (represented by a `0`). Each cell interacts with its (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.
2.  Any live cell with two or three live neighbors lives on to the next generation.
3.  Any live cell with more than three live neighbors dies, as if by over-population.
4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return _the next state_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg)

```
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg)

```
Input: board = [[1,1],[1,0]]
Output: [[1,1],[1,1]]
```

**Constraints:**

*   `m == board.length`
*   `n == board[i].length`
*   `1 <= m, n <= 25`
*   `board[i][j]` is `0` or `1`.

**Follow up:**

*   Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.
*   In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?


#### Solution

Language: **Python**

```python
def gameOfLife(board):
    m, n = len(board), len(board[0])
    result = [[0] * n for _ in range(m)]
    for i in range(m):
        for j in range(n):
            directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [1, 1], [-1, -1], [-1, 1], [1, -1]]
            live_neighbor = 0
            for direction in directions:
                next_i, next_j = i + direction[0], j + direction[1]
                if 0 <= next_i < m and 0 <= next_j < n and board[next_i][next_j] == 1:
                    live_neighbor += 1
            if board[i][j] == 1 and live_neighbor <= 2:
                result[i][j] = 0
            if board[i][j] == 1 and 2 <= live_neighbor <= 3:
                result[i][j] = 1
            if board[i][j] == 1 and live_neighbor > 3:
                result[i][j] = 0
            if board[i][j] == 0 and live_neighbor == 3:
                result[i][j] = 1
    return result

gameOfLife(board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]])

# O(1) space
class Solution(object):
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        # original | new | state
        #     0    |  0  |   0
        #     1    |  0  |   1
        #     0    |  1  |   2
        #     1    |  1  |   3
        m, n = len(board), len(board[0])
        def countNeighbors(r, c):
            nei = 0
            for i in range(r - 1, r + 2):
                for j in range(c - 1, c + 2):
                    if i in range(m) and j in range(n) and board[i][j] in [1, 3]:
                        nei += 1
            return nei

        # original -> state
        for r in range(m):
            for c in range(n):
                nei = countNeighbors(r, c)
                if board[r][c]:
                    if nei in [2, 3]:
                        board[r][c] = 3
                else
                    if nei == 3:
                        board[r][c] = 2

        # state -> new
        for r in range(m):
            for c in range(n):
                if board[r][c] == 1:
                    board[r][c] = 0
                if board[r][c] in [2, 3]:
                    board[r][c] = 1
```

### [54\. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Matrix](https://leetcode.com/tag/matrix/), [Simulation](https://leetcode.com/tag/simulation/)


Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

**Constraints:**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= m, n <= 10`
*   `-100 <= matrix[i][j] <= 100`


#### Solution

Language: **Python**

```python
def spiralOrder(matrix):
    row_start = 0; col_start = 0
    row_end = len(matrix); col_end = len(matrix[0])
    result = []

    while row_start < row_end and col_start < col_end:
        for j in range(col_start, col_end) :
            result.append(matrix[row_start][j])
        row_start += 1

        for i in range(row_start, row_end) :
            result.append(matrix[i][col_end - 1])
        col_end -= 1

        if not (row_start < row_end and col_start < col_end):
            break

        for j in range(col_end - 1, col_start - 1, -1) :
            result.append(matrix[row_end - 1][j])
        row_end -= 1

        for i in range(row_end - 1, row_start - 1, -1) :
            result.append(matrix[i][col_start])
        col_start += 1
    return result

if __name__ == '__main__':
    matrix = [[ 1, 2, 3 ],
              [ 4, 5, 6 ],
              [ 7, 8, 9 ]]
    spiralOrder(matrix)
```

### [36\. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Matrix](https://leetcode.com/tag/matrix/)


Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:

1.  Each row must contain the digits `1-9` without repetition.
2.  Each column must contain the digits `1-9` without repetition.
3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.

**Note:**

*   A Sudoku board (partially filled) could be valid but is not necessarily solvable.
*   Only the filled cells need to be validated according to the mentioned rules.

**Example 1:**

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

```
Input: board =
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: true
```

**Example 2:**

```
Input: board =
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8\. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
```

**Constraints:**

*   `board.length == 9`
*   `board[i].length == 9`
*   `board[i][j]` is a digit `1-9` or `'.'`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def isValidSudoku(self, board):
        """
        :type board: List[List[str]]
        :rtype: bool
        """
        cols = collections.defaultdict(set)
        rows = collections.defaultdict(set)
        squares = collections.defaultdict(set) # key = (r /3, c /3)

        for r in range(9):
            for c in range(9):
                if board[r][c] == ".":
                    continue
                if (board[r][c] in rows[r] or
                    board[r][c] in cols[c] or
                    board[r][c] in squares[(r // 3, c // 3)]):
                    return False
                cols[c].add(board[r][c])
                rows[r].add(board[r][c])
                squares[(r // 3, c // 3)].add(board[r][c])

        return True

# old solution
def isValidSudoku(board):
    for i in range(9):
        lookup_row = {}
        lookup_col = {}
        for j in range(9):
            if board[i][j] != '.':
                if board[i][j] in lookup_row or not 1 <= int(board[i][j]) <= 9:
                    return False
                lookup_row[board[i][j]] = 1
            if board[j][i] != '.':
                if board[j][i] in lookup_col or not 1 <= int(board[j][i]) <= 9:
                    return False
                lookup_col[board[j][i]] = 1

    for i in range(0, 9, 3):
        for j in range(0, 9, 3):
            if not check(i, j, board):
                return False

    return True

def check(x, y, board):
    lookup = {}
    for i in range(x, x + 3):
        for j in range(y, y + 3):
            if board[i][j] != '.':
                if board[i][j] in lookup or not 1 <= int(board[i][j]) <= 9:
                    return False
            lookup[board[i][j]] = 1
    return True

if __name__ == '__main__':
  board = [
    ["8","3",".",".","7",".",".",".","."],
    ["6",".",".","1","9","5",".",".","."],
    [".","9","8",".",".",".",".","6","."],
    ["8",".",".",".","6",".",".",".","3"],
    ["4",".",".","8",".","3",".",".","1"],
    ["7",".",".",".","2",".",".",".","6"],
    [".","6",".",".",".",".","2","8","."],
    [".",".",".","4","1","9",".",".","5"],
    [".",".",".",".","8",".",".","7","9"]
    ]
  isValidSudoku(board)    
  board = [
    ["5","3",".",".","7",".",".",".","."],
    ["6",".",".","1","9","5",".",".","."],
    [".","9","8",".",".",".",".","6","."],
    ["8",".",".",".","6",".",".",".","3"],
    ["4",".",".","8",".","3",".",".","1"],
    ["7",".",".",".","2",".",".",".","6"],
    [".","6",".",".",".",".","2","8","."],
    [".",".",".","4","1","9",".",".","5"],
    [".",".",".",".","8",".",".","7","9"]
  ]
  isValidSudoku(board)    
```

### [228\. Summary Ranges](https://leetcode.com/problems/summary-ranges/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/)


You are given a **sorted unique** integer array `nums`.

Return _the **smallest sorted** list of ranges that **cover all the numbers in the array exactly**_. That is, each element of `nums` is covered by exactly one of the ranges, and there is no integer `x` such that `x` is in one of the ranges but not in `nums`.

Each range `[a,b]` in the list should be output as:

*   `"a->b"` if `a != b`
*   `"a"` if `a == b`

**Example 1:**

```
Input: nums = [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
Explanation: The ranges are:
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
```

**Example 2:**

```
Input: nums = [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
Explanation: The ranges are:
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
```

**Example 3:**

```
Input: nums = []
Output: []
```

**Example 4:**

```
Input: nums = [-1]
Output: ["-1"]
```

**Example 5:**

```
Input: nums = [0]
Output: ["0"]
```

**Constraints:**

*   `0 <= nums.length <= 20`
*   `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`
*   All the values of `nums` are **unique**.
*   `nums` is sorted in ascending order.


#### Solution

Language: **Python**

```python
def summaryRanges(self, nums):
    if not nums:
        return []
    res, i, start = [], 0, 0
    while i < len(nums)-1:
        if nums[i]+1 != nums[i+1]:
            res.append(self.printRange(nums[start], nums[i]))
            start = i+1
        i += 1
    res.append(self.printRange(nums[start], nums[i]))
    return res

def printRange(self, l, r):
    if l == r:
        return str(l)
    else:
        return str(l) + "->" + str(r)
```

### [2006\. Count Number of Pairs With Absolute Difference K](https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/)


Given an integer array `nums` and an integer `k`, return _the number of pairs_ `(i, j)` _where_ `i < j` _such that_ `|nums[i] - nums[j]| == k`.

The value of `|x|` is defined as:

*   `x` if `x >= 0`.
*   `-x` if `x < 0`.

**Example 1:**

```
Input: nums = [1,2,2,1], k = 1
Output: 4
Explanation: The pairs with an absolute difference of 1 are:
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
```

**Example 2:**

```
Input: nums = [1,3], k = 3
Output: 0
Explanation: There are no pairs with an absolute difference of 3.
```

**Example 3:**

```
Input: nums = [3,2,1,5,4], k = 2
Output: 3
Explanation: The pairs with an absolute difference of 2 are:
- [3,2,1,5,4]
- [3,2,1,5,4]
- [3,2,1,5,4]
```

**Constraints:**

*   `1 <= nums.length <= 200`
*   `1 <= nums[i] <= 100`
*   `1 <= k <= 99`


#### Solution

Language: **Python**

```python
class Solution(object):
    def countKDifference(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        seen = defaultdict(int)
        counter = 0
        for num in nums:
            tmp, tmp2 = num - k, num + k
            if tmp in seen:
                counter += seen[tmp]
            if tmp2 in seen:
                counter += seen[tmp2]

            seen[num] += 1

        return counter
```

### [2017\. Grid Game](https://leetcode.com/problems/grid-game/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Matrix](https://leetcode.com/tag/matrix/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/)


You are given a **0-indexed** 2D array `grid` of size `2 x n`, where `grid[r][c]` represents the number of points at position `(r, c)` on the matrix. Two robots are playing a game on this matrix.

Both robots initially start at `(0, 0)` and want to reach `(1, n-1)`. Each robot may only move to the **right** (`(r, c)` to `(r, c + 1)`) or **down** (`(r, c)` to `(r + 1, c)`).

At the start of the game, the **first** robot moves from `(0, 0)` to `(1, n-1)`, collecting all the points from the cells on its path. For all cells `(r, c)` traversed on the path, `grid[r][c]` is set to `0`. Then, the **second** robot moves from `(0, 0)` to `(1, n-1)`, collecting the points on its path. Note that their paths may intersect with one another.

The **first** robot wants to **minimize** the number of points collected by the **second** robot. In contrast, the **second** robot wants to **maximize** the number of points it collects. If both robots play **optimally**, return _the **number of points** collected by the **second** robot._

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/09/08/a1.png)

```
Input: grid = [[2,5,4],[1,5,1]]
Output: 4
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 0 + 4 + 0 = 4 points.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/09/08/a2.png)

```
Input: grid = [[3,3,1],[8,5,2]]
Output: 4
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 3 + 1 + 0 = 4 points.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/09/08/a3.png)

```
Input: grid = [[1,3,1,15],[1,3,3,1]]
Output: 7
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.
```

**Constraints:**

*   `grid.length == 2`
*   `n == grid[r].length`
*   `1 <= n <= 5 * 10<sup>4</sup>`
*   `1 <= grid[r][c] <= 10<sup>5</sup>`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/grid-game/discuss/1486340/C%2B%2BJavaPython-Robot1-Minimize-TopSum-and-BottomSum-of-Robot-2-Picture-Explained)

```python
class Solution(object):
    def gridGame(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        n = len(grid[0])
        ans = float('inf')
        topSum = sum(grid[0])
        bottomSum = 0

        for i in range(n):
            topSum -= grid[0][i]
            ans = min(ans, max(topSum, bottomSum))
            bottomSum += grid[1][i]

        return ans
```

## Queue
### [239\. Sliding Window Maximum :rainbow:](https://leetcode.com/problems/sliding-window-maximum/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Queue](https://leetcode.com/tag/queue/), [Sliding Window](https://leetcode.com/tag/sliding-window/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Monotonic Queue](https://leetcode.com/tag/monotonic-queue/)


You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return _the max sliding window_.

**Example 1:**

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation:
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

**Example 3:**

```
Input: nums = [1,-1], k = 1
Output: [1,-1]
```

**Example 4:**

```
Input: nums = [9,11], k = 2
Output: [11]
```

**Example 5:**

```
Input: nums = [4,-2], k = 2
Output: [4]
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
*   `1 <= k <= nums.length`


#### Solution

Language: **Python**

```python
from collections import deque

def maxSlidingWindow(nums, k):
    dq = deque()
    result = []
    for i, num in enumerate(nums):
        if dq and dq[0][0] + k == i:
            dq.popleft()
        while dq and dq[-1][1] < num:
            dq.pop()
        dq.append([i, num])
        if i >= k - 1:
            result.append(dq[0][1])
    return result

maxSlidingWindow(nums = [1,3,-1,-3,5,3,6,7], k = 3)   
maxSlidingWindow(nums = [9,10,9,-7,-4,-8,2,-6], k = 5)           
```

### [1696\. Jump Game VI :fire:](https://leetcode.com/problems/jump-game-vi/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Queue](https://leetcode.com/tag/queue/), [Sliding Window](https://leetcode.com/tag/sliding-window/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Monotonic Queue](https://leetcode.com/tag/monotonic-queue/)


You are given a **0-indexed** integer array `nums` and an integer `k`.

You are initially standing at index `0`. In one move, you can jump at most `k` steps forward without going outside the boundaries of the array. That is, you can jump from index `i` to any index in the range `[i + 1, min(n - 1, i + k)]` **inclusive**.

You want to reach the last index of the array (index `n - 1`). Your **score** is the **sum** of all `nums[j]` for each index `j` you visited in the array.

Return _the **maximum score** you can get_.

**Example 1:**

```
Input: nums = [1,-1,-2,4,-7,3], k = 2
Output: 7
Explanation: You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.
```

**Example 2:**

```
Input: nums = [10,-5,-2,4,0,3], k = 3
Output: 17
Explanation: You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17.
```

**Example 3:**

```
Input: nums = [1,-5,-20,4,-1,3,-6,-3], k = 2
Output: 0
```

**Constraints:**

*   `1 <= nums.length, k <= 10<sup>5</sup>`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
def maxResult(nums, k):
    i = 0
    score = 0
    n = len(nums)
    while i < n:
        score += nums[i]
        if i == n - 1:
            break
        next_max = float('-inf')
        for j in range(i + 1, min(i + k + 1, n)):
            if nums[j] > next_max:
                next_max = nums[j]
                i = j
    return score

maxResult(nums = [1,-1,-2,4,-7,3], k = 2)

def maxResult(self, nums: List[int], k: int) -> int:
    if not nums:
        return 0

    dp = [float('-inf')]*len(nums)
    dp[0] = nums[0]

    for i in range(len(nums)):
        for j in range(max(i-k,0),i):
            dp[i] = max(dp[j]+nums[i],dp[i])

    #print(dp)
    return dp[-1]

import collections
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        if not nums:
            return 0

        dp = [float('-inf')]*len(nums)
        dp[0] = nums[0]
        dq = collections.deque()
        dq.append(0)

        for i in range(1,len(nums)):
            # similar to liding window maximum
            while dq and dq[0]<i-k:
                dq.popleft()
            dp[i] = nums[i] + dp[dq[0]]
            while dq and dp[dq[-1]]<=dp[i]:
                dq.pop()
            dq.append(i)
        #print(dp)
        return dp[-1]
```

### [362\. Design Hit Counter :rainbow:](https://leetcode.com/problems/design-hit-counter/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Binary Search](https://leetcode.com/tag/binary-search/), [Design](https://leetcode.com/tag/design/), [Queue](https://leetcode.com/tag/queue/)


Design a hit counter which counts the number of hits received in the past `5` minutes (i.e., the past `300` seconds).

Your system should accept a `timestamp` parameter (**in seconds** granularity), and you may assume that calls are being made to the system in chronological order (i.e., `timestamp` is monotonically increasing). Several hits may arrive roughly at the same time.

Implement the `HitCounter` class:

*   `HitCounter()` Initializes the object of the hit counter system.
*   `void hit(int timestamp)` Records a hit that happened at `timestamp` (**in seconds**). Several hits may happen at the same `timestamp`.
*   `int getHits(int timestamp)` Returns the number of hits in the past 5 minutes from `timestamp` (i.e., the past `300` seconds).

**Example 1:**

```
Input
["HitCounter", "hit", "hit", "hit", "getHits", "hit", "getHits", "getHits"]
[[], [1], [2], [3], [4], [300], [300], [301]]
Output
[null, null, null, null, 3, null, 4, 3]

Explanation
HitCounter hitCounter = new HitCounter();
hitCounter.hit(1);       // hit at timestamp 1.
hitCounter.hit(2);       // hit at timestamp 2.
hitCounter.hit(3);       // hit at timestamp 3.
hitCounter.getHits(4);   // get hits at timestamp 4, return 3.
hitCounter.hit(300);     // hit at timestamp 300.
hitCounter.getHits(300); // get hits at timestamp 300, return 4.
hitCounter.getHits(301); // get hits at timestamp 301, return 3.
```

**Constraints:**

*   `1 <= timestamp <= 2 * 10<sup>9</sup>`
*   All the calls are being made to the system in chronological order (i.e., `timestamp` is monotonically increasing).
*   At most `300` calls will be made to `hit` and `getHits`.

**Follow up:** What if the number of hits per second could be huge? Does your design scale?


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/design-hit-counter/solution/)
```python
from collections import deque
class HitCounter(object):
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.counter = deque()

    def hit(self, timestamp):
        """
        Record a hit.
        @param timestamp - The current timestamp (in seconds granularity).
        :type timestamp: int
        :rtype: void
        """
        self.counter.append(timestamp)

    def getHits(self, timestamp):
        """
        Return the number of hits in the past 5 minutes.
        @param timestamp - The current timestamp (in seconds granularity).
        :type timestamp: int
        :rtype: int
        """
        while self.counter and timestamp -self.counter[0] >= 300:
            self.counter.popleft()
        return len(self.counter)
```
* [](https://leetcode.com/problems/design-hit-counter/discuss/83511/Python-solution-with-detailed-explanation)
* The third solution creates an array of 300 elements. Every element of the array comprises of `[frequency, timestamp]`.
* Timestamp 1 maps to index 0. Timestamp 100 maps to index 99.
* Use modulo mathematics to update it. hit: O(1). get_hit: O(300). This solution will scale perfectly!

```Python
class HitCounter:
    def __init__(self):
        self.hits = [(0, 0)] * 300

    def hit(self, timestamp: int) -> None:
        i = (timestamp-1) % 300
        t, c = self.hits[i]

        if timestamp - t < 300:
            self.hits[i] = (timestamp, c+1)
        else:
            self.hits[i] = (timestamp, 1)

    def getHits(self, timestamp: int) -> int:
        count = 0
        for t, c in self.hits:
            if timestamp - t < 300:
                count += c
        return count
```

### [379\. Design Phone Directory :rainbow:](https://leetcode.com/problems/design-phone-directory/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Linked List](https://leetcode.com/tag/linked-list/), [Design](https://leetcode.com/tag/design/), [Queue](https://leetcode.com/tag/queue/)


Design a phone directory that initially has `maxNumbers` empty slots that can store numbers. The directory should store numbers, check if a certain slot is empty or not, and empty a given slot.

Implement the `PhoneDirectory` class:

*   `PhoneDirectory(int maxNumbers)` Initializes the phone directory with the number of available slots `maxNumbers`.
*   `int get()` Provides a number that is not assigned to anyone. Returns `-1` if no number is available.
*   `bool check(int number)` Returns `true` if the slot `number` is available and `false` otherwise.
*   `void release(int number)` Recycles or releases the slot `number`.

**Example 1:**

```
Input
["PhoneDirectory", "get", "get", "check", "get", "check", "release", "check"]
[[3], [], [], [2], [], [2], [2], [2]]
Output
[null, 0, 1, true, 2, false, null, true]

Explanation
PhoneDirectory phoneDirectory = new PhoneDirectory(3);
phoneDirectory.get();      // It can return any available phone number. Here we assume it returns 0.
phoneDirectory.get();      // Assume it returns 1.
phoneDirectory.check(2);   // The number 2 is available, so return true.
phoneDirectory.get();      // It returns 2, the only number that is left.
phoneDirectory.check(2);   // The number 2 is no longer available, so return false.
phoneDirectory.release(2); // Release number 2 back to the pool.
phoneDirectory.check(2);   // Number 2 is available again, return true.
```

**Constraints:**

*   `1 <= maxNumbers <= 10<sup>4</sup>`
*   `0 <= number < maxNumbers`
*   At most `2 * 10<sup>4</sup>` calls will be made to `get`, `check`, and `release`.


#### Solution

Language: **Python**

```python
class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        """
        Initialize your data structure here
        @param maxNumbers - The maximum numbers that can be stored in the phone directory.
        """
        self.maxnums = maxNumbers
        self.nums = collections.deque([])
        for elt in range(self.maxnums):
            self.nums.append(elt)
        self.count = collections.Counter(self.nums)


    def get(self) -> int:
        """
        Provide a number which is not assigned to anyone.
        @return - Return an available number. Return -1 if none is available.
        """
        if self.nums:
            num = self.nums.popleft()
            self.count[num] -= 1
            return num
        else:
            return -1



    def check(self, number: int) -> bool:
        """
        Check if a number is available or not.
        """
        if number in self.count and self.count[number] > 0:
            return True
        return False


    def release(self, number: int) -> None:
        """
        Recycle or release a number.
        """
        if number not in self.count or self.count[number] == 0:
            self.nums.append(number)
            self.count[number] += 1
```

## Stack
### [1249\. Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/)


Given a string <font face="monospace" style="display: inline;">s</font> of `'('` , `')'` and lowercase English characters.

Your task is to remove the minimum number of parentheses ( `'('` or `')'`, in any positions ) so that the resulting _parentheses string_ is valid and return **any** valid string.

Formally, a _parentheses string_ is valid if and only if:

*   It is the empty string, contains only lowercase characters, or
*   It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid strings, or
*   It can be written as `(A)`, where `A` is a valid string.

**Example 1:**

```
Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
```

**Example 2:**

```
Input: s = "a)b(c)d"
Output: "ab(c)d"
```

**Example 3:**

```
Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.
```

**Example 4:**

```
Input: s = "(a(b(c)d)"
Output: "a(b(c)d)"
```

**Constraints:**

*   `1 <= s.length <= 10<sup>5</sup>`
*   `s[i]` is either`'('` , `')'`, or lowercase English letter`.`


#### Solution

Language: **Python**

```python
def minRemoveToMakeValid(s):
    stack = []
    dict_use = {}
    for i, chr in enumerate(s):
        if chr == '(':
            stack.append(i)
        if chr == ')' and stack:
            dict_use[i] = True
            dict_use[stack[-1]] = True
            stack.pop()

    result = ''
    for i, chr in enumerate(s):
        if chr == '(' or chr == ')':
            if i in dict_use:
                result += chr
        else:
            result += chr
    return result    

def minRemoveToMakeValid(self, s: str) -> str:
    s = list(s)
    stack = []
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        elif char == ')':
            if stack:
                stack.pop()
            else:
                s[i] = ''
    while stack:
        s[stack.pop()] = ''
    return ''.join(s)
```

### [636\. Exclusive Time of Functions](https://leetcode.com/problems/exclusive-time-of-functions/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Stack](https://leetcode.com/tag/stack/)


On a **single-threaded** CPU, we execute a program containing `n` functions. Each function has a unique ID between `0` and `n-1`.

Function calls are **stored in a** : when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is **the current function being executed**. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.

You are given a list `logs`, where `logs[i]` represents the `i<sup>th</sup>` log message formatted as a string `"{function_id}:{"start" | "end"}:{timestamp}"`. For example, `"0:start:3"` means a function call with function ID `0` **started at the beginning** of timestamp `3`, and `"1:end:2"` means a function call with function ID `1` **ended at the end** of timestamp `2`. Note that a function can be called **multiple times, possibly recursively**.

A function's **exclusive time** is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for `2` time units and another call executing for `1` time unit, the **exclusive time** is `2 + 1 = 3`.

Return _the **exclusive time** of each function in an array, where the value at the_ `i<sup>th</sup>` _index represents the exclusive time for the function with ID_ `i`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/04/05/diag1b.png)

```
Input: n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
Output: [3,4]
Explanation:
Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.
Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.
Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.
So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.
```

**Example 2:**

```
Input: n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]
Output: [8]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls itself again.
Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.
Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.
So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.
```

**Example 3:**

```
Input: n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]
Output: [7,1]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls function 1.
Function 1 starts at the beginning of time 6, executes 1 units of time, and ends at the end of time 6.
Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time.
So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.
```

**Example 4:**

```
Input: n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:7","1:end:7","0:end:8"]
Output: [8,1]
```

**Example 5:**

```
Input: n = 1, logs = ["0:start:0","0:end:0"]
Output: [1]
```

**Constraints:**

*   `1 <= n <= 100`
*   `1 <= logs.length <= 500`
*   `0 <= function_id < n`
*   `0 <= timestamp <= 10<sup>9</sup>`
*   No two start events will happen at the same timestamp.
*   No two end events will happen at the same timestamp.
*   Each function has an `"end"` log for each `"start"` log.


#### Solution

Language: **Python**

```python
def exclusiveTime(n, logs):
    result = [0] * n
    stack = []
    prev_time = 0
    for log in logs:
        id, type, time = log.split(':')
        if type == 'start':
            if stack:
                result[stack[-1]] += int(time) - prev_time
            stack.append(int(id))
            prev_time = int(time)
        else:
            result[stack[-1]] += int(time) - prev_time + 1
            stack.pop()
            prev_time = int(time) + 1
    return result

exclusiveTime(n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"])
exclusiveTime(n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"])
exclusiveTime(n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"])
exclusiveTime(n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:7","1:end:7","0:end:8"])
exclusiveTime(n = 1, logs = ["0:start:0","0:end:0"])
```

### [71\. Simplify Path](https://leetcode.com/problems/simplify-path/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/)


Given a string `path`, which is an **absolute path** (starting with a slash `'/'`) to a file or directory in a Unix-style file system, convert it to the simplified **canonical path**.

In a Unix-style file system, a period `'.'` refers to the current directory, a double period `'..'` refers to the directory up a level, and any multiple consecutive slashes (i.e. `'//'`) are treated as a single slash `'/'`. For this problem, any other format of periods such as `'...'` are treated as file/directory names.

The **canonical path** should have the following format:

*   The path starts with a single slash `'/'`.
*   Any two directories are separated by a single slash `'/'`.
*   The path does not end with a trailing `'/'`.
*   The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period `'.'` or double period `'..'`)

Return _the simplified **canonical path**_.

**Example 1:**

```
Input: path = "/home/"
Output: "/home"
Explanation: Note that there is no trailing slash after the last directory name.
```

**Example 2:**

```
Input: path = "/../"
Output: "/"
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.
```

**Example 3:**

```
Input: path = "/home//foo/"
Output: "/home/foo"
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.
```

**Example 4:**

```
Input: path = "/a/./b/../../c/"
Output: "/c"
```

**Constraints:**

*   `1 <= path.length <= 3000`
*   `path` consists of English letters, digits, period `'.'`, slash `'/'` or `'_'`.
*   `path` is a valid absolute Unix path.


#### Solution

Language: **Python**

```python
def simplifyPath(path):
    path = path.split('/')
    stack = []
    for s in path:
        if (s == '.') or (s == '') or (not stack and s == '..'):
            continue
        elif s == '..' and stack:
            stack.pop()
        else:
            stack.append(s)
    return '/' + '/'.join(stack)

simplifyPath(path = "/home/")
simplifyPath(path = "/../")
simplifyPath(path = "/home//foo/")
simplifyPath(path = "/a/./b/../../c/")
```

### [227\. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/)


Given a string `s` which represents an expression, _evaluate this expression and return its value_.

The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate results will be in the range of `[-2<sup>31</sup>, 2<sup>31</sup> - 1]`.

**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.

**Example 1:**

```
Input: s = "3+2*2"
Output: 7
```

**Example 2:**

```
Input: s = " 3/2 "
Output: 1
```

**Example 3:**

```
Input: s = " 3+5 / 2 "
Output: 5
```

**Constraints:**

*   `1 <= s.length <= 3 * 10<sup>5</sup>`
*   `s` consists of integers and operators `('+', '-', '*', '/')` separated by some number of spaces.
*   `s` represents **a valid expression**.
*   All the integers in the expression are non-negative integers in the range `[0, 2<sup>31</sup> - 1]`.
*   The answer is **guaranteed** to fit in a **32-bit integer**.


#### Solution

Language: **Python**


```python
def calculate(s):
    stack = []
    pre_op = '+'
    num = 0
    for i, each in enumerate(s):
        if each.isdigit():
            num = 10 * num + int(each)
        if i == len(s) - 1 or each in '+-*/':
            if pre_op == '+':
                stack.append(num)
            elif pre_op == '-':
                stack.append(-num)
            elif pre_op == '*':
                stack.append(stack.pop() * num)
            elif pre_op == '/':
                top = stack.pop()
                if top < 0:
                    stack.append(int(top / num))
                else:
                    stack.append(top // num)
            pre_op = each
            num = 0
    return sum(stack)

calculate("3+2*2")
calculate(" 3/2 ")
calculate(" 3+5 / 2 ")
```

### [20\. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

Difficulty: **Easy**  

Related Topics: [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/)


Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1.  Open brackets must be closed by the same type of brackets.
2.  Open brackets must be closed in the correct order.

**Example 1:**

```
Input: s = "()"
Output: true
```

**Example 2:**

```
Input: s = "()[]{}"
Output: true
```

**Example 3:**

```
Input: s = "(]"
Output: false
```

**Example 4:**

```
Input: s = "([)]"
Output: false
```

**Example 5:**

```
Input: s = "{[]}"
Output: true
```

**Constraints:**

*   `1 <= s.length <= 10<sup>4</sup>`
*   `s` consists of parentheses only `'()[]{}'`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        hash_map = {'(': ')', '[': ']', '{': '}'}
        stack = []
        for item in s:
            if item in hash_map:
                stack.append(hash_map[item])
            else:
                if not stack or stack.pop() != item:
                    return False
        return not stack
```

### [921\. Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/), [Greedy](https://leetcode.com/tag/greedy/)


A parentheses string is valid if and only if:

*   It is the empty string,
*   It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid strings, or
*   It can be written as `(A)`, where `A` is a valid string.

You are given a parentheses string `s`. In one move, you can insert a parenthesis at any position of the string.

*   For example, if `s = "()))"`, you can insert an opening parenthesis to be `"(**(**)))"` or a closing parenthesis to be `"())**)**)"`.

Return _the minimum number of moves required to make_ `s` _valid_.

**Example 1:**

```
Input: s = "())"
Output: 1
```

**Example 2:**

```
Input: s = "((("
Output: 3
```

**Example 3:**

```
Input: s = "()"
Output: 0
```

**Example 4:**

```
Input: s = "()))(("
Output: 4
```

**Constraints:**

*   `1 <= s.length <= 1000`
*   `s[i]` is either `'('` or `')'`.


#### Solution

Language: **Python**

```python
def minAddToMakeValid(s):
    left_stack = []
    right_stack = []
    for string in s:
        if string == '(':
            left_stack.append(string)
        elif string == ')' and left_stack:
            left_stack.pop()
        else:
            right_stack.append(string)
    return len(left_stack) + len(right_stack)

class Solution:
    def minAddToMakeValid(self, s: str) -> int:
        left_stack = 0
        right_stack = 0
        for string in s:
            if string == '(':
                left_stack += 1
            elif string == ')' and left_stack:
                left_stack -= 1
            else:
                right_stack += 1
        return left_stack + right_stack

minAddToMakeValid(s = "())")
minAddToMakeValid(s = "(((")
minAddToMakeValid(s = "()")
minAddToMakeValid(s = "()))((")
```

### [32\. Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)

Difficulty: **Hard**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Stack](https://leetcode.com/tag/stack/)


Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

**Example 1:**

```
Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".
```

**Example 2:**

```
Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".
```

**Example 3:**

```
Input: s = ""
Output: 0
```

**Constraints:**

*   `0 <= s.length <= 3 * 10<sup>4</sup>`
*   `s[i]` is `'('`, or `')'`.


#### Solution

Language: **Python**

 Valid Parentheses  start  start i - start + 1  i - st.top() 

* [](https://leetcode.com/problems/longest-valid-parentheses/solution/)
```python
def longestValidParentheses(s):

    # stack, used to record index of parenthesis
    # initialized to -1 as dummy head for valid parentheses length computation
    stack = [-1]

    max_length = 0

    # linear scan each index and character in input string s
    for cur_idx, char in enumerate(s):

        if char == '(':

            # push when current char is (
            stack.append( cur_idx )

        else:

            # pop when current char is )
            stack.pop()

            if not stack:

                # stack is empty, push current index into stack
                stack.append( cur_idx )
            else:
                # stack is non-empty, update maximal valid parentheses length
                max_length = max(max_length, cur_idx - stack[-1])

    return max_length
```

### [224\. Basic Calculator :fire:](https://leetcode.com/problems/basic-calculator/)

Difficulty: **Hard**  

Related Topics: [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/), [Recursion](https://leetcode.com/tag/recursion/)


Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return _the result of the evaluation_.

**Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.

**Example 1:**

```
Input: s = "1 + 1"
Output: 2
```

**Example 2:**

```
Input: s = " 2-1 + 2 "
Output: 3
```

**Example 3:**

```
Input: s = "(1+(4+5+2)-3)+(6+8)"
Output: 23
```

**Constraints:**

*   `1 <= s.length <= 3 * 10<sup>5</sup>`
*   `s` consists of digits, `'+'`, `'-'`, `'('`, `')'`, and `' '`.
*   `s` represents a valid expression.
*   `'+'` is **not** used as a unary operation (i.e., `"+1"` and `"+(2 + 3)"` is invalid).
*   `'-'` could be used as a unary operation (i.e., `"-1"` and `"-(2 + 3)"` is valid).
*   There will be no two consecutive operators in the input.
*   Every number and running calculation will fit in a signed 32-bit integer.


#### Solution

Language: **Python**

solutions:
* 
* +-resnum0sign
* `(`ressignressign
* `)`
* 
```python
def calculate(self, s: str) -> int:
        res, num, sign = 0, 0, 1
        stack = []
        for c in s:
            if c.isdigit():
                num = 10 * num + int(c)
            elif c == "+" or c == "-":
                res = res + sign * num
                num = 0
                sign = 1 if c == "+" else -1
            elif c == "(":
                stack.append(res)
                stack.append(sign)
                res = 0
                sign = 1
            elif c == ")":
                res = res + sign * num
                num = 0
                res *= stack.pop()
                res += stack.pop()
        res = res + sign * num
        return res
```

 recursion
```Python
class Solution(object):
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        """
        def helper(s):
            stack = []
            sign = '+'
            num = 0

            while len(s) > 0:
                c = s.pop(0)
                if c.isdigit():
                    num = 10 * num + int(c)
                #  num
                if c == '(':
                    num = helper(s)

                if (not c.isdigit() and c != ' ') or len(s) == 0:
                    if sign == '+':
                        stack.append(num)
                    elif sign == '-':
                        stack.append(-num)
                    elif sign == '*':
                        stack[-1] = stack[-1] * num
                    elif sign == '/':
                        # python  0 
                        stack[-1] = int(stack[-1] / float(num))  
                    num = 0
                    sign = c
                # 
                if c == ')': break
            return sum(stack)
        return helper(list(s))
```
### [394\. Decode String](https://leetcode.com/problems/decode-string/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/), [Recursion](https://leetcode.com/tag/recursion/)


Given an encoded string, return its decoded string.

The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.

You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.

Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there won't be input like `3a` or `2[4]`.

**Example 1:**

```
Input: s = "3[a]2[bc]"
Output: "aaabcbc"
```

**Example 2:**

```
Input: s = "3[a2[c]]"
Output: "accaccacc"
```

**Example 3:**

```
Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"
```

**Example 4:**

```
Input: s = "abc3[cd]xyz"
Output: "abccdcdcdxyz"
```

**Constraints:**

*   `1 <= s.length <= 30`
*   `s` consists of lowercase English letters, digits, and square brackets `'[]'`.
*   `s` is guaranteed to be **a valid** input.
*   All the integers in `s` are in the range `[1, 300]`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def decodeString(self, s):
        """
        :type s: str
        :rtype: str
        """
        stack = []

        for i in range(len(s)):
            if s[i] != ']':
                stack.append(s[i])
            else:
                substr = ''
                while stack[-1] != '[':
                    substr = stack.pop() + substr
                stack.pop()

                num = ''
                while stack and stack[-1].isdigit():
                    num = stack.pop() + num
                stack.append(int(num) * substr)

        return ''.join(stack)
```

### [155\. Min Stack](https://leetcode.com/problems/min-stack/)

Difficulty: **Easy**  

Related Topics: [Stack](https://leetcode.com/tag/stack/), [Design](https://leetcode.com/tag/design/)


Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the `MinStack` class:

*   `MinStack()` initializes the stack object.
*   `void push(int val)` pushes the element `val` onto the stack.
*   `void pop()` removes the element on the top of the stack.
*   `int top()` gets the top element of the stack.
*   `int getMin()` retrieves the minimum element in the stack.

**Example 1:**

```
Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
```

**Constraints:**

*   `-2<sup>31</sup> <= val <= 2<sup>31</sup> - 1`
*   Methods `pop`, `top` and `getMin` operations will always be called on **non-empty** stacks.
*   At most `3 * 10<sup>4</sup>` calls will be made to `push`, `pop`, `top`, and `getMin`.


#### Solution

Language: **Python**

```python
class MinStack(object):

    def __init__(self):
        self.stack = []
        self.minstack = []

    def push(self, number):
        self.stack.append(number)
        if len(self.minstack) == 0 or number <= self.minstack[-1]:
            self.minstack.append(number)

    def pop(self):
        if self.stack[-1] == self.minstack[-1]:
            self.minstack.pop()
        return self.stack.pop()

    def top(self):
        if self.stack:
            return self.stack[-1]

    def min(self):
        return self.minstack[-1]

if __name__ == "__main__":
    minStack = MinStack()
    minStack.push(4)
    minStack.push(5)
    minStack.push(1)
    minStack.push(3)
    assert minStack.min() == 1
    minStack.pop()
    minStack.pop()
    assert minStack.top() == 5
```

### [716\. Max Stack](https://leetcode.com/problems/max-stack/)

Difficulty: **Easy**  

Related Topics: [Linked List](https://leetcode.com/tag/linked-list/), [Stack](https://leetcode.com/tag/stack/), [Design](https://leetcode.com/tag/design/), [Doubly-Linked List](https://leetcode.com/tag/doubly-linked-list/), [Ordered Set](https://leetcode.com/tag/ordered-set/)


Design a max stack data structure that supports the stack operations and supports finding the stack's maximum element.

Implement the `MaxStack` class:

*   `MaxStack()` Initializes the stack object.
*   `void push(int x)` Pushes element `x` onto the stack.
*   `int pop()` Removes the element on top of the stack and returns it.
*   `int top()` Gets the element on the top of the stack without removing it.
*   `int peekMax()` Retrieves the maximum element in the stack without removing it.
*   `int popMax()` Retrieves the maximum element in the stack and removes it. If there is more than one maximum element, only remove the **top-most** one.

**Example 1:**

```
Input
["MaxStack", "push", "push", "push", "top", "popMax", "top", "peekMax", "pop", "top"]
[[], [5], [1], [5], [], [], [], [], [], []]
Output
[null, null, null, null, 5, 5, 1, 5, 1, 5]

Explanation
MaxStack stk = new MaxStack();
stk.push(5);   // [5] the top of the stack and the maximum number is 5.
stk.push(1);   // [5, 1] the top of the stack is 1, but the maximum is 5.
stk.push(5);   // [5, 1, 5] the top of the stack is 5, which is also the maximum, because it is the top most one.
stk.top();     // return 5, [5, 1, 5] the stack did not change.
stk.popMax();  // return 5, [5, 1] the stack is changed now, and the top is different from the max.
stk.top();     // return 1, [5, 1] the stack did not change.
stk.peekMax(); // return 5, [5, 1] the stack did not change.
stk.pop();     // return 1, [5] the top of the stack and the max element is now 5.
stk.top();     // return 5, [5] the stack did not change.
```

**Constraints:**

*   `-10<sup>7</sup> <= x <= 10<sup>7</sup>`
*   At most `10<sup>4</sup>` calls will be made to `push`, `pop`, `top`, `peekMax`, and `popMax`.
*   There will be **at least one element** in the stack when `pop`, `top`, `peekMax`, or `popMax` is called.

**Follow up:** Could you come up with a solution that supports `O(1)` for each `top` call and `O(logn)` for each other call?

#### Solution

Language: **Python**

```python
class MaxStack(object):

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stk=[]
        self.maxstk=[]

    def push(self, x):
        """
        :type x: int
        :rtype: void
        """
        self.stk.append(x)
        if not self.maxstk:
            self.maxstk.append(x)
        else:
            self.maxstk.append(max(x,self.maxstk[-1]))

    def pop(self):
        """
        :rtype: int
        """
        self.maxstk.pop()
        return self.stk.pop()
    def top(self):
        """
        :rtype: int
        """
        return self.stk[-1]

    def peekMax(self):
        """
        :rtype: int
        """
        return self.maxstk[-1]

    def popMax(self):
        """
        :rtype: int
        """
        n=self.maxstk.pop()
        i=len(self.stk)-1
        tmp=[]
        while n!=self.stk[-1]:
            tmp.append(self.pop())
        ret=self.stk.pop()
        for i in xrange(len(tmp)-1,-1,-1):
            self.push(tmp[i])
        return ret
```

### [388\. Longest Absolute File Path :rainbow:](https://leetcode.com/problems/longest-absolute-file-path/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/)


Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:

![](https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg)

Here, we have `dir` as the only directory in the root. `dir` contains two subdirectories, `subdir1` and `subdir2`. `subdir1` contains a file `file1.ext` and subdirectory `subsubdir1`. `subdir2` contains a subdirectory `subsubdir2`, which contains a file `file2.ext`.

In text form, it looks like this (with  representing the tab character):

```
dir
 subdir1
  file1.ext
  subsubdir1
 subdir2
  subsubdir2
   file2.ext
```

If we were to write this representation in code, it will look like this: `"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"`. Note that the `'\n'` and `'\t'` are the new-line and tab characters.

Every file and directory has a unique **absolute path** in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by `'/'s`. Using the above example, the **absolute path** to `file2.ext` is `"dir/subdir2/subsubdir2/file2.ext"`. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form `name.extension`, where `name` and `extension` consist of letters, digits, and/or spaces.

Given a string `input` representing the file system in the explained format, return _the length of the **longest absolute path** to a **file** in the abstracted file system_. If there is no file in the system, return `0`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg)

```
Input: input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"
Output: 20
Explanation: We have only one file, and the absolute path is "dir/subdir2/file.ext" of length 20.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg)

```
Input: input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
Output: 32
Explanation: We have two files:
"dir/subdir1/file1.ext" of length 21
"dir/subdir2/subsubdir2/file2.ext" of length 32.
We return 32 since it is the longest absolute path to a file.
```

**Example 3:**

```
Input: input = "a"
Output: 0
Explanation: We do not have any files, just a single directory named "a".
```

**Example 4:**

```
Input: input = "file1.txt\nfile2.txt\nlongfile.txt"
Output: 12
Explanation: There are 3 files at the root directory.
Since the absolute path for anything at the root directory is just the name itself, the answer is "longfile.txt" with length 12.
```

**Constraints:**

*   `1 <= input.length <= 10<sup>4</sup>`
*   `input` may contain lowercase or uppercase English letters, a new line character `'\n'`, a tab character `'\t'`, a dot `'.'`, a space `' '`, and digits.


#### Solution

Language: **Python**

```python
class Solution:
    def lengthLongestPath(self, input: str) -> int:
        stack = [(-1, 0)]
        max_size = 0
        for p in input.split('\n'):
            depth = p.count('\t')
            p = p.replace('\t', '')
            while stack and stack[-1][0] >= depth:
                stack.pop()
            if '.' in p:
                max_size = max(max_size, stack[-1][1] + len(p))
            else:
                stack.append((depth, len(p) + 1 + stack[-1][1]))
        return max_size
```

### [84\. Largest Rectangle in Histogram :fire:](https://leetcode.com/problems/largest-rectangle-in-histogram/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Stack](https://leetcode.com/tag/stack/), [Monotonic Stack](https://leetcode.com/tag/monotonic-stack/)


Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return _the area of the largest rectangle in the histogram_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
Input: heights = [2,1,5,6,2,3]
Output: 10
Explanation: The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

```
Input: heights = [2,4]
Output: 4
```

**Constraints:**

*   `1 <= heights.length <= 10<sup>5</sup>`
*   `0 <= heights[i] <= 10<sup>4</sup>`


#### Solution

Language: **Python**

https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/28917/AC-Python-clean-solution-using-stack-76ms
```Python

def largestRectangleArea(self, height):
    height.append(0)
    stack = [-1]
    ans = 0
    for i in xrange(len(height)):
        while height[i] < height[stack[-1]]:
            h = height[stack.pop()]
            w = i - stack[-1] - 1
            ans = max(ans, h * w)
        stack.append(i)
    height.pop()
    return ans

height = [2,1,5,6,2,3]
```

### [85\. Maximal Rectangle :rainbow:](https://leetcode.com/problems/maximal-rectangle/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Stack](https://leetcode.com/tag/stack/), [Matrix](https://leetcode.com/tag/matrix/), [Monotonic Stack](https://leetcode.com/tag/monotonic-stack/)


Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

```
Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 6
Explanation: The maximal rectangle is shown in the above picture.
```

**Example 2:**

```
Input: matrix = []
Output: 0
```

**Example 3:**

```
Input: matrix = [["0"]]
Output: 0
```

**Example 4:**

```
Input: matrix = [["1"]]
Output: 1
```

**Example 5:**

```
Input: matrix = [["0","0"]]
Output: 0
```

**Constraints:**

*   `rows == matrix.length`
*   `cols == matrix[i].length`
*   `0 <= row, cols <= 200`
*   `matrix[i][j]` is `'0'` or `'1'`.


#### Solution

Language: **Python**

```python
def maximalRectangle(self, matrix):
    if not matrix or not matrix[0]:
        return 0
    n = len(matrix[0])
    height = [0] * (n + 1)
    ans = 0
    for row in matrix:
        for i in xrange(n):
            height[i] = height[i] + 1 if row[i] == '1' else 0
        stack = [-1]
        for i in xrange(n + 1):
            while height[i] < height[stack[-1]]:
                h = height[stack.pop()]
                w = i - 1 - stack[-1]
                ans = max(ans, h * w)
            stack.append(i)
    return ans
```

### [1472\. Design Browser History](https://leetcode.com/problems/design-browser-history/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Linked List](https://leetcode.com/tag/linked-list/), [Stack](https://leetcode.com/tag/stack/), [Design](https://leetcode.com/tag/design/), [Doubly-Linked List](https://leetcode.com/tag/doubly-linked-list/), [Data Stream](https://leetcode.com/tag/data-stream/)


You have a **browser** of one tab where you start on the `homepage` and you can visit another `url`, get back in the history number of `steps` or move forward in the history number of `steps`.

Implement the `BrowserHistory` class:

*   `BrowserHistory(string homepage)` Initializes the object with the `homepage` of the browser.
*   `void visit(string url)` Visits `url` from the current page. It clears up all the forward history.
*   `string back(int steps)` Move `steps` back in history. If you can only return `x` steps in the history and `steps > x`, you will return only `x` steps. Return the current `url` after moving back in history **at most** `steps`.
*   `string forward(int steps)` Move `steps` forward in history. If you can only forward `x` steps in the history and `steps > x`, you will forward only `x` steps. Return the current `url` after forwarding in history **at most** `steps`.

**Example:**

```
Input:
["BrowserHistory","visit","visit","visit","back","back","forward","visit","forward","back","back"]
[["leetcode.com"],["google.com"],["facebook.com"],["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]]
Output:
[null,null,null,null,"facebook.com","google.com","facebook.com",null,"linkedin.com","google.com","leetcode.com"]

Explanation:
BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
browserHistory.visit("google.com");       // You are in "leetcode.com". Visit "google.com"
browserHistory.visit("facebook.com");     // You are in "google.com". Visit "facebook.com"
browserHistory.visit("youtube.com");      // You are in "facebook.com". Visit "youtube.com"
browserHistory.back(1);                   // You are in "youtube.com", move back to "facebook.com" return "facebook.com"
browserHistory.back(1);                   // You are in "facebook.com", move back to "google.com" return "google.com"
browserHistory.forward(1);                // You are in "google.com", move forward to "facebook.com" return "facebook.com"
browserHistory.visit("linkedin.com");     // You are in "facebook.com". Visit "linkedin.com"
browserHistory.forward(2);                // You are in "linkedin.com", you cannot move forward any steps.
browserHistory.back(2);                   // You are in "linkedin.com", move back two steps to "facebook.com" then to "google.com". return "google.com"
browserHistory.back(7);                   // You are in "google.com", you can move back only one step to "leetcode.com". return "leetcode.com"
```

**Constraints:**

*   `1 <= homepage.length <= 20`
*   `1 <= url.length <= 20`
*   `1 <= steps <= 100`
*   `homepage` and `url` consist of  '.' or lower case English letters.
*   At most `5000` calls will be made to `visit`, `back`, and `forward`.


#### Solution

Language: **Python**

* [](https://blog.csdn.net/fuxuemingzhu/article/details/107001857)
* Time: O(1) for each method
* Space: O(N), where N is the most URLs we save
```
curr_viewidx
:
<1> BackBack,
<2> ForwardForward, 
<3> curr_view ,Visit,cache
```

```python
class BrowserHistory:

    def __init__(self, homepage: str):
        self.his = [homepage]
        self.cur = 0


    def visit(self, url: str) -> None:
        while self.his and len(self.his) - 1 > self.cur:
            self.his.pop()
        self.his.append(url)
        self.cur += 1


    def back(self, steps: int) -> str:
        self.cur -= min(self.cur, steps)
        return self.his[self.cur]


    def forward(self, steps: int) -> str:
        self.cur += steps
        self.cur = min(self.cur, len(self.his) - 1)
        return self.his[self.cur]

# Your BrowserHistory object will be instantiated and called as such:
# obj = BrowserHistory(homepage)
# obj.visit(url)
# param_2 = obj.back(steps)
# param_3 = obj.forward(steps)
```

### [1209\. Remove All Adjacent Duplicates in String II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/)


You are given a string `s` and an integer `k`, a `k` **duplicate removal** consists of choosing `k` adjacent and equal letters from `s` and removing them, causing the left and the right side of the deleted substring to concatenate together.

We repeatedly make `k` **duplicate removals** on `s` until we no longer can.

Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.

**Example 1:**

```
Input: s = "abcd", k = 2
Output: "abcd"
Explanation: There's nothing to delete.
```

**Example 2:**

```
Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation:
First delete "eee" and "ccc", get "ddbbbdaa"
Then delete "bbb", get "dddaa"
Finally delete "ddd", get "aa"
```

**Example 3:**

```
Input: s = "pbbcggttciiippooaais", k = 2
Output: "ps"
```

**Constraints:**

*   `1 <= s.length <= 10<sup>5</sup>`
*   `2 <= k <= 10<sup>4</sup>`
*   `s` only contains lower case English letters.


#### Solution

Language: **Python**

```python
def removeDuplicates(self, s, k):
    """
    :type s: str
    :type k: int
    :rtype: str
    """
    st = []  # pair of (character, frequence)
    for c in s:
        if st and st[-1][0] == c:
            st[-1][1] += 1  # Increase the frequency
        else:
            st.append([c, 1])
        if st[-1][1] == k:  # If reach enough k duplicate letters -> then remove
            st.pop()
    return "".join(c * f for c, f in st)

s = "deeedbbcccbdaa"; k = 3
```

### [1047\. Remove All Adjacent Duplicates In String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/)

Difficulty: **Easy**  

Related Topics: [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/)


You are given a string `s` consisting of lowercase English letters. A **duplicate removal** consists of choosing two **adjacent** and **equal** letters and removing them.

We repeatedly make **duplicate removals** on `s` until we no longer can.

Return _the final string after all such duplicate removals have been made_. It can be proven that the answer is **unique**.

**Example 1:**

```
Input: s = "abbaca"
Output: "ca"
Explanation:
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
```

**Example 2:**

```
Input: s = "azxxzy"
Output: "ay"
```

**Constraints:**

*   `1 <= s.length <= 10<sup>5</sup>`
*   `s` consists of lowercase English letters.


#### Solution

Language: **Python**

```Python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack = []
        for ch in s:
            if stack and stack[-1] == ch:
                stack.pop()
            else:
                stack.append(ch)
        return ''.join(stack)
```

### [150\. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Math](https://leetcode.com/tag/math/), [Stack](https://leetcode.com/tag/stack/)


Evaluate the value of an arithmetic expression in .

Valid operators are `+`, `-`, `*`, and `/`. Each operand may be an integer or another expression.

**Note** that division between two integers should truncate toward zero.

It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.

**Example 1:**

```
Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
```

**Example 2:**

```
Input: tokens = ["4","13","5","/","+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
```

**Example 3:**

```
Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

**Constraints:**

*   `1 <= tokens.length <= 10<sup>4</sup>`
*   `tokens[i]` is either an operator: `"+"`, `"-"`, `"*"`, or `"/"`, or an integer in the range `[-200, 200]`.


#### Solution

Language: **Python**

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token not in ['+', '-', '*', '/']:
            stack.append(token)
        else:
            num_r = int(stack.pop())
            num_l = int(stack.pop())
            if token == "+":
                stack.append(num_r + num_l)
            elif token == "-":
                stack.append(num_l - num_r)
            elif token == "*":
                stack.append(num_l * num_r)
            elif token == "/":
                if num_l * num_r < 0:
                    stack.append(-(abs(num_l) // abs(num_r)))
                else:
                    stack.append(num_l // num_r)
    return stack[0]
tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
evalRPN(tokens)        
```

### [1475\. Final Prices With a Special Discount in a Shop](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Stack](https://leetcode.com/tag/stack/), [Monotonic Stack](https://leetcode.com/tag/monotonic-stack/)


Given the array `prices` where `prices[i]` is the price of the `ith` item in a shop. There is a special discount for items in the shop, if you buy the `ith` item, then you will receive a discount equivalent to `prices[j]` where `j` is the **minimum** index such that `j > i` and `prices[j] <= prices[i]`, otherwise, you will not receive any discount at all.

_Return an array where the `ith` element is the final price you will pay for the `ith` item of the shop considering the special discount._

**Example 1:**

```
Input: prices = [8,4,6,2,3]
Output: [4,2,4,2,3]
Explanation:
For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.
For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.
For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.
For items 3 and 4 you will not receive any discount at all.
```

**Example 2:**

```
Input: prices = [1,2,3,4,5]
Output: [1,2,3,4,5]
Explanation: In this case, for all items, you will not receive any discount at all.
```

**Example 3:**

```
Input: prices = [10,1,1,6]
Output: [9,0,1,6]
```

**Constraints:**

*   `1 <= prices.length <= 500`
*   `1 <= prices[i] <= 10^3`


#### Solution

Language: **Python**

```python
class Solution(object):
    def finalPrices(self, prices):
        """
        :type prices: List[int]
        :rtype: List[int]
        """
        res = []
        stack = []
        for i in range(len(prices) - 1, -1, -1):
            while stack and prices[i] < stack[-1]:
                stack.pop()
            if not stack:
                res.append(prices[i])
            else:
                res.append(prices[i] - stack[-1])
            stack.append(prices[i])
        return res[::-1]
```

### [735\. Asteroid Collision :rainbow:](https://leetcode.com/problems/asteroid-collision/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Stack](https://leetcode.com/tag/stack/)


We are given an array `asteroids` of integers representing asteroids in a row.

For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.

Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.

**Example 1:**

```
Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10\. The 5 and 10 never collide.
```

**Example 2:**

```
Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.
```

**Example 3:**

```
Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5\. The 10 and -5 collide resulting in 10.
```

**Constraints:**

*   `2 <= asteroids.length <= 10<sup>4</sup>`
*   `-1000 <= asteroids[i] <= 1000`
*   `asteroids[i] != 0`


#### Solution

Language: **Python**

```python
class Solution(object):
    def asteroidCollision(self, asteroids):
        """
        :type asteroids: List[int]
        :rtype: List[int]
        """
        stack = []
        for a in asteroids:
            while stack and a < 0 and stack[-1] > 0:
                diff = a + stack[-1]
                if diff < 0:
                    stack.pop()
                elif diff == 0:
                    stack.pop()
                    a = 0
                else:
                    a = 0
            if a:
                stack.append(a)
        return stack
```

### [739\. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Stack](https://leetcode.com/tag/stack/), [Monotonic Stack](https://leetcode.com/tag/monotonic-stack/)


Given an array of integers `temperatures` represents the daily temperatures, return _an array_ `answer` _such that_ `answer[i]` _is the number of days you have to wait after the_ `i<sup>th</sup>` _day to get a warmer temperature_. If there is no future day for which this is possible, keep `answer[i] == 0` instead.

**Example 1:**

```
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
```

**Example 2:**

```
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]
```

**Example 3:**

```
Input: temperatures = [30,60,90]
Output: [1,1,0]
```

**Constraints:**

*   `1 <= temperatures.length <= 10<sup>5</sup>`
*   `30 <= temperatures[i] <= 100`


#### Solution

Language: **Python**

```python
class Solution(object):
    def dailyTemperatures(self, temperatures):
        """
        :type temperatures: List[int]
        :rtype: List[int]
        """
        stack = []
        res = [0] * len(temperatures)
        for i, t in enumerate(temperatures):
            if not stack or stack[-1][1] >= t:
                stack.append([i, t])
            else:
                while stack and stack[-1][1] < t:
                    prev_index, prev_t = stack.pop()
                    res[prev_index] = i - prev_index
                stack.append([i, t])
        return res
```

### [853\. Car Fleet :rainbow:](https://leetcode.com/problems/car-fleet/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Stack](https://leetcode.com/tag/stack/), [Sorting](https://leetcode.com/tag/sorting/), [Monotonic Stack](https://leetcode.com/tag/monotonic-stack/)


There are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.

You are given two integer array `position` and `speed`, both of length `n`, where `position[i]` is the position of the `i<sup>th</sup>` car and `speed[i]` is the speed of the `i<sup>th</sup>` car (in miles per hour).

A car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper **at the same speed**. The faster car will **slow down** to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).

A **car fleet** is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.

If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.

Return _the **number of car fleets** that will arrive at the destination_.

**Example 1:**

```
Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3
Explanation:
The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.
The car starting at 0 does not catch up to any other car, so it is a fleet by itself.
The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6\. The fleet moves at speed 1 until it reaches target.
Note that no other cars meet these fleets before the destination, so the answer is 3.
```

**Example 2:**

```
Input: target = 10, position = [3], speed = [3]
Output: 1
Explanation: There is only one car, hence there is only one fleet.
```

**Example 3:**

```
Input: target = 100, position = [0,2,4], speed = [4,2,1]
Output: 1
Explanation:
The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4\. The fleet moves at speed 2.
Then, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6\. The fleet moves at speed 1 until it reaches target.
```

**Constraints:**

*   `n == position.length == speed.length`
*   `1 <= n <= 10<sup>5</sup>`
*   `0 < target <= 10<sup>6</sup>`
*   `0 <= position[i] < target`
*   All the values of `position` are **unique**.
*   `0 < speed[i] <= 10<sup>6</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def carFleet(self, target, position, speed):
        """
        :type target: int
        :type position: List[int]
        :type speed: List[int]
        :rtype: int
        """
        pair = [[p, s] for p, s in zip(position, speed)]

        stack = []
        for p, s in sorted(pair)[::-1]: # Reverse Sorted Order
            stack.append((target - p) / s)
            if len(stack) >= 2 and stack[-1] <= stack[-2]:
                stack.pop()
        return len(stack)    
```

## Heap
### [973\. K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Math](https://leetcode.com/tag/math/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Geometry](https://leetcode.com/tag/geometry/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Quickselect](https://leetcode.com/tag/quickselect/)


Given an array of `points` where `points[i] = [x<sub style="display: inline;">i</sub>, y<sub style="display: inline;">i</sub>]` represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.

The distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `(x<sub style="display: inline;">1</sub> - x<sub style="display: inline;">2</sub>)<sup>2</sup> + (y<sub style="display: inline;">1</sub> - y<sub style="display: inline;">2</sub>)<sup>2</sup>`).

You may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg)

```
Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].
```

**Example 2:**

```
Input: points = [[3,3],[5,-1],[-2,4]], k = 2
Output: [[3,3],[-2,4]]
Explanation: The answer [[-2,4],[3,3]] would also be accepted.
```

**Constraints:**

*   `1 <= k <= points.length <= 10<sup>4</sup>`
*   `-10<sup>4</sup> < x<sub style="display: inline;">i</sub>, y<sub style="display: inline;">i</sub> < 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
from heapq import heappush, heappop

# sol-2: nlog(k)
def kClosest(points, k):
    heap = []
    for point in points:
        distance = point[0] ** 2 + point[1] ** 2
        heappush(heap, (-distance, point))
        if len(heap) > k:
            heappop(heap)
    return [point for _, point in heap]

kClosest(points = [[1,3],[-2,2]], k = 1)
kClosest(points = [[3,3],[5,-1],[-2,4]], k = 2)

class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        pts = []
        for x, y in points:
            dist = (abs(x - 0) ** 2) + (abs(y - 0) ** 2)
            pts.append([dist, x, y])

        res = []
        heapq.heapify(pts)
        for i in range(k):
            dist, x, y = heapq.heappop(pts)
            res.append([x, y])
        return res
```

### [253\. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/)


Given an array of meeting time intervals `intervals` where `intervals[i] = [start<sub style="display: inline;">i</sub>, end<sub style="display: inline;">i</sub>]`, return _the minimum number of conference rooms required_.

**Example 1:**

```
Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2
```

**Example 2:**

```
Input: intervals = [[7,10],[2,4]]
Output: 1
```

**Constraints:**

*   `1 <= intervals.length <= 10<sup>4</sup>`
*   `0 <= start<sub style="display: inline;">i</sub> < end<sub style="display: inline;">i</sub> <= 10<sup>6</sup>`


#### Solution

Language: **Python**

```python
from heapq import heappush, heappop

def minMeetingRooms(intervals):
    intervals.sort(key = lambda x: x[0])
    heap = []
    heappush(heap, intervals[0][1])
    global_max = 1
    for i in range(1, len(intervals)):
        if heap[0] < intervals[i][0]:
            heappop(heap)
        heappush(heap, intervals[i][1])
        global_max = max(global_max, len(heap))
    return global_max

minMeetingRooms([[0, 30],[5, 10],[15, 20]])
minMeetingRooms([[7,10],[2,4]])
```

### [347\. Top K Frequent Elements :fire:](https://leetcode.com/problems/top-k-frequent-elements/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Bucket Sort](https://leetcode.com/tag/bucket-sort/), [Counting](https://leetcode.com/tag/counting/), [Quickselect](https://leetcode.com/tag/quickselect/)


Given an integer array `nums` and an integer `k`, return _the_ `k` _most frequent elements_. You may return the answer in **any order**.

**Example 1:**

```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `k` is in the range `[1, the number of unique elements in the array]`.
*   It is **guaranteed** that the answer is **unique**.

**Follow up:** Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.


#### Solution

Language: **Python**

```python
from collections import Counter
from heapq import heappop, heappush

def topKFrequent(nums, k):
    count = Counter(nums)
    heap = []
    for i, (num, freq) in enumerate(count.iteritems()):
        heappush(heap, (freq, num))
        if i > k - 1:
            heappop(heap)
    return [num for _, num in heap]

topKFrequent(nums = [1,1,1,2,2,3], k = 2)
topKFrequent(nums = [1], k = 1)

# counting sort
def topKFrequent(nums, k):
    counter = {}
    freq = [[] for _ in range(len(nums) + 1)]

    for num in nums:
        counter[num] = counter.get(num, 0) + 1

    for num, frequency in counter.items():
        freq[frequency].append(num)

    res = []
    for i in range(len(freq) -1, -1, -1):
        for num in freq[i]:
            res.append(num)
            if len(res) == k:
                return res
```

### [378\. Kth Smallest Element in a Sorted Matrix :fire:](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `n x n` `matrix` where each of the rows and columns is sorted in ascending order, return _the_ `k<sup>th</sup>` _smallest element in the matrix_.

Note that it is the `k<sup>th</sup>` smallest element **in the sorted order**, not the `k<sup>th</sup>` **distinct** element.

You must find a solution with a memory complexity better than `O(n<sup>2</sup>)`.

**Example 1:**

```
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13
```

**Example 2:**

```
Input: matrix = [[-5]], k = 1
Output: -5
```

**Constraints:**

*   `n == matrix.length == matrix[i].length`
*   `1 <= n <= 300`
*   `-10<sup>9</sup> <= matrix[i][j] <= 10<sup>9</sup>`
*   All the rows and columns of `matrix` are **guaranteed** to be sorted in **non-decreasing order**.
*   `1 <= k <= n<sup>2</sup>`

**Follow up:**

*   Could you solve the problem with a constant memory (i.e., `O(1)` memory complexity)?
*   Could you solve the problem in `O(n)` time complexity? The solution may be too advanced for an interview but you may find reading fun.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1322101/C%2B%2BJavaPython-MaxHeap-MinHeap-Binary-Search-Picture-Explain-Clean-and-Concise)
```python
class Solution:  # 204 ms, faster than 54.32%
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        m, n = len(matrix), len(matrix[0])  # For general, the matrix need not be a square
        minHeap = []  # val, r, c
        for r in range(min(k, m)):
            heappush(minHeap, (matrix[r][0], r, 0))

        ans = -1  # any dummy value
        for i in range(k):
            ans, r, c = heappop(minHeap)
            if c+1 < n: heappush(minHeap, (matrix[r][c + 1], r, c + 1))
        return ans
```

O(n * log(n))
```python
# sol-2: binary search
class Solution(object):
    def kthSmallest(self, matrix, k):
        lo, hi = matrix[0][0], matrix[-1][-1]
        while lo<hi:
            mid = (lo+hi)//2
            if sum(bisect.bisect_right(row, mid) for row in matrix) < k:
                lo = mid+1
            else:
                hi = mid
        return lo           
```

### [692\. Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Trie](https://leetcode.com/tag/trie/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Bucket Sort](https://leetcode.com/tag/bucket-sort/), [Counting](https://leetcode.com/tag/counting/)


Given an array of strings `words` and an integer `k`, return _the_ `k` _most frequent strings_.

Return the answer **sorted** by **the frequency** from highest to lowest. Sort the words with the same frequency by their **lexicographical order**.

**Example 1:**

```
Input: words = ["i","love","leetcode","i","love","coding"], k = 2
Output: ["i","love"]
Explanation: "i" and "love" are the two most frequent words.
Note that "i" comes before "love" due to a lower alphabetical order.
```

**Example 2:**

```
Input: words = ["the","day","is","sunny","the","the","the","sunny","is","is"], k = 4
Output: ["the","is","sunny","day"]
Explanation: "the", "is", "sunny" and "day" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.
```

**Constraints:**

*   `1 <= words.length <= 500`
*   `1 <= words[i] <= 10`
*   `words[i]` consists of lowercase English letters.
*   `k` is in the range `[1, The number of **unique** words[i]]`

**Follow-up:** Could you solve it in `O(n log(k))` time and `O(n)` extra space?


#### Solution

Language: **Python**

```python
class FreqWord(object):
    def __init__(self, freq, word):
        self.freq = freq
        self.word = word

    def __cmp__(self, other):
        if self.freq != other.freq:
            return cmp(self.freq, other.freq)
        else:
            return cmp(other.word, self.word)

class Solution(object):
    def topKFrequent(self, words, k):
        """
        :type words: List[str]
        :type k: int
        :rtype: List[str]
        """
        count = collections.Counter(words)
        heap = []
        for word, freq in count.items():
            heapq.heappush(heap, FreqWord(freq, word))
            if len(heap) > k:
                heapq.heappop(heap)

        return [heapq.heappop(heap).word for _ in xrange(k)][::-1]    
```

### [295\. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

Difficulty: **Hard**  

Related Topics: [Two Pointers](https://leetcode.com/tag/two-pointers/), [Design](https://leetcode.com/tag/design/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Data Stream](https://leetcode.com/tag/data-stream/)


The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.

*   For example, for `arr = [2,3,4]`, the median is `3`.
*   For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.

Implement the MedianFinder class:

*   `MedianFinder()` initializes the `MedianFinder` object.
*   `void addNum(int num)` adds the integer `num` from the data stream to the data structure.
*   `double findMedian()` returns the median of all elements so far. Answers within `10<sup>-5</sup>` of the actual answer will be accepted.

**Example 1:**

```
Input
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]

Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

**Constraints:**

*   `-10<sup>5</sup> <= num <= 10<sup>5</sup>`
*   There will be at least one element in the data structure before calling `findMedian`.
*   At most `5 * 10<sup>4</sup>` calls will be made to `addNum` and `findMedian`.

**Follow up:**

*   If all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?
*   If `99%` of all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?


#### Solution

Language: **Python**

```python
from heapq import heappop, heappush

class MedianFinder(object):
    def __init__(self):
        self.left = []
        self.right = []

    def addNum(self, num):
        '''
        if len(self.left) == len(self.right):
            heappush(self.right, num)
        else:
            heappush(self.left, -num)
        '''
        heappush(self.right, num)
        if len(self.left) + 1 < len(self.right):
            heappush(self.left, -heappop(self.right))

        if (self.left and self.right) and -self.left[0] > self.right[0]:
            heappush(self.right, -heappop(self.left))
            heappush(self.left, -heappop(self.right))

    def findMedian(self):
        if len(self.right) == len(self.left):
            return (-self.left[0] + self.right[0]) * 0.5
        else:
            return self.right[0]

if __name__ == "__main__":
    new = MedianFinder()
    new.addNum(3)
    new.findMedian()
    new.addNum(2)
    new.findMedian()
    new.addNum(1)
    new.findMedian()
    new.addNum(3)
    new.findMedian()
```

### [373\. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/)


You are given two integer arrays `nums1` and `nums2` sorted in **ascending order** and an integer `k`.

Define a pair `(u, v)` which consists of one element from the first array and one element from the second array.

Return _the_ `k` _pairs_ `(u<sub style="display: inline;">1</sub>, v<sub style="display: inline;">1</sub>), (u<sub style="display: inline;">2</sub>, v<sub style="display: inline;">2</sub>), ..., (u<sub style="display: inline;">k</sub>, v<sub style="display: inline;">k</sub>)` _with the smallest sums_.

**Example 1:**

```
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

**Example 2:**

```
Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [[1,1],[1,1]]
Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```

**Example 3:**

```
Input: nums1 = [1,2], nums2 = [3], k = 3
Output: [[1,3],[2,3]]
Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]
```

**Constraints:**

*   `1 <= nums1.length, nums2.length <= 10<sup>5</sup>`
*   `-10<sup>9</sup> <= nums1[i], nums2[i] <= 10<sup>9</sup>`
*   `nums1` and `nums2` both are sorted in **ascending order**.
*   `1 <= k <= 1000`


#### Solution

Language: **Python**

```python
import heapq

def kSmallestPairs(nums1, nums2, k):
    result = []
    len1, len2 = len(nums1), len(nums2)
    if not len1 or not len2: return res
    heap = []
    for i in range(len1):
        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))
    while len(result) < min(k, len1 * len2):
        sum, i, j = heapq.heappop(heap)
        result.append([nums1[i], nums2[j]])
        next_j = j + 1
        if next_j < len2:
            heapq.heappush(heap, (nums1[i] + nums2[next_j], i, next_j))
    return result

kSmallestPairs(nums1 = [1,7,11], nums2 = [2,4,6], k = 3)        
```

### [407\. Trapping Rain Water II :fire:](https://leetcode.com/problems/trapping-rain-water-ii/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `m x n` integer matrix `heightMap` representing the height of each unit cell in a 2D elevation map, return _the volume of water it can trap after raining_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg)

```
Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
Output: 4
Explanation: After the rain, water is trapped between the blocks.
We have two small ponds 1 and 3 units trapped.
The total volume of water trapped is 4.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg)

```
Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
Output: 10
```

**Constraints:**

*   `m == heightMap.length`
*   `n == heightMap[i].length`
*   `1 <= m, n <= 200`
*   `0 <= heightMap[i][j] <= 2 * 10<sup>4</sup>`


#### Solution

Language: **Python**

* [](https://www.youtube.com/watch?v=7GH-x3Dn-4o&ab_channel=XiaoxuHu)
```python
class Solution:

    def trapRainWater(self, grid):
        """
        :type heightMap: List[List[int]]
        :rtype: int
        """
        if len(grid) == 0:
            return 0

        m = len(grid)
        n = len(grid[0])
        heap = []
        vst = set()

        # init , put surrounding into heap
        for i in [0, m - 1]:
            for j in range(n):
                heap.append((grid[i][j], i, j))
                vst.add((i, j))

        for j in [0, n - 1]:
            for i in range(m):
                if (i, j) in vst:
                    continue

                heap.append((grid[i][j], i, j))
                vst.add((i, j))

        heapq.heapify(heap)

        dxy = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        ans = 0
        mx = float('-inf')

        while heap:

            h, x, y = heapq.heappop(heap)
            mx = max(h, mx)

            for dx, dy in dxy:
                nx = x + dx
                ny = y + dy

                if not (0 <= nx < m and 0 <= ny < n):
                    continue

                if (nx, ny) in vst:
                    continue

                if mx > grid[nx][ny]:
                    ans += mx - grid[nx][ny]

                itm = (grid[nx][ny], nx, ny)
                heapq.heappush(heap, itm)
                vst.add((nx, ny))

        return ans
```

### [759\. Employee Free Time :fire:](https://leetcode.com/problems/employee-free-time/description/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/)


We are given a list `schedule` of employees, which represents the working time for each employee.

Each employee has a list of non-overlapping `Intervals`, and these intervals are in sorted order.

Return the list of finite intervals representing **common, positive-length free time** for _all_ employees, also in sorted order.

(Even though we are representing `Intervals` in the form `[x, y]`, the objects inside are `Intervals`, not lists or arrays. For example, `schedule[0][0].start = 1`, `schedule[0][0].end = 2`, and `schedule[0][0][0]` is not defined).  Also, we wouldn't include intervals like [5, 5] in our answer, as they have zero length.

**Example 1:**

```
Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
Output: [[3,4]]
Explanation: There are a total of three employees, and all common
free time intervals would be [-inf, 1], [3, 4], [10, inf].
We discard any intervals that contain inf as they aren't finite.
```

**Example 2:**

```
Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
Output: [[5,6],[7,9]]
```

**Constraints:**

*   `1 <= schedule.length , schedule[i].length <= 50`
*   `0 <= schedule[i].start < schedule[i].end <= 10^8`


#### Solution

Language: **Python**

```python
# T: O(n*log(n)), n is the number of intervals across all employees
# S: O(n)
schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]

def employeeFreeTime(schedule):
    intervals = sorted([interval for s in schedule for interval in s], key=lambda x: x[0])
    res, pre = [], intervals[0]
    for interval in intervals[1:]:
        if interval[0] <= pre[1] and interval[1] > pre[1]:
            pre[1] = interval[1]
        elif interval[0] > pre[1]:
            res.append([pre[1], interval[0]])
            pre = interval
    return res
```

```Python
# T: O(n*log(k)), n is the number of intervals across all employees
#                 k is the number of employees
# S: O(k)
class Solution:
    def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':
        # collect first events of all employees
        heap = []
        for i, employee in enumerate(schedule):
            # (event.start, employee index, event index)
            heapq.heappush(heap, (employee[0].start, i, 0))

        res = []
        _, i, j = heap[0]
        prev_end = schedule[i][j].end
        while heap:
            _, i, j = heapq.heappop(heap)
            # check for next employee event and push it
            if j + 1 < len(schedule[i]):
                heapq.heappush(heap, (schedule[i][j + 1].start, i, j + 1))

            event = schedule[i][j]
            if event.start > prev_end:
                res.append(Interval(prev_end, event.start))
            prev_end = max(prev_end, event.end)
        return res
```

### [1845\. Seat Reservation Manager](https://leetcode.com/problems/seat-reservation-manager/)

Difficulty: **Medium**  

Related Topics: [Design](https://leetcode.com/tag/design/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/)


Design a system that manages the reservation state of `n` seats that are numbered from `1` to `n`.

Implement the `SeatManager` class:

*   `SeatManager(int n)` Initializes a `SeatManager` object that will manage `n` seats numbered from `1` to `n`. All seats are initially available.
*   `int reserve()` Fetches the **smallest-numbered** unreserved seat, reserves it, and returns its number.
*   `void unreserve(int seatNumber)` Unreserves the seat with the given `seatNumber`.

**Example 1:**

```
Input
["SeatManager", "reserve", "reserve", "unreserve", "reserve", "reserve", "reserve", "reserve", "unreserve"]
[[5], [], [], [2], [], [], [], [], [5]]
Output
[null, 1, 2, null, 2, 3, 4, 5, null]

Explanation
SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats.
seatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1.
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5].
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3.
seatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4.
seatManager.reserve();    // The only available seat is seat 5, so return 5.
seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].
```

**Constraints:**

*   `1 <= n <= 10<sup>5</sup>`
*   `1 <= seatNumber <= n`
*   For each call to `reserve`, it is guaranteed that there will be at least one unreserved seat.
*   For each call to `unreserve`, it is guaranteed that `seatNumber` will be reserved.
*   At most `10<sup>5</sup>` calls **in total** will be made to `reserve` and `unreserve`.


#### Solution

Language: **Python**

```python
class SeatManager(object):

    def __init__(self, n):
        """
        :type n: int
        """
        self.heap = []
        for i in range(1, n + 1):
            heapq.heappush(self.heap, i)

    def reserve(self):
        """
        :rtype: int
        """
        return heapq.heappop(self.heap) if self.heap else -1

    def unreserve(self, seatNumber):
        """
        :type seatNumber: int
        :rtype: None
        """
        heapq.heappush(self.heap, seatNumber)
        colle

# Your SeatManager object will be instantiated and called as such:
# obj = SeatManager(n)
# param_1 = obj.reserve()
# obj.unreserve(seatNumber)
```

### [703\. Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Design](https://leetcode.com/tag/design/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Binary Tree](https://leetcode.com/tag/binary-tree/), [Data Stream](https://leetcode.com/tag/data-stream/)


Design a class to find the `k<sup>th</sup>` largest element in a stream. Note that it is the `k<sup>th</sup>` largest element in the sorted order, not the `k<sup>th</sup>` distinct element.

Implement `KthLargest` class:

*   `KthLargest(int k, int[] nums)` Initializes the object with the integer `k` and the stream of integers `nums`.
*   `int add(int val)` Appends the integer `val` to the stream and returns the element representing the `k<sup>th</sup>` largest element in the stream.

**Example 1:**

```
Input
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output
[null, 4, 5, 5, 8, 8]

Explanation
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
```

**Constraints:**

*   `1 <= k <= 10<sup>4</sup>`
*   `0 <= nums.length <= 10<sup>4</sup>`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
*   `-10<sup>4</sup> <= val <= 10<sup>4</sup>`
*   At most `10<sup>4</sup>` calls will be made to `add`.
*   It is guaranteed that there will be at least `k` elements in the array when you search for the `k<sup>th</sup>` element.


#### Solution

Language: **Python**

```python
class KthLargest(object):

    def __init__(self, k, nums):
        """
        :type k: int
        :type nums: List[int]
        """
        self.minheap = nums
        self.k = k
        heapq.heapify(self.minheap)
        while len(self.minheap) > k:
            heapq.heappop(self.minheap)


    def add(self, val):
        """
        :type val: int
        :rtype: int
        """
        heapq.heappush(self.minheap, val)
        if len(self.minheap) > self.k:
            heapq.heappop(self.minheap)
        return self.minheap[0]


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)
```

### [846\. Hand of Straights :fire:](https://leetcode.com/problems/hand-of-straights/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/)


Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size `groupSize`, and consists of `groupSize` consecutive cards.

Given an integer array `hand` where `hand[i]` is the value written on the `i<sup>th</sup>` card and an integer `groupSize`, return `true` if she can rearrange the cards, or `false` otherwise.

**Example 1:**

```
Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
Output: true
Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]
```

**Example 2:**

```
Input: hand = [1,2,3,4,5], groupSize = 4
Output: false
Explanation: Alice's hand can not be rearranged into groups of 4.

```

**Constraints:**

*   `1 <= hand.length <= 10<sup>4</sup>`
*   `0 <= hand[i] <= 10<sup>9</sup>`
*   `1 <= groupSize <= hand.length`

**Note:** This question is the same as 1296:


#### Solution

Language: **Python**

```python
class Solution(object):
    def isNStraightHand(self, hand, groupSize):
        """
        :type hand: List[int]
        :type groupSize: int
        :rtype: bool
        """
        if len(hand) % groupSize:
            return False
        
        count = {}
        for n in hand:
            count[n] = 1 + count.get(n, 0)
        
        minH = list(count.keys())
        heapq.heapify(minH)
        while minH:
            first = minH[0]
            for i in range(first, first + groupSize):
                if i not in count:
                    return False
                count[i] -= 1
                if count[i] == 0:
                    if i != minH[0]:
                        return False
                    heapq.heappop(minH)
        return True    
```

### [1882\. Process Tasks Using Servers :rainbow:](https://leetcode.com/problems/process-tasks-using-servers/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/)


You are given two **0-indexed** integer arrays `servers` and `tasks` of lengths `n` and `m` respectively. `servers[i]` is the **weight** of the `i<sup>th</sup>` server, and `tasks[j]` is the **time needed** to process the `j<sup>th</sup>` task **in seconds**.

Tasks are assigned to the servers using a **task queue**. Initially, all servers are free, and the queue is **empty**.

At second `j`, the `j<sup>th</sup>` task is **inserted** into the queue (starting with the `0<sup>th</sup>` task being inserted at second `0`). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the **smallest weight**, and in case of a tie, it is assigned to a free server with the **smallest index**.

If there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned **in order of insertion** following the weight and index priorities above.

A server that is assigned task `j` at second `t` will be free again at second `t + tasks[j]`.

Build an array `ans` of length `m`, where `ans[j]` is the **index** of the server the `j<sup>th</sup>` task will be assigned to.

Return _the array_ `ans`.

**Example 1:**

```
Input: servers = [3,3,2], tasks = [1,2,3,2,1,2]
Output: [2,2,0,2,1,2]
Explanation: Events in chronological order go as follows:
- At second 0, task 0 is added and processed using server 2 until second 1.
- At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.
- At second 2, task 2 is added and processed using server 0 until second 5.
- At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.
- At second 4, task 4 is added and processed using server 1 until second 5.
- At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.
```

**Example 2:**

```
Input: servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]
Output: [1,4,1,4,1,3,2]
Explanation: Events in chronological order go as follows:
- At second 0, task 0 is added and processed using server 1 until second 2.
- At second 1, task 1 is added and processed using server 4 until second 2.
- At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4\.
- At second 3, task 3 is added and processed using server 4 until second 7.
- At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9\.
- At second 5, task 5 is added and processed using server 3 until second 7.
- At second 6, task 6 is added and processed using server 2 until second 7.
```

**Constraints:**

*   `servers.length == n`
*   `tasks.length == m`
*   `1 <= n, m <= 2 * 10<sup>5</sup>`
*   `1 <= servers[i], tasks[j] <= 2 * 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def assignTasks(self, servers, tasks):
        """
        :type servers: List[int]
        :type tasks: List[int]
        :rtype: List[int]
        """
        res = [0] * len(tasks)
        avail = [(servers[i], i) for i in range(len(servers))]
        heapq.heapify(avail)
        unavail = []
        
        t = 0
        for i in range(len(tasks)):
            t = max(t, i)
            
            if len(avail) == 0:
                t = unavail[0][0]
            
            while unavail and t >= unavail[0][0]:
                timefree, weight, index = heapq.heappop(unavail)
                heapq.heappush(avail, (weight, index))
            
            weight, index = heapq.heappop(avail)
            res[i] = index
            heapq.heappush(unavail, (t + tasks[i], weight, index))
        return res
                            
```

## Hash Table
### [953\. Verifying an Alien Dictionary](https://leetcode.com/problems/verifying-an-alien-dictionary/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/)


In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different `order`. The `order` of the alphabet is some permutation of lowercase letters.

Given a sequence of `words` written in the alien language, and the `order` of the alphabet, return `true` if and only if the given `words` are sorted lexicographically in this alien language.

**Example 1:**

```
Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
Output: true
Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.
```

**Example 2:**

```
Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
Output: false
Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.
```

**Example 3:**

```
Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
Output: false
Explanation: The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" > "app", because 'l' > '', where '' is defined as the blank character which is less than any other character ().
```

**Constraints:**

*   `1 <= words.length <= 100`
*   `1 <= words[i].length <= 20`
*   `order.length == 26`
*   All characters in `words[i]` and `order` are English lowercase letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        dic = {}
        new_words = []
        for i, ch in enumerate(order):
            dic[ch] = i
        for w in words:
            new = []
            for c in w:
                new.append(dic[c])
            new_words.append(new)
        for w1, w2 in zip(new_words, new_words[1:]):
            if w1 > w2:
                return False
        return True
```

### [560\. Subarray Sum Equals K :rainbow:](https://leetcode.com/problems/subarray-sum-equals-k/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/)


Given an array of integers `nums` and an integer `k`, return _the total number of continuous subarrays whose sum equals to `k`_.

**Example 1:**

```
Input: nums = [1,1,1], k = 2
Output: 2
```

**Example 2:**

```
Input: nums = [1,2,3], k = 3
Output: 2
```

**Constraints:**

*   `1 <= nums.length <= 2 * 10<sup>4</sup>`
*   `-1000 <= nums[i] <= 1000`
*   `-10<sup>7</sup> <= k <= 10<sup>7</sup>`


#### Solution

Language: **Python**

```python
def subarraySum(nums, k):
        n = len(nums)
        d = {}
        d[0] = 1
        cumsum = 0
        res = 0
        for i in range(n):
            cumsum += nums[i]
            if cumsum - k in d:
                res += d[cumsum - k]
            d[cumsum] = d.get(cumsum, 0) + 1
        return res

subarraySum(nums = [1,-1,0], k = 0)
```

### [523\. Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/)


Given an integer array `nums` and an integer `k`, return `true` _if_ `nums` _has a continuous subarray of size **at least two** whose elements sum up to a multiple of_ `k`_, or_ `false` _otherwise_.

An integer `x` is a multiple of `k` if there exists an integer `n` such that `x = n * k`. `0` is **always** a multiple of `k`.

**Example 1:**

```
Input: nums = [23,2,4,6,7], k = 6
Output: true
Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
```

**Example 2:**

```
Input: nums = [23,2,6,4,7], k = 6
Output: true
Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
```

**Example 3:**

```
Input: nums = [23,2,6,4,7], k = 13
Output: false
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `0 <= nums[i] <= 10<sup>9</sup>`
*   `0 <= sum(nums[i]) <= 2<sup>31</sup> - 1`
*   `1 <= k <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

```
Example:
nums = [23,2,4], k = 6
Lets walk through the code with the example.
(i=0) : sums = 23 => 23%6 => (sums = 5)
(i=1) : sums = 5+2=7 => 7%6 => (sums = 1)
(i=2) : sums = 1+4=5 => 5%6 => (sums = 5)
```

* We have encountered the same sums(remainder) again which means we have the subarray of `sums%k = 0`.
* But, there's another aspect to this problem. The subarray must have a minimum size of 2.

```
Counter example to understand this. Lets take nums = [23,6], k = 6
(i=0) : sums = 23 => 23%6 => (sums = 5)
(i=1) : sums = 5+6=11 => 11%6 => (sums = 5)
```

```python
class Solution(object):
    def checkSubarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        d = dict()
        d[0] = -1
        sums = 0
        for i in range(len(nums)):
            sums += nums[i]
            if k!=0 :
                sums = sums % k
            if sums in d:
                if i - d[sums] > 1:
                    return True
            else:
                d[sums] = i
        return False
```

### [349\. Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Binary Search](https://leetcode.com/tag/binary-search/), [Sorting](https://leetcode.com/tag/sorting/)


Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must be **unique** and you may return the result in **any order**.

**Example 1:**

```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
```

**Example 2:**

```
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
```

**Constraints:**

*   `1 <= nums1.length, nums2.length <= 1000`
*   `0 <= nums1[i], nums2[i] <= 1000`


#### Solution

Language: **Python**

```python
from collections import defaultdict

def intersection(nums1, nums2):
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    dict = defaultdict(int)
    result = []
    for num in nums1:
        if num in dict:
            dict[num] += 1
        else:
            dict[num] = 1
    for num in nums2:
        if dict[num] > 0 and num not in result:
            result.append(num)
            dict[num] -= 1
    return result
```

### [311\. Sparse Matrix Multiplication](https://leetcode.com/problems/sparse-matrix-multiplication/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Matrix](https://leetcode.com/tag/matrix/)


Given two `mat1` of size `m x k` and `mat2` of size `k x n`, return the result of `mat1 x mat2`. You may assume that multiplication is always possible.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/12/mult-grid.jpg)

```
Input: mat1 = [[1,0,0],[-1,0,3]], mat2 = [[7,0,0],[0,0,0],[0,0,1]]
Output: [[7,0,0],[-7,0,3]]
```

**Example 2:**

```
Input: mat1 = [[0]], mat2 = [[0]]
Output: [[0]]
```

**Constraints:**

*   `m == mat1.length`
*   `k == mat1[i].length == mat2.length`
*   `n == mat2[i].length`
*   `1 <= m, n, k <= 100`
*   `-100 <= mat1[i][j], mat2[i][j] <= 100`


#### Solution

Language: **Python**

```python
class Solution(object):
    def multiply(self, A, B):
        if not A or not A[0] or not B or not B[0]:
            return [[]]
        sparse_A = self.get_none_zero(A)
        sparse_B = self.get_none_zero(B)
        n, m, k = len(A), len(A[0]), len(B[0])
        C = [[0] * k for _ in range(n)]
        for i, j, val_A in sparse_A:
            for x, y, val_B in sparse_B:
                if j == x:
                    C[i][y] += val_A * val_B
        return C

    def get_none_zero(self, A):
        res = []
        n, m = len(A), len(A[0])
        for i in range(n):
            for j in range(m):
                if A[i][j] == 0:
                    continue
                res.append((i, j, A[i][j]))
        return res
```

```python
def multiply(A, B):
    t, m, n = len(A), len(B), len(B[0])
    AB = [[0] * n for _ in range(t)]

    for i in range(t):
        for j in range(m):
            if A[i][j] == 0:
                continue
            for k in range(n):
                if B[j][k] == 0:
                    continue
                AB[i][k] += A[i][j] * B[j][k]
    return AB    

A = [
  [ 1, 0, 0],
  [-1, 0, 3]
]

B = [
  [ 7, 0, 0 ],
  [ 0, 0, 0 ],
  [ 0, 0, 1 ]
]
multiply(A, B)
```

### [380\. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [Design](https://leetcode.com/tag/design/), [Randomized](https://leetcode.com/tag/randomized/)


Implement the `RandomizedSet` class:

*   `RandomizedSet()` Initializes the `RandomizedSet` object.
*   `bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise.
*   `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.
*   `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.

You must implement the functions of the class such that each function works in **average** `O(1)` time complexity.

**Example 1:**

```
Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
```

**Constraints:**

*   `-2<sup>31</sup> <= val <= 2<sup>31</sup> - 1`
*   At most `2 * ``10<sup>5</sup>` calls will be made to `insert`, `remove`, and `getRandom`.
*   There will be **at least one** element in the data structure when `getRandom` is called.


#### Solution

Language: **Python**

```python
from random import randint

class RandomizedSet:
    def __init__(self):
        self.nums, self.pos = [], {}

    def insert(self, val):
        if val not in self.pos:
            self.nums.append(val)
            self.pos[val] = len(self.nums) - 1
            return True
        return False

    def remove(self, val):
        if val in self.pos:
            val_idx, last_val = self.pos[val], self.nums[-1]
            self.nums[val_idx], self.pos[last_val] = last_val, val_idx
            self.nums.pop(); del self.pos[val]
            return True
        return False

    def getRandom(self):
        return self.nums[randint(0, len(self.nums) - 1)]
```

### [381\. Insert Delete GetRandom O(1) - Duplicates allowed](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [Design](https://leetcode.com/tag/design/), [Randomized](https://leetcode.com/tag/randomized/)


`RandomizedCollection` is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also removing a random element.

Implement the `RandomizedCollection` class:

*   `RandomizedCollection()` Initializes the empty `RandomizedCollection` object.
*   `bool insert(int val)` Inserts an item `val` into the multiset, even if the item is already present. Returns `true` if the item is not present, `false` otherwise.
*   `bool remove(int val)` Removes an item `val` from the multiset if present. Returns `true` if the item is present, `false` otherwise. Note that if `val` has multiple occurrences in the multiset, we only remove one of them.
*   `int getRandom()` Returns a random element from the current multiset of elements. The probability of each element being returned is **linearly related** to the number of same values the multiset contains.

You must implement the functions of the class such that each function works on **average** `O(1)` time complexity.

**Note:** The test cases are generated such that `getRandom` will only be called if there is **at least one** item in the `RandomizedCollection`.

**Example 1:**

```
Input
["RandomizedCollection", "insert", "insert", "insert", "getRandom", "remove", "getRandom"]
[[], [1], [1], [2], [], [1], []]
Output
[null, true, false, true, 2, true, 1]

Explanation
RandomizedCollection randomizedCollection = new RandomizedCollection();
randomizedCollection.insert(1);   // return true since the collection does not contain 1.
                                  // Inserts 1 into the collection.
randomizedCollection.insert(1);   // return false since the collection contains 1.
                                  // Inserts another 1 into the collection. Collection now contains [1,1].
randomizedCollection.insert(2);   // return true since the collection does not contain 2.
                                  // Inserts 2 into the collection. Collection now contains [1,1,2].
randomizedCollection.getRandom(); // getRandom should:
                                  // - return 1 with probability 2/3, or
                                  // - return 2 with probability 1/3.
randomizedCollection.remove(1);   // return true since the collection contains 1.
                                  // Removes 1 from the collection. Collection now contains [1,2].
randomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.
```

**Constraints:**

*   `-2<sup>31</sup> <= val <= 2<sup>31</sup> - 1`
*   At most `2 * 10<sup>5</sup>` calls **in total** will be made to `insert`, `remove`, and `getRandom`.
*   There will be **at least one** element in the data structure when `getRandom` is called.


#### Solution

Language: **Python**

```python
from random import randint
from collections import defaultdict

class RandomizedCollection:
    def __init__(self):
        self.nums = []
        self.pos = defaultdict(set)

    def insert(self, val):
        val_exists = val not in self.nums
        self.pos[val].add(len(self.nums))
        self.nums.append(val)
        return val_exists

    def getRandom(self):
        return self.nums[randint(0, len(self.nums) - 1)]

    def remove(self, val):
        if val not in self.nums:
            return False
        last_val = self.nums[-1]
        self.nums.pop()

        val_index = self.pos[val].pop()
        self.nums[val_index] = last_val
        self.pos[last_val].remove(len(self.nums))
        self.pos[last_val].add(val_index)
        if not self.pos[val]:
            del self.pos[val]            
        return True

randomizedCollection =  RandomizedCollection()
randomizedCollection.insert(1)  
randomizedCollection.insert(1)  
randomizedCollection.insert(2)  
randomizedCollection.getRandom()
randomizedCollection.remove(1)  
randomizedCollection.getRandom()
```

### [249\. Group Shifted Strings](https://leetcode.com/problems/group-shifted-strings/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/)


We can shift a string by shifting each of its letters to its successive letter.

*   For example, `"abc"` can be shifted to be `"bcd"`.

We can keep shifting the string to form a sequence.

*   For example, we can keep shifting `"abc"` to form the sequence: `"abc" -> "bcd" -> ... -> "xyz"`.

Given an array of strings `strings`, group all `strings[i]` that belong to the same shifting sequence. You may return the answer in **any order**.

**Example 1:**

```
Input: strings = ["abc","bcd","acef","xyz","az","ba","a","z"]
Output: [["acef"],["a","z"],["abc","bcd","xyz"],["az","ba"]]
```

**Example 2:**

```
Input: strings = ["a"]
Output: [["a"]]
```

**Constraints:**

*   `1 <= strings.length <= 200`
*   `1 <= strings[i].length <= 50`
*   `strings[i]` consists of lowercase English letters.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/group-shifted-strings/discuss/282285/Python-Solution-with-Explanation-(44ms-84))

```python
import collections

def groupStrings(strings):
    groups = collections.defaultdict(list)

    for s in strings:  # Grouping.
        groups[hashStr(s)].append(s)

    result = []
    for key, val in groups.iteritems():
        result.append(sorted(val))

    return result

def hashStr(s):
    base = ord(s[0])
    hashcode = ""
    for s_ in s:
        if ord(s_) - base >= 0:
            hashcode += chr(ord(s_) - base)
        else:
            hashcode += chr(ord(s_) - base + 26)
    return hashcode

if __name__ == "__main__":
    groupStrings(["abc","bcd","xyz","az","ba","acef","a","z"])
```

### [246\. Strobogrammatic Number](https://leetcode.com/problems/strobogrammatic-number/)

Difficulty: **Easy**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/)


Given a string `num` which represents an integer, return `true` _if_ `num` _is a **strobogrammatic number**_.

A **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).

**Example 1:**

```
Input: num = "69"
Output: true
```

**Example 2:**

```
Input: num = "88"
Output: true
```

**Example 3:**

```
Input: num = "962"
Output: false
```

**Example 4:**

```
Input: num = "1"
Output: true
```

**Constraints:**

*   `1 <= num.length <= 50`
*   `num` consists of only digits.
*   `num` does not contain any leading zeros except for zero itself.


#### Solution

Language: **Python**

```python
def isStrobogrammatic(num):
    mapping = {'1': '1', '8': '8', '0': '0', '6': '9', '9': '6'}
    i, j = 0, len(num) - 1
    while i <= j:
        if num[i] not in mapping or num[j] not in mapping or not mapping[num[i]] == num[j]:
            return False
        else:
            i += 1
            j -= 1
    return True

isStrobogrammatic("69")
isStrobogrammatic("828")
isStrobogrammatic("962")
```

### [350\. Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Binary Search](https://leetcode.com/tag/binary-search/), [Sorting](https://leetcode.com/tag/sorting/)


Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must appear as many times as it shows in both arrays and you may return the result in **any order**.

**Example 1:**

```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
```

**Example 2:**

```
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.
```

**Constraints:**

*   `1 <= nums1.length, nums2.length <= 1000`
*   `0 <= nums1[i], nums2[i] <= 1000`

**Follow up:**

*   What if the given array is already sorted? How would you optimize your algorithm?
*   What if `nums1`'s size is small compared to `nums2`'s size? Which algorithm is better?
*   What if elements of `nums2` are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?


#### Solution

Language: **Python**

```python
class Solution(object):
    def intersect(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        result = []
        counter = {}
        for num in nums1:
            if num in counter:
                counter[num] += 1
            else:
                counter[num] = 1
        for num in nums2:
            if num in counter and counter[num] > 0:
                result.append(num)
                counter[num] -= 1
        return result
```

### [1\. Two Sum](https://leetcode.com/problems/two-sum/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/)


Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.

You can return the answer in any order.

**Example 1:**

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Output: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:**

```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

**Example 3:**

```
Input: nums = [3,3], target = 6
Output: [0,1]
```

**Constraints:**

*   `2 <= nums.length <= 10<sup>4</sup>`
*   `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`
*   `-10<sup>9</sup> <= target <= 10<sup>9</sup>`
*   **Only one valid answer exists.**

**Follow-up: **Can you come up with an algorithm that is less than `O(n<sup>2</sup>) `time complexity?

#### Solution

Language: **Python**

```python
# sol-1: O(n^2)
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(1, n):
            if nums[i] + nums[j] == target:
                return [i, j]

twoSum(nums = [2, 7, 11, 15], target = 9)

# sol-2: O(nlogn)
def twoSum(nums, target):
    nums.sort()
    i = 0
    j = len(nums) - 1
    while i < j:
        if nums[i] + nums[j] > target:
            j -= 1
        elif nums[i] + nums[j] < target:
            i += 1
        else:
            return [i, j]

twoSum(nums = [2, 7, 11, 15], target = 9)

# sol-2: O(n)
def twoSum(nums, target):
    d = {}
    for i, num in enumerate(nums):
        if target - num in d:
            return [d[target - num], i]
        else:
            d[num] = i

twoSum(nums = [2, 7, 11, 15], target = 9)        
```

### [325\. Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/)


Given an integer array `nums` and an integer `k`, return _the maximum length of a subarray that sums to_ `k`. If there isn't one, return `0` instead.

**Example 1:**

```
Input: nums = [1,-1,5,-2,3], k = 3
Output: 4
Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.
```

**Example 2:**

```
Input: nums = [-2,-1,2,1], k = 1
Output: 2
Explanation: The subarray [-1, 2] sums to 1 and is the longest.
```

**Constraints:**

*   `1 <= nums.length <= 2 * 10<sup>5</sup>`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
*   `-10<sup>9</sup> <= k <= 10<sup>9</sup>`


#### Solution

Language: **Python**

```python
def maxSubArrayLen(nums, k):
    ans, acc = 0, 0               # answer and the accumulative value of nums
    mp = {0:-1}                 #key is acc value, and value is the index
    for i in xrange(len(nums)):
        acc += nums[i]
        if acc not in mp:
            mp[acc] = i
        if acc-k in mp:
            ans = max(ans, i-mp[acc-k])
    return ans

maxSubArrayLen(nums = [1, -1, 5, -2, 3], k = 3)
maxSubArrayLen(nums = [-2, -1, 2, 1], k = 1)
```

### [1570\. Dot Product of Two Sparse Vectors](https://leetcode.com/problems/dot-product-of-two-sparse-vectors/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Design](https://leetcode.com/tag/design/)


Given two sparse vectors, compute their dot product.

Implement class `SparseVector`:

*   `SparseVector(nums)` Initializes the object with the vector `nums`
*   `dotProduct(vec)` Compute the dot product between the instance of _SparseVector_ and `vec`

A **sparse vector** is a vector that has mostly zero values, you should store the sparse vector **efficiently** and compute the dot product between two _SparseVector_.

**Follow up: **What if only one of the vectors is sparse?

**Example 1:**

```
Input: nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]
Output: 8
Explanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
v1.dotProduct(v2) = 1*0 + 0*3 + 0*0 + 2*4 + 3*0 = 8
```

**Example 2:**

```
Input: nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2]
Output: 0
Explanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
v1.dotProduct(v2) = 0*0 + 1*0 + 0*0 + 0*0 + 0*2 = 0
```

**Example 3:**

```
Input: nums1 = [0,1,0,0,2,0,0], nums2 = [1,0,0,0,3,0,4]
Output: 6
```

**Constraints:**

*   `n == nums1.length == nums2.length`
*   `1 <= n <= 10^5`
*   `0 <= nums1[i], nums2[i] <= 100`


#### Solution

Language: **Python**

```python
class SparseVector:
    def __init__(self, nums: List[int]):
        self.nonzeros = {}
        for i, n in enumerate(nums):
            if n != 0:
                self.nonzeros[i] = n              

    def dotProduct(self, vec: 'SparseVector') -> int:
        result = 0
        # iterate through each non-zero element in this sparse vector
        # update the dot product if the corresponding index has a non-zero value in the other vector
        for i, n in self.nonzeros.items():
            if i in vec.nonzeros:
                result += n * vec.nonzeros[i]
        return result
```

### [49\. Group Anagrams](https://leetcode.com/problems/group-anagrams/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Sorting](https://leetcode.com/tag/sorting/)


Given an array of strings `strs`, group **the anagrams** together. You can return the answer in **any order**.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**Example 2:**

```
Input: strs = [""]
Output: [[""]]
```

**Example 3:**

```
Input: strs = ["a"]
Output: [["a"]]
```

**Constraints:**

*   `1 <= strs.length <= 10<sup>4</sup>`
*   `0 <= strs[i].length <= 100`
*   `strs[i]` consists of lowercase English letters.


#### Solution

Language: **Python**

```python
from collections import defaultdict

def groupAnagrams(strs):
    d = defaultdict(list)
    for str in strs:
        d[''.join(sorted(str))].append(str)
    return [list_item for _, list_item in d.iteritems()]

groupAnagrams(strs = ["eat", "tea", "tan", "ate", "nat", "bat"])

class Solution:
    def groupAnagrams(strs):
        ans = collections.defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            ans[tuple(count)].append(s)
        return ans.values()
```

### [187\. Repeated DNA Sequences](https://leetcode.com/problems/repeated-dna-sequences/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/), [Sliding Window](https://leetcode.com/tag/sliding-window/), [Rolling Hash](https://leetcode.com/tag/rolling-hash/), [Hash Function](https://leetcode.com/tag/hash-function/)


The **DNA sequence** is composed of a series of nucleotides abbreviated as `'A'`, `'C'`, `'G'`, and `'T'`.

*   For example, `"ACGAATTCCG"` is a **DNA sequence**.

When studying **DNA**, it is useful to identify repeated sequences within the DNA.

Given a string `s` that represents a **DNA sequence**, return all the **`10`-letter-long** sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in **any order**.

**Example 1:**

```
Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
Output: ["AAAAACCCCC","CCCCCAAAAA"]
```

**Example 2:**

```
Input: s = "AAAAAAAAAAAAA"
Output: ["AAAAAAAAAA"]
```

**Constraints:**

*   `1 <= s.length <= 10<sup>5</sup>`
*   `s[i]` is either `'A'`, `'C'`, `'G'`, or `'T'`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def findRepeatedDnaSequences(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        seen = set()
        repeated = set()
        N = len(s)
        for i in range(N):
            cur = s[i : i+ 10]
            if cur in seen:
                repeated.add(cur)
            else:
                seen.add(cur)
        return list(repeated)

class Solution:
    # @param s, a string
    # @return a list of strings
    def findRepeatedDnaSequences(self, s):
        sequences = collections.defaultdict(int) #set '0' as the default value for non-existing keys
        for i in range(len(s)):
            sequences[s[i:i+10]] += 1#add 1 to the count
        return [key for key, value in sequences.iteritems() if value > 1] #extract the relevant keys
```

### [205\. Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/)

Difficulty: **Easy**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/)


Given two strings `s` and `t`, _determine if they are isomorphic_.

Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

**Example 1:**

```
Input: s = "egg", t = "add"
Output: true
```

**Example 2:**

```
Input: s = "foo", t = "bar"
Output: false
```

**Example 3:**

```
Input: s = "paper", t = "title"
Output: true
```

**Constraints:**

*   `1 <= s.length <= 5 * 10<sup>4</sup>`
*   `t.length == s.length`
*   `s` and `t` consist of any valid ascii character.


#### Solution

Language: **Python**

```python
def isIsomorphic(s, t):
    def helper(s, t):
        lookup = {}
        for l_s, l_t in zip(s, t):
            if l_s in lookup:
                if l_t != lookup[l_s]:
                    return False
            else:
                lookup[l_s] = l_t
        return True
    return helper(s, t) and helper(t, s)

if __name__ == "__main__":
    isIsomorphic("egga", "addd") == False
    isIsomorphic("egg", "add") == True
    isIsomorphic("foo", "bar") == False
    isIsomorphic("paper", "title") == True
```

### [609\. Find Duplicate File in System](https://leetcode.com/problems/find-duplicate-file-in-system/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/)


Given a list `paths` of directory info, including the directory path, and all the files with contents in this directory, return _all the duplicate files in the file system in terms of their paths_. You may return the answer in **any order**.

A group of duplicate files consists of at least two files that have the same content.

A single directory info string in the input list has the following format:

*   `"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"`

It means there are `n` files `(f1.txt, f2.txt ... fn.txt)` with content `(f1_content, f2_content ... fn_content)` respectively in the directory "`root/d1/d2/.../dm"`. Note that `n >= 1` and `m >= 0`. If `m = 0`, it means the directory is just the root directory.

The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:

*   `"directory_path/file_name.txt"`

**Example 1:**

```
Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"]
Output: [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]
```

**Example 2:**

```
Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)"]
Output: [["root/a/2.txt","root/c/d/4.txt"],["root/a/1.txt","root/c/3.txt"]]
```

**Constraints:**

*   `1 <= paths.length <= 2 * 10<sup>4</sup>`
*   `1 <= paths[i].length <= 3000`
*   `1 <= sum(paths[i].length) <= 5 * 10<sup>5</sup>`
*   `paths[i]` consist of English letters, digits, `'/'`, `'.'`, `'('`, `')'`, and `' '`.
*   You may assume no files or directories share the same name in the same directory.
*   You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info.

**Follow up:**

*   Imagine you are given a real file system, how will you search files? DFS or BFS?
*   If the file content is very large (GB level), how will you modify your solution?
*   If you can only read the file by 1kb each time, how will you modify your solution?
*   What is the time complexity of your modified solution? What is the most time-consuming part and memory-consuming part of it? How to optimize?
*   How to make sure the duplicated files you find are not false positive?


#### Solution

Language: **Python**

```python
class Solution(object):
    def findDuplicate(self, paths):
        """
        :type paths: List[str]
        :rtype: List[List[str]]
        """
        d = collections.defaultdict(list)
        for path in paths:
            path = path.split(' ')
            dir = path[0]
            files = path[1: ]
            for file in files:
                file_name, content = file.split('(')
                content = content[: -1]
                file_name = dir + '/' + file_name
                d[content].append(file_name)
        res = []
        for content, ls in d.iteritems():
            if len(ls) > 1:
                res.append(ls)
        return res
```

### [423\. Reconstruct Original Digits from English](https://leetcode.com/problems/reconstruct-original-digits-from-english/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/)


Given a string `s` containing an out-of-order English representation of digits `0-9`, return _the digits in **ascending** order_.

**Example 1:**

```
Input: s = "owoztneoer"
Output: "012"
```

**Example 2:**

```
Input: s = "fviefuro"
Output: "45"
```

**Constraints:**

*   `1 <= s.length <= 10<sup>5</sup>`
*   `s[i]` is one of the characters `["e","g","f","i","h","o","n","s","r","u","t","w","v","x","z"]`.
*   `s` is **guaranteed** to be valid.


#### Solution

Language: **Python**

```python
class Solution:
    def originalDigits(self, s):
        cnt = Counter(s)
        Digits = ["zero","two","four","six","eight","one","three","five","seven","nine"]
        Corresp = [0,2,4,6,8,1,3,5,7,9]
        Counters = [Counter(digit) for digit in Digits]
        Found = [0]*10
        for it, C in enumerate(Counters):
            k = min(cnt[x]//C[x] for x in C)
            for i in C.keys(): C[i] *= k
            cnt -= C
            Found[Corresp[it]] = k

        return "".join([str(i)*Found[i] for i in range(10)])   
```

### [1807\. Evaluate the Bracket Pairs of a String](https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/)


You are given a string `s` that contains some bracket pairs, with each pair containing a **non-empty** key.

*   For example, in the string `"(name)is(age)yearsold"`, there are **two** bracket pairs that contain the keys `"name"` and `"age"`.

You know the values of a wide range of keys. This is represented by a 2D string array `knowledge` where each `knowledge[i] = [key<sub style="display: inline;">i</sub>, value<sub style="display: inline;">i</sub>]` indicates that key `key<sub style="display: inline;">i</sub>` has a value of `value<sub style="display: inline;">i</sub>`.

You are tasked to evaluate **all** of the bracket pairs. When you evaluate a bracket pair that contains some key `key<sub style="display: inline;">i</sub>`, you will:

*   Replace `key<sub style="display: inline;">i</sub>` and the bracket pair with the key's corresponding `value<sub style="display: inline;">i</sub>`.
*   If you do not know the value of the key, you will replace `key<sub style="display: inline;">i</sub>` and the bracket pair with a question mark `"?"` (without the quotation marks).

Each key will appear at most once in your `knowledge`. There will not be any nested brackets in `s`.

Return _the resulting string after evaluating **all** of the bracket pairs._

**Example 1:**

```
Input: s = "(name)is(age)yearsold", knowledge = [["name","bob"],["age","two"]]
Output: "bobistwoyearsold"
Explanation:
The key "name" has a value of "bob", so replace "(name)" with "bob".
The key "age" has a value of "two", so replace "(age)" with "two".
```

**Example 2:**

```
Input: s = "hi(name)", knowledge = [["a","b"]]
Output: "hi?"
Explanation: As you do not know the value of the key "name", replace "(name)" with "?".
```

**Example 3:**

```
Input: s = "(a)(a)(a)aaa", knowledge = [["a","yes"]]
Output: "yesyesyesaaa"
Explanation: The same key can appear multiple times.
The key "a" has a value of "yes", so replace all occurrences of "(a)" with "yes".
Notice that the "a"s not in a bracket pair are not evaluated.
```

**Constraints:**

*   `1 <= s.length <= 10<sup>5</sup>`
*   `0 <= knowledge.length <= 10<sup>5</sup>`
*   `knowledge[i].length == 2`
*   `1 <= key<sub style="display: inline;">i</sub>.length, value<sub style="display: inline;">i</sub>.length <= 10`
*   `s` consists of lowercase English letters and round brackets `'('` and `')'`.
*   Every open bracket `'('` in `s` will have a corresponding close bracket `')'`.
*   The key in each bracket pair of `s` will be non-empty.
*   There will not be any nested bracket pairs in `s`.
*   `key<sub style="display: inline;">i</sub>` and `value<sub style="display: inline;">i</sub>` consist of lowercase English letters.
*   Each `key<sub style="display: inline;">i</sub>` in `knowledge` is unique.


#### Solution

Language: **Python**

```python
class Solution(object):
    def evaluate(self, s, knowledge):
        """
        :type s: str
        :type knowledge: List[List[str]]
        :rtype: str
        """
        d = {}
        for pair in knowledge:
            key, value = pair
            d[key] = value
        res = ''
        find_bracket = False
        for ch in s:
            if ch not in '()' and not find_bracket:
                res += ch
            elif ch == "(":
                find_bracket = True
                tmp = ''
            elif ch == ")":                
                res += d[tmp] if tmp in d else '?'
                find_bracket = False
            else:
                tmp += ch
        return res
```

### [1248\. Count Number of Nice Subarrays :fire:](https://leetcode.com/problems/count-number-of-nice-subarrays/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [Sliding Window](https://leetcode.com/tag/sliding-window/)


Given an array of integers `nums` and an integer `k`. A continuous subarray is called **nice** if there are `k` odd numbers on it.

Return _the number of **nice** sub-arrays_.

**Example 1:**

```
Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
```

**Example 2:**

```
Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There is no odd numbers in the array.
```

**Example 3:**

```
Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16
```

**Constraints:**

*   `1 <= nums.length <= 50000`
*   `1 <= nums[i] <= 10^5`
*   `1 <= k <= nums.length`


#### Solution

Language: **Python**

```python
class Solution(object):
    def numberOfSubarrays(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        d = {}
        presum = 0
        d[presum] = 1
        for num in nums:
            presum += num % 2
            if presum in d:
                d[presum] += 1
            else:
                d[presum] = 1
        count = 0
        for presum in d:
            if presum - k in d:
                count += d[presum - k] * d[presum]
        return count
```

### [554\. Brick Wall](https://leetcode.com/problems/brick-wall/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/)


There is a rectangular brick wall in front of you with `n` rows of bricks. The `i<sup>th</sup>` row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.

Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.

Given the 2D array `wall` that contains the information about the wall, return _the minimum number of crossed bricks after drawing such a vertical line_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg)

```
Input: wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
Output: 2
```

**Example 2:**

```
Input: wall = [[1],[1],[1]]
Output: 3
```

**Constraints:**

*   `n == wall.length`
*   `1 <= n <= 10<sup>4</sup>`
*   `1 <= wall[i].length <= 10<sup>4</sup>`
*   `1 <= sum(wall[i].length) <= 2 * 10<sup>4</sup>`
*   `sum(wall[i])` is the same for each row `i`.
*   `1 <= wall[i][j] <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

```python
class Solution(object):
    def leastBricks(self, wall):
        """
        :type wall: List[List[int]]
        :rtype: int
        """
        d = {}
        for line in wall:
            cum_sum = 0
            for num in line[ :-1]:
                cum_sum += num
                d[cum_sum] = d.get(cum_sum, 0) + 1
        return len(wall) if not d else len(wall) - max(d.values())
```

### [1189\. Maximum Number of Balloons :rainbow:](https://leetcode.com/problems/maximum-number-of-balloons/)

Difficulty: **Easy**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Counting](https://leetcode.com/tag/counting/)


Given a string `text`, you want to use the characters of `text` to form as many instances of the word **"balloon"** as possible.

You can use each character in `text` **at most once**. Return the maximum number of instances that can be formed.

**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/09/05/1536_ex1_upd.JPG)**

```
Input: text = "nlaebolko"
Output: 1
```

**Example 2:**

**![](https://assets.leetcode.com/uploads/2019/09/05/1536_ex2_upd.JPG)**

```
Input: text = "loonbalxballpoon"
Output: 2
```

**Example 3:**

```
Input: text = "leetcode"
Output: 0
```

**Constraints:**

*   `1 <= text.length <= 10<sup>4</sup>`
*   `text` consists of lower case English letters only.


#### Solution

Language: **Python**

```python
class Solution(object):
    def maxNumberOfBalloons(self, text):
        """
        :type text: str
        :rtype: int
        """
        t_counter = {}
        for s in 'balloon':
            t_counter[s] = t_counter.get(s, 0) + 1

        print (t_counter)
        counter = {}
        for s in t_counter.keys():
            counter[s] = 0

        for s in text:
            if s in t_counter:
                counter[s] = counter[s] + 1

        res = float('inf')
        for s, freq in counter.items():
            res = min(res, freq // t_counter[s])

        return res
```

### [1930\. Unique Length-3 Palindromic Subsequences :fire:](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/)


Given a string `s`, return _the number of **unique palindromes of length three** that are a **subsequence** of_ `s`.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted **once**.

A **palindrome** is a string that reads the same forwards and backwards.

A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

*   For example, `"ace"` is a subsequence of `"<u style="display: inline;">a</u>b<u style="display: inline;">c</u>d<u style="display: inline;">e</u>"`.

**Example 1:**

```
Input: s = "aabca"
Output: 3
Explanation: The 3 palindromic subsequences of length 3 are:
- "aba" (subsequence of "aabca")
- "aaa" (subsequence of "aabca")
- "aca" (subsequence of "aabca")
```

**Example 2:**

```
Input: s = "adc"
Output: 0
Explanation: There are no palindromic subsequences of length 3 in "adc".
```

**Example 3:**

```
Input: s = "bbcbaba"
Output: 4
Explanation: The 4 palindromic subsequences of length 3 are:
- "bbb" (subsequence of "bbcbaba")
- "bcb" (subsequence of "bbcbaba")
- "bab" (subsequence of "bbcbaba")
- "aba" (subsequence of "bbcbaba")
```

**Constraints:**

*   `3 <= s.length <= 10<sup>5</sup>`
*   `s` consists of only lowercase English letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def countPalindromicSubsequence(self, s):
        """
        :type s: str
        :rtype: int
        """
        res = set()
        left = set()
        right = collections.Counter(s)
        
        for i, ch in enumerate(s):
            right[ch] -= 1
            if right[ch] == 0:
                right.pop(ch)
            
            for j in range(26):
                c = chr(ord('a') + j)
                if c in left and c in right:
                    res.add((ch, c))

            left.add(ch)

        return len(res)             
```

## Sliding Window
### [438\. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Sliding Window](https://leetcode.com/tag/sliding-window/)


Given two strings `s` and `p`, return _an array of all the start indices of_ `p`_'s anagrams in_ `s`. You may return the answer in **any order**.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
```

**Example 2:**

```
Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
```

**Constraints:**

*   `1 <= s.length, p.length <= 3 * 10<sup>4</sup>`
*   `s` and `p` consist of lowercase English letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def findAnagrams(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: List[int]
        """
        k = len(p)
        counter = collections.Counter(p)
        counter_cur = collections.Counter(s[: k - 1])
        l = 0
        res = []
        for i, ch in enumerate(s[k - 1: ]):
            counter_cur[ch] += 1
            if counter_cur == counter:
                res.append(i)

            counter_cur[s[l]] -= 1
            if counter_cur[s[l]] == 0:
                del counter_cur[s[l]]
            l += 1
        return res
```

### [76\. Minimum Window Substring :rainbow:](https://leetcode.com/problems/minimum-window-substring/)

Difficulty: **Hard**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Sliding Window](https://leetcode.com/tag/sliding-window/)


Given two strings `s` and `t` of lengths `m` and `n` respectively, return _the **minimum window substring** of_ `s` _such that every character in_ `t` _(**including duplicates**) is included in the window. If there is no such substring__, return the empty string_ `""`_._

The testcases will be generated such that the answer is **unique**.

A **substring** is a contiguous sequence of characters within the string.

**Example 1:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:**

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:**

```
Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
```

**Constraints:**

*   `m == s.length`
*   `n == t.length`
*   `1 <= m, n <= 10<sup>5</sup>`
*   `s` and `t` consist of uppercase and lowercase English letters.

**Follow up:** Could you find an algorithm that runs in `O(m + n)` time?

#### Solution

Language: **Python**

Time / Space Complexity : O(|S| + |T|)
```python
def minWindow(s, t):
    result , letter_needed = '', {}
    j, count, min_len = 0, 0, len(s) + 1 # count: num_letter_reached in t
    for item in t:
        letter_needed[item] = letter_needed.get(item, 0) + 1
    for i, chr in enumerate(s):
        if chr not in letter_needed:
            continue
        letter_needed[chr] -= 1
        if letter_needed[chr] >= 0:
            count += 1
        while count == len(t):
            if min_len > i - j + 1:
                min_len = i - j + 1
                result = s[j: i + 1]
            if s[j] in letter_needed:
                letter_needed[s[j]] += 1
                if letter_needed[s[j]] > 0:
                    count -= 1
            j += 1
    return result

minWindow(s = "ADBANCX", t = "ABC")
minWindow(s = "ADOBECODEBANC", t = "ABC")
minWindow(s = "a", t = "a")
minWindow(s = "a", t = "aa")
```

### [340\. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Sliding Window](https://leetcode.com/tag/sliding-window/)


Given a string `s` and an integer `k`, return _the length of the longest substring of_ `s` _that contains at most_ `k` _**distinct** characters_.

**Example 1:**

```
Input: s = "eceba", k = 2
Output: 3
Explanation: The substring is "ece" with length 3.
```

**Example 2:**

```
Input: s = "aa", k = 1
Output: 2
Explanation: The substring is "aa" with length 2.
```

**Constraints:**

*   `1 <= s.length <= 5 * 10<sup>4</sup>`
*   `0 <= k <= 50`


#### Solution

Language: **Python**

```python
class Solution(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        n, left, right = len(s), 0, 0
        counter = collections.Counter()
        res = 0
        while right < n:
            counter[s[right]] += 1
            while len(counter) > k:
                counter[s[left]] -= 1
                if counter[s[left]] == 0:
                    del counter[s[left]]
                left += 1
            res = max(res, right - left + 1)    
            right += 1
        return res
```

### [1004\. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Sliding Window](https://leetcode.com/tag/sliding-window/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/)


Given a binary array `nums` and an integer `k`, return _the maximum number of consecutive_ `1`_'s in the array if you can flip at most_ `k` `0`'s.

**Example 1:**

```
Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1\. The longest subarray is underlined.
```

**Example 2:**

```
Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1\. The longest subarray is underlined.
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `nums[i]` is either `0` or `1`.
*   `0 <= k <= nums.length`


#### Solution

Language: **Python**


```python
def longestOnes(nums, k):
    global_max = 0
    for i in range(len(nums)):
        for j in range(i):
            n = len(nums[j: i + 1])
            if sum(nums[j: i + 1]) + k >= n:
                global_max = max(global_max, n)
    return global_max

longestOnes(nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2)
longestOnes(nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3)

def longestOnes(nums, k):
    result = 0
    i = 0
    for j in range(len(nums)):
        if nums[j] == 0:
            k -= 1
        if k < 0:
            if nums[i] == 0:
                k += 1
            i += 1
        result = max(result, j - i + 1)
    return result

longestOnes(nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2)
longestOnes(nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3)
```

### [3\. Longest Substring Without Repeating Characters :rainbow:](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Sliding Window](https://leetcode.com/tag/sliding-window/)


Given a string `s`, find the length of the **longest substring** without repeating characters.

**Example 1:**

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Example 4:**

```
Input: s = ""
Output: 0
```

**Constraints:**

*   `0 <= s.length <= 5 * 10<sup>4</sup>`
*   `s` consists of English letters, digits, symbols and spaces.


#### Solution

Language: **Python**

```python
def lengthOfLongestSubstring(s):
    counter = {}
    left = 0
    right = 0
    result = 0
    for right in range(len(s)):
        counter[s[right]] = counter.get(s[right], 0) + 1
        while counter[s[right]] > 1:
            counter[s[left]] -= 1
            left += 1
        result = max(result, right - left + 1)
    return result

lengthOfLongestSubstring('abcabcbb')
lengthOfLongestSubstring('bbbbb')
lengthOfLongestSubstring('pwwkew')
lengthOfLongestSubstring('aacdb')
```

### [567\. Permutation in String](https://leetcode.com/problems/permutation-in-string/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/), [Sliding Window](https://leetcode.com/tag/sliding-window/)


Given two strings `s1` and `s2`, return `true` _if_ `s2` _contains a permutation of_ `s1`_, or_ `false` _otherwise_.

In other words, return `true` if one of `s1`'s permutations is the substring of `s2`.

**Example 1:**

```
Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
```

**Example 2:**

```
Input: s1 = "ab", s2 = "eidboaoo"
Output: false
```

**Constraints:**

*   `1 <= s1.length, s2.length <= 10<sup>4</sup>`
*   `s1` and `s2` consist of lowercase English letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        k = len(s1)
        counter1 = collections.Counter(s1)
        counter2 = collections.Counter(s2[: k - 1])
        l = 0
        for ch in s2[k - 1: ]:
            counter2[ch] += 1
            if counter2 == counter1:
                return True

            counter2[s2[l]] -= 1
            if counter2[s2[l]] == 0:
                del counter2[s2[l]]
            l += 1

        return False
```

### [209\. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Sliding Window](https://leetcode.com/tag/sliding-window/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/)


Given an array of positive integers `nums` and a positive integer `target`, return the minimal length of a **contiguous subarray** `[nums<sub style="display: inline;">l</sub>, nums<sub style="display: inline;">l+1</sub>, ..., nums<sub style="display: inline;">r-1</sub>, nums<sub style="display: inline;">r</sub>]` of which the sum is greater than or equal to `target`. If there is no such subarray, return `0` instead.

**Example 1:**

```
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
```

**Example 2:**

```
Input: target = 4, nums = [1,4,4]
Output: 1
```

**Example 3:**

```
Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0
```

**Constraints:**

*   `1 <= target <= 10<sup>9</sup>`
*   `1 <= nums.length <= 10<sup>5</sup>`
*   `1 <= nums[i] <= 10<sup>5</sup>`

**Follow up:** If you have figured out the `O(n)` solution, try coding another solution of which the time complexity is `O(n log(n))`.

#### Solution

Language: **Python**

```python
# not ac
def minSubArrayLen(target, nums):
    result = len(nums)
    left = 0
    cum_sum = 0
    for i, num in enumerate(nums):
        cum_sum += num
        while cum_sum >= target:
            result = min(result, i - left + 1)
            cum_sum -= nums[left]
            left += 1
    return result if result != len(nums) else 0

minSubArrayLen(target = 7, nums = [2,3,1,2,4,3])
minSubArrayLen(target = 4, nums = [1,4,4])
minSubArrayLen(target = 11, nums = [1,1,1,1,1,1,1,1])
```

### [424\. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Sliding Window](https://leetcode.com/tag/sliding-window/)


You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**

```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
```

**Example 2:**

```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
```

**Constraints:**

*   `1 <= s.length <= 10<sup>5</sup>`
*   `s` consists of only uppercase English letters.
*   `0 <= k <= s.length`


#### Solution

Language: **Python**

```python
class Solution(object):
    def characterReplacement(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        N = len(s)
        left, right = 0, 0 # [left, right] 
        counter = collections.Counter()
        res = 0
        while right < N:
            counter[s[right]] += 1
            while right - left + 1 - counter.most_common(1)[0][1] > k:
                counter[s[left]] -= 1
                left += 1
            res = max(res, right - left + 1)
            right += 1
        return res
```

### [713\. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Sliding Window](https://leetcode.com/tag/sliding-window/)


Given an array of integers `nums` and an integer `k`, return _the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than_ `k`.

**Example 1:**

```
Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
```

**Example 2:**

```
Input: nums = [1,2,3], k = 0
Output: 0
```

**Constraints:**

*   `1 <= nums.length <= 3 * 10<sup>4</sup>`
*   `1 <= nums[i] <= 1000`
*   `0 <= k <= 10<sup>6</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        N = len(nums)
        prod = 1
        l, r = 0, 0
        res = 0
        while r < N:
            prod *= nums[r]
            while l <= r and prod >= k:
                prod /= nums[l]
                l += 1
            res += r - l + 1
            r += 1
        return res
```

### [1838\. Frequency of the Most Frequent Element :fire:](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Greedy](https://leetcode.com/tag/greedy/), [Sliding Window](https://leetcode.com/tag/sliding-window/), [Sorting](https://leetcode.com/tag/sorting/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/)


The **frequency** of an element is the number of times it occurs in an array.

You are given an integer array `nums` and an integer `k`. In one operation, you can choose an index of `nums` and increment the element at that index by `1`.

Return _the **maximum possible frequency** of an element after performing **at most**_ `k` _operations_.

**Example 1:**

```
Input: nums = [1,2,4], k = 5
Output: 3
Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].
4 has a frequency of 3.
```

**Example 2:**

```
Input: nums = [1,4,8,13], k = 5
Output: 2
Explanation: There are multiple optimal solutions:
- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.
```

**Example 3:**

```
Input: nums = [3,9,6], k = 2
Output: 1
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `1 <= nums[i] <= 10<sup>5</sup>`
*   `1 <= k <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def maxFrequency(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        nums.sort()
        res = 0
        l = 0
        total = 0
        for r in range(len(nums)):
            total += nums[r]
            window_size = r - l + 1
            while window_size * nums[r] > total + k: # consider nums[r] is most frequent character
                total -= nums[r]
                l += 1
            res = max(res, r - l + 1)
        return res

```

### [1423\. Maximum Points You Can Obtain from Cards :rainbow:](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Sliding Window](https://leetcode.com/tag/sliding-window/), [Prefix Sum](https://leetcode.com/tag/prefix-sum/)


There are several cards **arranged in a row**, and each card has an associated number of points. The points are given in the integer array `cardPoints`.

In one step, you can take one card from the beginning or from the end of the row. You have to take exactly `k` cards.

Your score is the sum of the points of the cards you have taken.

Given the integer array `cardPoints` and the integer `k`, return the _maximum score_ you can obtain.

**Example 1:**

```
Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1\. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.
```

**Example 2:**

```
Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.
```

**Example 3:**

```
Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.
```

**Constraints:**

*   `1 <= cardPoints.length <= 10<sup>5</sup>`
*   `1 <= cardPoints[i] <= 10<sup>4</sup>`
*   `1 <= k <= cardPoints.length`


#### Solution

Language: **Python**

```python
class Solution(object):
    def maxScore(self, cardPoints, k):
        """
        :type cardPoints: List[int]
        :type k: int
        :rtype: int
        """
        l, r = 0, len(cardPoints) - k
        total = sum(cardPoints[r: ])
        res = total
        
        while r < len(cardPoints):
            total += cardPoints[l] - cardPoints[r]
            res = max(res, total)
            r += 1
            l += 1

        return res
        '''
        def dfs(l, r, k):
            if l > r or k <= 0:
                return 0
            if (l, r) in memo:
                return memo[(l, r)]

            res = max(cardPoints[l] + dfs(l + 1, r, k - 1), cardPoints[r] + dfs(l, r - 1, k - 1))
            memo[(l, r)] = res
            return res
            
        
        #self.score = 0
        memo = {}
        return dfs(0, len(cardPoints) - 1, k)
        '''
```

## String
### [680\. Valid Palindrome II :rainbow:](https://leetcode.com/problems/valid-palindrome-ii/)

Difficulty: **Easy**  

Related Topics: [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/), [Greedy](https://leetcode.com/tag/greedy/)


Given a string `s`, return `true` _if the_ `s` _can be palindrome after deleting **at most one** character from it_.

**Example 1:**

```
Input: s = "aba"
Output: true
```

**Example 2:**

```
Input: s = "abca"
Output: true
Explanation: You could delete the character 'c'.
```

**Example 3:**

```
Input: s = "abc"
Output: false
```

**Constraints:**

*   `1 <= s.length <= 10<sup>5</sup>`
*   `s` consists of lowercase English letters.


#### Solution

Language: **Python**

```python
class Solution(object):
    def validPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        # Time: O(n)
        # Space: O(n)
        left, right = 0, len(s) - 1
        while left < right:
            if s[left] != s[right]:
                one, two = s[left:right], s[left + 1:right + 1]
                return one == one[::-1] or two == two[::-1]
            left, right = left + 1, right - 1
        return True

#  Generic for "you may delete at most N character"
class Solution(object):
    def validPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """

        def helper(s, i, j, k):
            if k < 0:
                return False

            if i >= j:
                return True
            if s[i] == s[j]:
                return helper(s, i + 1, j - 1, k)
            else:
                return helper(s, i + 1, j, k - 1) or helper(s, i, j - 1, k - 1)
        i, j = 0, len(s) - 1
        return helper(s, i, j, 1)
```

### [157\. Read N Characters Given Read4](https://leetcode.com/problems/read-n-characters-given-read4/)

Difficulty: **Easy**  

Related Topics: [String](https://leetcode.com/tag/string/), [Simulation](https://leetcode.com/tag/simulation/), [Interactive](https://leetcode.com/tag/interactive/)


Given a `file` and assume that you can only read the file using a given method `read4`, implement a method to read `n` characters.

**Method read4:**

The API `read4` reads **four consecutive characters** from `file`, then writes those characters into the buffer array `buf4`.

The return value is the number of actual characters read.

Note that `read4()` has its own file pointer, much like `FILE *fp` in C.

**Definition of read4:**

```
    Parameter:  char[] buf4
    Returns:    int

buf4[] is a destination, not a source. The results from read4 will be copied to buf4[].
```

Below is a high-level example of how `read4` works:

![](https://assets.leetcode.com/uploads/2020/07/01/157_example.png)

```
File file("abcde"); // File is "abcde", initially file pointer (fp) points to 'a'
char[] buf4 = new char[4]; // Create buffer with enough space to store characters
read4(buf4); // read4 returns 4\. Now buf4 = "abcd", fp points to 'e'
read4(buf4); // read4 returns 1\. Now buf4 = "e", fp points to end of file
read4(buf4); // read4 returns 0\. Now buf4 = "", fp points to end of file
```

**Method read:**

By using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.

The return value is the number of actual characters read.

**Definition of read:**

```
    Parameters:	char[] buf, int n
    Returns:	int

buf[] is a destination, not a source. You will need to write the results to buf[].
```

**Note:**

*   Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.
*   The `read` function will only be called once for each test case.
*   You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.

**Example 1:**

```
Input: file = "abc", n = 4
Output: 3
Explanation: After calling your read method, buf should contain "abc". We read a total of 3 characters from the file, so return 3.
Note that "abc" is the file's content, not buf. buf is the destination buffer that you will have to write the results to.
```

**Example 2:**

```
Input: file = "abcde", n = 5
Output: 5
Explanation: After calling your read method, buf should contain "abcde". We read a total of 5 characters from the file, so return 5.
```

**Example 3:**

```
Input: file = "abcdABCD1234", n = 12
Output: 12
Explanation: After calling your read method, buf should contain "abcdABCD1234". We read a total of 12 characters from the file, so return 12.
```

**Example 4:**

```
Input: file = "leetcode", n = 5
Output: 5
Explanation: After calling your read method, buf should contain "leetc". We read a total of 5 characters from the file, so return 5.
```

**Constraints:**

*   `1 <= file.length <= 500`
*   `file` consist of English letters and digits.
*   `1 <= n <= 1000`


#### Solution

Language: **Python**

* [](https://www.youtube.com/watch?v=Zw2UzFsMfZI&ab_channel=%E5%AE%B0%E7%9B%B8%E5%B0%8F%E7%94%98%E7%BD%97):  cache,  buf 
* [](https://leetcode.com/problems/read-n-characters-given-read4/solution/)

```python
"""
The read4 API is already defined for you.

    @param buf, a list of characters
    @return an integer
    def read4(buf):

# Below is an example of how the read4 API can be called.
file = File("abcdefghijk") # File is "abcdefghijk", initially file pointer (fp) points to 'a'
buf = [' '] * 4 # Create buffer with enough space to store characters
read4(buf) # read4 returns 4. Now buf = ['a','b','c','d'], fp points to 'e'
read4(buf) # read4 returns 4. Now buf = ['e','f','g','h'], fp points to 'i'
read4(buf) # read4 returns 3. Now buf = ['i','j','k',...], fp points to end of file
"""

class Solution:
    def read(self, buf, n):
        """
        :type buf: Destination buffer (List[str])
        :type n: Number of characters to read (int)
        :rtype: The number of actual characters read (int)
        """
        ## RC ##
        ## APPROACH : BUFFER READING ##
        ## 1. dont get confused with question description, our final buf will have min( n, all the characters that are in file)
        ## 2. At any point cache4, will maximum of 4 characters or count returned from the read4.
        ## 3. As I can read utmost 4 chars at a time, I create an array of size 4 and pass it to the function read4(cache4). That read4 function will fill my cache4 and returns the count how many characters it filled.
        ## 4. I take those cache4 chars filled and append it to my final buf.

        cache4 = [''] * 4         
        read = 0
        while read < n:
            count = read4(cache4)             # Read file into cache4 && count -> num of chars in cache4
            if not count: break             # no of chars to read, EOF
            count = min(count, n - read)    # if n = 5 and file size is 8, in second read you have to take only n-read i.e 5-4 = 1
            buf[read:] = cache4[:count]       # Copy from cache4 to buf.
            read += count
        return read                         # we have return total num of characters read
```

### [158\. Read N Characters Given read4 II - Call Multiple Times](https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/)

Difficulty: **Hard**  

Related Topics: [String](https://leetcode.com/tag/string/), [Simulation](https://leetcode.com/tag/simulation/), [Interactive](https://leetcode.com/tag/interactive/)


Given a `file` and assume that you can only read the file using a given method `read4`, implement a method `read` to read `n` characters. Your method `read` may be **called multiple times**.

**Method read4:**

The API `read4` reads **four consecutive characters** from `file`, then writes those characters into the buffer array `buf4`.

The return value is the number of actual characters read.

Note that `read4()` has its own file pointer, much like `FILE *fp` in C.

**Definition of read4:**

```
    Parameter:  char[] buf4
    Returns:    int

buf4[] is a destination, not a source. The results from read4 will be copied to buf4[].
```

Below is a high-level example of how `read4` works:

![](https://assets.leetcode.com/uploads/2020/07/01/157_example.png)

```
File file("abcde"); // File is "abcde", initially file pointer (fp) points to 'a'
char[] buf4 = new char[4]; // Create buffer with enough space to store characters
read4(buf4); // read4 returns 4\. Now buf4 = "abcd", fp points to 'e'
read4(buf4); // read4 returns 1\. Now buf4 = "e", fp points to end of file
read4(buf4); // read4 returns 0\. Now buf4 = "", fp points to end of file
```

**Method read:**

By using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.

The return value is the number of actual characters read.

**Definition of read:**

```
    Parameters:	char[] buf, int n
    Returns:	int

buf[] is a destination, not a source. You will need to write the results to buf[].
```

**Note:**

*   Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.
*   The read function may be **called multiple times**.
*   Please remember to **RESET** your class variables declared in Solution, as static/class variables are persisted across multiple test cases. Please see for more details.
*   You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.
*   It is guaranteed that in a given test case the same buffer `buf` is called by `read`.

**Example 1:**

```
Input: file = "abc", queries = [1,2,1]
Output: [1,2,0]
Explanation: The test case represents the following scenario:
File file("abc");
Solution sol;
sol.read(buf, 1); // After calling your read method, buf should contain "a". We read a total of 1 character from the file, so return 1.
sol.read(buf, 2); // Now buf should contain "bc". We read a total of 2 characters from the file, so return 2.
sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.
Assume buf is allocated and guaranteed to have enough space for storing all characters from the file.
```

**Example 2:**

```
Input: file = "abc", queries = [4,1]
Output: [3,0]
Explanation: The test case represents the following scenario:
File file("abc");
Solution sol;
sol.read(buf, 4); // After calling your read method, buf should contain "abc". We read a total of 3 characters from the file, so return 3.
sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.
```

**Constraints:**

*   `1 <= file.length <= 500`
*   `file` consist of English letters and digits.
*   `1 <= queries.length <= 10`
*   `1 <= queries[i] <= 500`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/discuss/1338071/Short-python-solution-and-explanation)
* [](https://www.youtube.com/watch?v=E-UIXA6LTIc&ab_channel=%E5%AE%B0%E7%9B%B8%E5%B0%8F%E7%94%98%E7%BD%97)

```python
# The read4 API is already defined for you.
# def read4(cache4: List[str]) -> int:

class Solution:
    def __init__(self):
        self.cache4 = []

    def read(self, buf: List[str], n: int) -> int:
        count = 0
        while n:
            # load buffer if empty
            if len(self.cache4) == 0:
                self.cache4 = [None] * 4
                read4(self.cache4)

            # Read from head; check if reading got nothing
            if self.cache4[0] is None:
                break

            buf[count] = self.cache4[0]
            self.cache4.pop(0)

            count += 1
            n -= 1


        return count
```

### [415\. Add Strings](https://leetcode.com/problems/add-strings/)

Difficulty: **Easy**  

Related Topics: [Math](https://leetcode.com/tag/math/), [String](https://leetcode.com/tag/string/), [Simulation](https://leetcode.com/tag/simulation/)


Given two non-negative integers, `num1` and `num2` represented as string, return _the sum of_ `num1` _and_ `num2` _as a string_.

You must solve the problem without using any built-in library for handling large integers (such as `BigInteger`). You must also not convert the inputs to integers directly.

**Example 1:**

```
Input: num1 = "11", num2 = "123"
Output: "134"
```

**Example 2:**

```
Input: num1 = "456", num2 = "77"
Output: "533"
```

**Example 3:**

```
Input: num1 = "0", num2 = "0"
Output: "0"
```

**Constraints:**

*   `1 <= num1.length, num2.length <= 10<sup>4</sup>`
*   `num1` and `num2` consist of only digits.
*   `num1` and `num2` don't have any leading zeros except for the zero itself.


#### Solution

Language: **Python**


```python
def addStrings(num1, num2):
    i = len(num1) - 1
    j = len(num2) - 1
    result = ''
    carry = 0
    while i >= 0 or j >= 0:
        if i >= 0:
            carry += int(num1[i])
            i -= 1
        if j >= 0:
            carry += int(num2[j])
            j -= 1
        carry, curr = divmod(carry, 10)
        result = str(curr) + result
    if carry > 0:
        result = str(carry) + result
    return result  
```

### [161\. One Edit Distance](https://leetcode.com/problems/one-edit-distance/)

Difficulty: **Medium**  

Related Topics: [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/)


Given two strings `s` and `t`, return `true` if they are both one edit distance apart, otherwise return `false`.

A string `s` is said to be one distance apart from a string `t` if you can:

*   Insert **exactly one** character into `s` to get `t`.
*   Delete **exactly one** character from `s` to get `t`.
*   Replace **exactly one** character of `s` with **a different character** to get `t`.

**Example 1:**

```
Input: s = "ab", t = "acb"
Output: true
Explanation: We can insert 'c' into s to get t.
```

**Example 2:**

```
Input: s = "", t = ""
Output: false
Explanation: We cannot get t from s by only one step.
```

**Example 3:**

```
Input: s = "a", t = ""
Output: true
```

**Example 4:**

```
Input: s = "", t = "A"
Output: true
```

**Constraints:**

*   `0 <= s.length <= 10<sup>4</sup>`
*   `0 <= t.length <= 10<sup>4</sup>`
*   `s` and `t` consist of lower-case letters, upper-case letters **and/or** digits.


#### Solution

Language: **Python**

```python
class Solution:
    def isOneEditDistance(self, s: 'str', t: 'str') -> 'bool':
        ns, nt = len(s), len(t)

        # Ensure that s is shorter than t.
        if ns > nt:
            return self.isOneEditDistance(t, s)

        # The strings are NOT one edit away distance  
        # if the length diff is more than 1.
        if nt - ns > 1:
            return False

        for i in range(ns):
            if s[i] != t[i]:
                # if strings have the same length
                if ns == nt:
                    return s[i + 1:] == t[i + 1:]
                # if strings have different lengths
                else:
                    return s[i:] == t[i + 1:]

        # If there is no diffs on ns distance
        # the strings are one edit away only if
        # t has one more character.
        return ns + 1 == nt

isOneEditDistance(s = "ab", t = "acb")
isOneEditDistance(s = "cab", t = "ad")
isOneEditDistance(s = "1203", t = "1213")
```    

### [8\. String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/)


Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).

The algorithm for `myAtoi(string s)` is as follows:

1.  Read in and ignore any leading whitespace.
2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.
3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.
4.  Convert these digits into an integer (i.e. `"123" -> 123`, `"0032" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).
5.  If the integer is out of the 32-bit signed integer range `[-2<sup>31</sup>, 2<sup>31</sup> - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-2<sup>31</sup>` should be clamped to `-2<sup>31</sup>`, and integers greater than `2<sup>31</sup> - 1` should be clamped to `2<sup>31</sup> - 1`.
6.  Return the integer as the final result.

**Note:**

*   Only the space character `' '` is considered a whitespace character.
*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.

**Example 1:**

```
Input: s = "42"
Output: 42
Explanation: The underlined characters are what is read in, the caret is the current reader position.
Step 1: "42" (no characters read because there is no leading whitespace)
         ^
Step 2: "42" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "42" ("42" is read in)
           ^
The parsed integer is 42.
Since 42 is in the range [-231, 231 - 1], the final result is 42.
```

**Example 2:**

```
Input: s = "   -42"
Output: -42
Explanation:
Step 1: "   -42" (leading whitespace is read and ignored)
            ^
Step 2: "   -42" ('-' is read, so the result should be negative)
             ^
Step 3: "   -42" ("42" is read in)
               ^
The parsed integer is -42.
Since -42 is in the range [-231, 231 - 1], the final result is -42.
```

**Example 3:**

```
Input: s = "4193 with words"
Output: 4193
Explanation:
Step 1: "4193 with words" (no characters read because there is no leading whitespace)
         ^
Step 2: "4193 with words" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "4193 with words" ("4193" is read in; reading stops because the next character is a non-digit)
             ^
The parsed integer is 4193.
Since 4193 is in the range [-231, 231 - 1], the final result is 4193.
```

**Example 4:**

```
Input: s = "words and 987"
Output: 0
Explanation:
Step 1: "words and 987" (no characters read because there is no leading whitespace)
         ^
Step 2: "words and 987" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "words and 987" (reading stops immediately because there is a non-digit 'w')
         ^
The parsed integer is 0 because no digits were read.
Since 0 is in the range [-231, 231 - 1], the final result is 0.
```

**Example 5:**

```
Input: s = "-91283472332"
Output: -2147483648
Explanation:
Step 1: "-91283472332" (no characters read because there is no leading whitespace)
         ^
Step 2: "-91283472332" ('-' is read, so the result should be negative)
          ^
Step 3: "-91283472332" ("91283472332" is read in)
                     ^
The parsed integer is -91283472332.
Since -91283472332 is less than the lower bound of the range [-231, 231 - 1], the final result is clamped to -231 = -2147483648\.
```

**Constraints:**

*   `0 <= s.length <= 200`
*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def myAtoi(self, s):
        """
        :type s: str
        :rtype: int
        """
        string = s.strip()
        if len(string)==0:
            return 0
        flag = 1
        ans = []
        if string[0] == '+':
            string = string[1:]
        elif string[0] == '-':
            flag = -1
            string = string[1:]
        for i in string:
            if i.isnumeric():
                ans.append(i)
            else:
                break
        if len(ans) == 0:
            return 0
        res = int(''.join(ans))
        res = flag*res
        if 2**31*(-1) <= res <= 2**31-1:
            return res
        else:
            if res > 2**31-1:
                return 2**31-1
            elif res < 2**31*(-1):
                return 2**31*(-1)
```

### [678\. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Stack](https://leetcode.com/tag/stack/), [Greedy](https://leetcode.com/tag/greedy/)


Given a string `s` containing only three types of characters: `'('`, `')'` and `'*'`, return `true` _if_ `s` _is **valid**_.

The following rules define a **valid** string:

*   Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.
*   Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.
*   Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.
*   `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string `""`.

**Example 1:**

```
Input: s = "()"
Output: true
```

**Example 2:**

```
Input: s = "(*)"
Output: true
```

**Example 3:**

```
Input: s = "(*))"
Output: true
```

**Constraints:**

*   `1 <= s.length <= 100`
*   `s[i]` is `'('`, `')'` or `'*'`.


#### Solution

Language: **Python**

```python
def checkValidString(s):
    """
    :type s: str
    :rtype: bool
    """
    left_min, left_max = 0, 0 # min left open parenthses
    for c in s:
        if c == '(':
            left_min, left_max = left_min + 1, left_max + 1
        elif c == ')':
            left_min, left_max = left_min - 1, left_max - 1
        else:
            left_min, left_max = left_min - 1, left_max + 1

        if left_max < 0:
            return False
        if left_min < 0: # ( * ) (
            left_min = 0

    return left_min == 0 # i.e. 0 in [left_min, left_max]

checkValidString(s='**)))') # -1 -1
checkValidString(s='((()*') # 1 3
checkValidString(s='*') # 0 1
checkValidString(s='(*))') # 0 0
checkValidString(s='((**') # 0 4     
```

### [468\. Validate IP Address](https://leetcode.com/problems/validate-ip-address/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/)


Given a string `queryIP`, return `"IPv4"` if IP is a valid IPv4 address, `"IPv6"` if IP is a valid IPv6 address or `"Neither"` if IP is not a correct IP of any type.

**A valid IPv4** address is an IP in the form `"x<sub style="display: inline;">1</sub>.x<sub style="display: inline;">2</sub>.x<sub style="display: inline;">3</sub>.x<sub style="display: inline;">4</sub>"` where `0 <= x<sub style="display: inline;">i</sub> <= 255` and `x<sub style="display: inline;">i</sub>` **cannot contain** leading zeros. For example, `"192.168.1.1"` and `"192.168.1.0"` are valid IPv4 addresses but `"192.168.01.1"`, while `"192.168.1.00"` and `"192.168@1.1"` are invalid IPv4 addresses.

**A valid IPv6** address is an IP in the form `"x<sub style="display: inline;">1</sub>:x<sub style="display: inline;">2</sub>:x<sub style="display: inline;">3</sub>:x<sub style="display: inline;">4</sub>:x<sub style="display: inline;">5</sub>:x<sub style="display: inline;">6</sub>:x<sub style="display: inline;">7</sub>:x<sub style="display: inline;">8</sub>"` where:

*   `1 <= x<sub style="display: inline;">i</sub>.length <= 4`
*   `x<sub style="display: inline;">i</sub>` is a **hexadecimal string** which may contain digits, lower-case English letter (`'a'` to `'f'`) and upper-case English letters (`'A'` to `'F'`).
*   Leading zeros are allowed in `x<sub style="display: inline;">i</sub>`.

For example, "`2001:0db8:85a3:0000:0000:8a2e:0370:7334"` and "`2001:db8:85a3:0:0:8A2E:0370:7334"` are valid IPv6 addresses, while "`2001:0db8:85a3::8A2E:037j:7334"` and "`02001:0db8:85a3:0000:0000:8a2e:0370:7334"` are invalid IPv6 addresses.

**Example 1:**

```
Input: queryIP = "172.16.254.1"
Output: "IPv4"
Explanation: This is a valid IPv4 address, return "IPv4".
```

**Example 2:**

```
Input: queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334"
Output: "IPv6"
Explanation: This is a valid IPv6 address, return "IPv6".
```

**Example 3:**

```
Input: queryIP = "256.256.256.256"
Output: "Neither"
Explanation: This is neither a IPv4 address nor a IPv6 address.
```

**Example 4:**

```
Input: queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334:"
Output: "Neither"
```

**Example 5:**

```
Input: queryIP = "1e1.4.5.6"
Output: "Neither"
```

**Constraints:**

*   `queryIP` consists only of English letters, digits and the characters `'.'` and `':'`.


#### Solution

Language: **Python**

```python
import string

def validIPAddress(IP):
    xs = IP.split('.')
    if len(xs) == 4:
        for x in xs:
            if not x.isdigit() or not 0 <= int(x) <= 255 or len(x) > 1 and x[0] == '0':
                return 'Neither'
        return 'IPv4'
    xs = IP.split(':')
    if len(xs) == 8:
        for x in xs:
            if not 1 <= len(x) <= 4 or not all(c in string.hexdigits for c in x):
                return 'Neither'
        return 'IPv6'
    return 'Neither'

validIPAddress(IP = "172.16.254.1")
validIPAddress(IP = "2001:0db8:85a3:0:0:8A2E:0370:7334")
validIPAddress(IP = "256.256.256.256")
validIPAddress(IP = "2001:0db8:85a3:0:0:8A2E:0370:7334:")
validIPAddress(IP = "1e1.4.5.6")
```

### [151\. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)

Difficulty: **Medium**  

Related Topics: [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/)


Given an input string `s`, reverse the order of the **words**.

A **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.

Return _a string of the words in reverse order concatenated by a single space._

**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

**Example 1:**

```
Input: s = "the sky is blue"
Output: "blue is sky the"
```

**Example 2:**

```
Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
```

**Example 3:**

```
Input: s = "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
```

**Example 4:**

```
Input: s = "  Bob    Loves  Alice   "
Output: "Alice Loves Bob"
```

**Example 5:**

```
Input: s = "Alice does not even like bob"
Output: "bob like even not does Alice"
```

**Constraints:**

*   `1 <= s.length <= 10<sup>4</sup>`
*   `s` contains English letters (upper-case and lower-case), digits, and spaces `' '`.
*   There is **at least one** word in `s`.

**Follow-up: **If the string data type is mutable in your language, can you solve it **in-place** with `O(1)` extra space?


#### Solution

Language: **Python**

```python
def reverseWords(s):
    words = s.split()
    words.reverse()
    return ' '.join(words)

if __name__ == "__main__":
    reverseWords("the sky is blue")
    reverseWords("  hello world!  ")
    reverseWords("example good a")

def reverseWords(s):
    s = list(" ".join(s.split()))[::-1]
    i = 0
    while i < len(s):
        start = i
        while i < len(s) and not s[i].isspace():
            i += 1
        self.reverse(s, start, i-1)
        i += 1
    return "".join(s)

def reverse(s, i, j):
    while i < j:
        s[i], s[j] = s[j], s[i]
        i += 1; j -= 1
```

### [38\. Count and Say](https://leetcode.com/problems/count-and-say/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/)


The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:

*   `countAndSay(1) = "1"`
*   `countAndSay(n)` is the way you would "say" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.

To determine how you "say" a digit string, split it into the **minimal** number of groups so that each group is a contiguous section all of the **same character.** Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.

For example, the saying and conversion for digit string `"3322251"`:

![](https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg)

Given a positive integer `n`, return _the_ `n<sup>th</sup>` _term of the **count-and-say** sequence_.

**Example 1:**

```
Input: n = 1
Output: "1"
Explanation: This is the base case.
```

**Example 2:**

```
Input: n = 4
Output: "1211"
Explanation:
countAndSay(1) = "1"
countAndSay(2) = say "1" = one 1 = "11"
countAndSay(3) = say "11" = two 1's = "21"
countAndSay(4) = say "21" = one 2 + one 1 = "12" + "11" = "1211"
```

**Constraints:**

*   `1 <= n <= 30`


#### Solution

Language: **Python**

```python
def getNext(s):
    i = j = 0
    n = len(s)
    result = ''
    for i in range(n):
        if s[j] != s[i]:
            result += str(i - j) + s[j]
            j = i
        if i == n - 1:
            result += str(i - j + 1) + s[i]
    return result

def countAndSay(n):
    result = '1'
    for _ in range(n - 1):
        result = getNext(result)
    return result    

countAndSay(1)
countAndSay(2)
countAndSay(3)
countAndSay(4)
countAndSay(5)
```

### [68\. Text Justification :rainbow:](https://leetcode.com/problems/text-justification/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/), [Simulation](https://leetcode.com/tag/simulation/)


Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left-justified and no extra space is inserted between words.

**Note:**

*   A word is defined as a character sequence consisting of non-space characters only.
*   Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
*   The input array `words` contains at least one word.

**Example 1:**

```
Input: words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
Output:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
```

**Example 2:**

```
Input: words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
Output:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
Explanation: Note that the last line is "shall be    " instead of "shall     be", because the last line must be left-justified instead of fully-justified.
Note that the second line is also left-justified becase it contains only one word.
```

**Example 3:**

```
Input: words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"], maxWidth = 20
Output:
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]
```

**Constraints:**

*   `1 <= words.length <= 300`
*   `1 <= words[i].length <= 20`
*   `words[i]` consists of only English letters and symbols.
*   `1 <= maxWidth <= 100`
*   `words[i].length <= maxWidth`


#### Solution

Language: **Python**

```python
def fullJustify(words, maxWidth):
    result = []
    cur = []
    count_letters = 0
    for word in words:
        if count_letters + len(cur) + len(word) > maxWidth:
            for i in range(maxWidth - count_letters):
                number_space = len(cur) - 1
                cur[i % (number_space or 1)] += ' '
            result.append(''.join(cur))
            cur = []
            count_letters = 0
        cur.append(word)
        count_letters += len(word)
    return result + [' '.join(cur).ljust(maxWidth)]
```

### [1541\. Minimum Insertions to Balance a Parentheses String](https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/), [Greedy](https://leetcode.com/tag/greedy/)


Given a parentheses string `s` containing only the characters `'('` and `')'`. A parentheses string is **balanced** if:

*   Any left parenthesis `'('` must have a corresponding two consecutive right parenthesis `'))'`.
*   Left parenthesis `'('` must go before the corresponding two consecutive right parenthesis `'))'`.

In other words, we treat `'('` as openning parenthesis and `'))'` as closing parenthesis.

For example, `"())"`, `"())(())))"` and `"(())())))"` are balanced, `")()"`, `"()))"` and `"(()))"` are not balanced.

You can insert the characters `'('` and `')'` at any position of the string to balance it if needed.

Return _the minimum number of insertions_ needed to make `s` balanced.

**Example 1:**

```
Input: s = "(()))"
Output: 1
Explanation: The second '(' has two matching '))', but the first '(' has only ')' matching. We need to to add one more ')' at the end of the string to be "(())))" which is balanced.
```

**Example 2:**

```
Input: s = "())"
Output: 0
Explanation: The string is already balanced.
```

**Example 3:**

```
Input: s = "))())("
Output: 3
Explanation: Add '(' to match the first '))', Add '))' to match the last '('.
```

**Example 4:**

```
Input: s = "(((((("
Output: 12
Explanation: Add 12 ')' to balance the string.
```

**Example 5:**

```
Input: s = ")))))))"
Output: 5
Explanation: Add 4 '(' at the beginning of the string and one ')' at the end. The string becomes "(((())))))))".
```

**Constraints:**

*   `1 <= s.length <= 10^5`
*   `s` consists of `'('` and `')'` only.


#### Solution

Language: **Python**

```python
def minInsertions(s):
    """
    :type s: str
    :rtype: int
    """
    s += "$"  # appending dummy character at the end, to make things simpler
    left_braces, count, i = 0, 0, 0
    while( i < len(s)-1 ):
        if s[i] == "(":
            left_braces, i = left_braces + 1, i + 1
        elif s[i] == ")" and s[i+1] == ")":
            if left_braces:
                left_braces -= 1
            else:
                count += 1                  # one open brace required
            i += 2
        elif s[i] == ")" and s[i+1] != ")":
            if left_braces:
                count += 1                  # one close brace required
                left_braces -= 1
            else:
                count += 2                  # one open and one close brace required
            i += 1
    return count + (left_braces * 2)        # close braces required at the end for all the remaining left braces

minInsertions(s = "(()))") == 1
minInsertions(s = "))())(") == 3
minInsertions(s = "((((((") == 12
```

### [418\. Sentence Screen Fitting :fire:](https://leetcode.com/problems/sentence-screen-fitting/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


Given a `rows x cols` screen and a `sentence` represented as a list of strings, return _the number of times the given sentence can be fitted on the screen_.

The order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.

**Example 1:**

```
Input: sentence = ["hello","world"], rows = 2, cols = 8
Output: 1
Explanation:
hello---
world---
The character '-' signifies an empty space on the screen.
```

**Example 2:**

```
Input: sentence = ["a", "bcd", "e"], rows = 3, cols = 6
Output: 2
Explanation:
a-bcd-
e-a---
bcd-e-
The character '-' signifies an empty space on the screen.
```

**Example 3:**

```
Input: sentence = ["i","had","apple","pie"], rows = 4, cols = 5
Output: 1
Explanation:
i-had
apple
pie-i
had--
The character '-' signifies an empty space on the screen.
```

**Constraints:**

*   `1 <= sentence.length <= 100`
*   `1 <= sentence[i].length <= 10`
*   `sentence[i]` consists of lowercase English letters.
*   `1 <= rows, cols <= 2 * 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
def wordsTyping(sentence, rows, cols):
    s = " ".join(sentence) + " "
    n = len(s)
    start = 0

    for i in range(rows):
        start += cols

        # Find the index of the nearest space
        while s[start % n] != " ":
            start -= 1

        # Index of next word is after the space
        start += 1

    return start // n

wordsTyping(sentence = ["a", "bcd", "e"], rows = 3, cols = 6)
```

### [833\. Find And Replace in String](https://leetcode.com/problems/find-and-replace-in-string/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/), [Sorting](https://leetcode.com/tag/sorting/)


You are given a **0-indexed** string `s` that you must perform `k` replacement operations on. The replacement operations are given as three **0-indexed** parallel arrays, `indices`, `sources`, and `targets`, all of length `k`.

To complete the `i<sup>th</sup>` replacement operation:

1.  Check if the **substring** `sources[i]` occurs at index `indices[i]` in the **original string** `s`.
2.  If it does not occur, **do nothing**.
3.  Otherwise if it does occur, **replace** that substring with `targets[i]`.

For example, if `s = "<u style="display: inline;">ab</u>cd"`, `indices[i] = 0`, `sources[i] = "ab"`, and `targets[i] = "eee"`, then the result of this replacement will be `"<u style="display: inline;">eee</u>cd"`.

All replacement operations must occur **simultaneously**, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will **not overlap**.

*   For example, a testcase with `s = "abc"`, `indices = [0, 1]`, and `sources = ["ab","bc"]` will not be generated because the `"ab"` and `"bc"` replacements overlap.

Return _the **resulting string** after performing all replacement operations on_ `s`.

A **substring** is a contiguous sequence of characters in a string.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/06/12/833-ex1.png)

```
Input: s = "abcd", indices = [0, 2], sources = ["a", "cd"], targets = ["eee", "ffff"]
Output: "eeebffff"
Explanation:
"a" occurs at index 0 in s, so we replace it with "eee".
"cd" occurs at index 2 in s, so we replace it with "ffff".
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/06/12/833-ex2-1.png)

```
Input: s = "abcd", indices = [0, 2], sources = ["ab","ec"], targets = ["eee","ffff"]
Output: "eeecd"
Explanation:
"ab" occurs at index 0 in s, so we replace it with "eee".
"ec" does not occur at index 2 in s, so we do nothing.
```

**Constraints:**

*   `1 <= s.length <= 1000`
*   `k == indices.length == sources.length == targets.length`
*   `1 <= k <= 100`
*   `0 <= indexes[i] < s.length`
*   `1 <= sources[i].length, targets[i].length <= 50`
*   `s` consists of only lowercase English letters.
*   `sources[i]` and `targets[i]` consist of only lowercase English letters.


#### Solution

Language: **Python**

```python
def findReplaceString(s, indices, sources, targets):
    d = {indices: (sources, target) for indices, sources, target in zip(indices, sources, targets)}
    result = ''
    i = 0
    while i < len(s):
        if i in d and s[i: i + len(d[i][0])] == d[i][0]:
            result += d[i][1]
            i += len(d[i][0])
        else:
            result += s[i]
            i += 1
    return result

findReplaceString(s = "abcd", indices = [0, 2], sources = ["a", "cd"], targets = ["eee", "ffff"])
```

* Time Complexity
    * Let `N = len(S)` and `M = len(indexes)`
    * Building `lookup` ---> `O(M)`
    * Building `result` ---> `O(N)`
* Space Complexity
    * Building `lookup` ---> `O(M)`
    * Building `result` ---> `O(N)`



### [271\. Encode and Decode Strings](https://leetcode.com/problems/encode-and-decode-strings/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/), [Design](https://leetcode.com/tag/design/)


Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

Machine 1 (sender) has the function:

```
string encode(vector <string>strs) {
  // ... your code
  return encoded_string;
}</string>
```

Machine 2 (receiver) has the function:

```
vector <string>decode(string s) {
  //... your code
  return strs;
}</string>
```

So Machine 1 does:

```
string encoded_string = encode(strs);
```

and Machine 2 does:

```
vector <string>strs2 = decode(encoded_string);</string>
```

`strs2` in Machine 2 should be the same as `strs` in Machine 1.

Implement the `encode` and `decode` methods.

You are not allowed to solve the problem using any serialize methods (such as `eval`).

**Example 1:**

```
Input: dummy_input = ["Hello","World"]
Output: ["Hello","World"]
Explanation:
Machine 1:
Codec encoder = new Codec();
String msg = encoder.encode(strs);
Machine 1 ---msg---> Machine 2

Machine 2:
Codec decoder = new Codec();
String[] strs = decoder.decode(msg);
```

**Example 2:**

```
Input: dummy_input = [""]
Output: [""]
```

**Constraints:**

*   `1 <= strs.length <= 200`
*   `0 <= strs[i].length <= 200`
*   `strs[i]` contains any possible characters out of `256` valid ASCII characters.

**Follow up:** Could you write a generalized algorithm to work on any possible set of characters?


#### Solution

Language: **Python**

```python
class Codec:
    def encode(self, strs):
        return ''.join('%d:' % len(s) + s for s in strs)

    def decode(self, s):
        strs = []
        i = 0
        while i < len(s):
            j = s.find(':', i)
            i = j + 1 + int(s[i:j])
            strs.append(s[j+1:i])
        return strs

codec = Codec()
s = codec.encode(["Hello","World"])
codec.decode(s)
```

### [811\. Subdomain Visit Count](https://leetcode.com/problems/subdomain-visit-count/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/)


A website domain `"discuss.leetcode.com"` consists of various subdomains. At the top level, we have `"com"`, at the next level, we have `"leetcode.com"` and at the lowest level, `"discuss.leetcode.com"`. When we visit a domain like `"discuss.leetcode.com"`, we will also visit the parent domains `"leetcode.com"` and `"com"` implicitly.

A **count-paired domain** is a domain that has one of the two formats `"rep d1.d2.d3"` or `"rep d1.d2"` where `rep` is the number of visits to the domain and `d1.d2.d3` is the domain itself.

*   For example, `"9001 discuss.leetcode.com"` is a **count-paired domain** that indicates that `discuss.leetcode.com` was visited `9001` times.

Given an array of **count-paired domains** `cpdomains`, return _an array of the **count-paired domains** of each subdomain in the input_. You may return the answer in **any order**.

**Example 1:**

```
Input: cpdomains = ["9001 discuss.leetcode.com"]
Output: ["9001 leetcode.com","9001 discuss.leetcode.com","9001 com"]
Explanation: We only have one website domain: "discuss.leetcode.com".
As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.
```

**Example 2:**

```
Input: cpdomains = ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
Output: ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]
Explanation: We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times.
For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.
```

**Constraints:**

*   `1 <= cpdomain.length <= 100`
*   `1 <= cpdomain[i].length <= 100`
*   `cpdomain[i]` follows either the `"rep<sub style="display: inline;">i</sub> d1<sub style="display: inline;">i</sub>.d2<sub style="display: inline;">i</sub>.d3<sub style="display: inline;">i</sub>"` format or the `"rep<sub style="display: inline;">i</sub> d1<sub style="display: inline;">i</sub>.d2<sub style="display: inline;">i</sub>"` format.
*   `rep<sub style="display: inline;">i</sub>` is an integer in the range `[1, 10<sup>4</sup>]`.
*   `d1<sub style="display: inline;">i</sub>`, `d2<sub style="display: inline;">i</sub>`, and `d3<sub style="display: inline;">i</sub>` consist of lowercase English letters.


#### Solution

Language: **Python**

```python
class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        d = {}
        for cpdomain in cpdomains:
            cpdomain = cpdomain.split(" ")
            cp, domain = int(cpdomain[0]), cpdomain[1]
            domain = domain.split('.')
            n = len(domain)
            for i in range(n - 1, -1, -1):
                key = '.'.join(domain[i:n])
                d[key] = d.get(key, 0) + cp
        result = []
        for domain, count in d.items():
            result.append(str(count) + ' ' +  domain)
        return result
```

### [635\. Design Log Storage System :rainbow:](https://leetcode.com/problems/design-log-storage-system/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Design](https://leetcode.com/tag/design/), [Ordered Set](https://leetcode.com/tag/ordered-set/)


You are given several logs, where each log contains a unique ID and timestamp. Timestamp is a string that has the following format: `Year:Month:Day:Hour:Minute:Second`, for example, `2017:01:01:23:59:59`. All domains are zero-padded decimal numbers.

Implement the `LogSystem` class:

*   `LogSystem()` Initializes the `LogSystem`object.
*   `void put(int id, string timestamp)` Stores the given log `(id, timestamp)` in your storage system.
*   `int[] retrieve(string start, string end, string granularity)` Returns the IDs of the logs whose timestamps are within the range from `start` to `end` inclusive. `start` and `end` all have the same format as `timestamp`, and `granularity` means how precise the range should be (i.e. to the exact `Day`, `Minute`, etc.). For example, `start = "2017:01:01:23:59:59"`, `end = "2017:01:02:23:59:59"`, and `granularity = "Day"` means that we need to find the logs within the inclusive range from **Jan. 1st 2017** to **Jan. 2nd 2017**, and the `Hour`, `Minute`, and `Second` for each log entry can be ignored.

**Example 1:**

```
Input
["LogSystem", "put", "put", "put", "retrieve", "retrieve"]
[[], [1, "2017:01:01:23:59:59"], [2, "2017:01:01:22:59:59"], [3, "2016:01:01:00:00:00"], ["2016:01:01:01:01:01", "2017:01:01:23:00:00", "Year"], ["2016:01:01:01:01:01", "2017:01:01:23:00:00", "Hour"]]
Output
[null, null, null, null, [3, 2, 1], [2, 1]]

Explanation
LogSystem logSystem = new LogSystem();
logSystem.put(1, "2017:01:01:23:59:59");
logSystem.put(2, "2017:01:01:22:59:59");
logSystem.put(3, "2016:01:01:00:00:00");

// return [3,2,1], because you need to return all logs between 2016 and 2017.
logSystem.retrieve("2016:01:01:01:01:01", "2017:01:01:23:00:00", "Year");

// return [2,1], because you need to return all logs between Jan. 1, 2016 01:XX:XX and Jan. 1, 2017 23:XX:XX.
// Log 3 is not returned because Jan. 1, 2016 00:00:00 comes before the start of the range.
logSystem.retrieve("2016:01:01:01:01:01", "2017:01:01:23:00:00", "Hour");
```

**Constraints:**

*   `1 <= id <= 500`
*   `2000 <= Year <= 2017`
*   `1 <= Month <= 12`
*   `1 <= Day <= 31`
*   `0 <= Hour <= 23`
*   `0 <= Minute, Second <= 59`
*   `granularity` is one of the values `["Year", "Month", "Day", "Hour", "Minute", "Second"]`.
*   At most `500` calls will be made to `put` and `retrieve`.


#### Solution

Language: **Python**

```python
class LogSystem(object):
    def __init__(self):
        self.logs = []

    def put(self, tid, timestamp):
        self.logs.append((tid, timestamp))

    def retrieve(self, s, e, gra):
        index = {'Year': 5 - 1, 'Month': 8 - 1, 'Day': 11 - 1,
                 'Hour': 14 - 1, 'Minute': 17 - 1, 'Second': 20 - 1}[gra]
        start = s[:index]
        end = e[:index]

        return list(tid for tid, timestamp in self.logs
                      if start <= timestamp[:index] <= end)
```

## Linked List
### [23\. Merge k Sorted Lists :rainbow:](https://leetcode.com/problems/merge-k-sorted-lists/)

Difficulty: **Hard**  

Related Topics: [Linked List](https://leetcode.com/tag/linked-list/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Merge Sort](https://leetcode.com/tag/merge-sort/)


You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

*   `k == lists.length`
*   `0 <= k <= 10^4`
*   `0 <= lists[i].length <= 500`
*   `-10^4 <= lists[i][j] <= 10^4`
*   `lists[i]` is sorted in **ascending order**.
*   The sum of `lists[i].length` won't exceed `10^4`.


#### Solution

Language: **Python**

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        cur = dummy = ListNode(-1)
        heap = []
        for ls in lists:
            if ls:
                heapq.heappush(heap, (ls.val, ls))
        while heap:
            node = heappop(heap)[1]
            cur.next = node
            cur = cur.next
            if node.next:
                heapq.heappush(heap, (node.next.val, node.next))
        return dummy.next
```


### [143\. Reorder List :fire:](https://leetcode.com/problems/reorder-list/)

Difficulty: **Medium**  

Related Topics: [Linked List](https://leetcode.com/tag/linked-list/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Stack](https://leetcode.com/tag/stack/), [Recursion](https://leetcode.com/tag/recursion/)


You are given the head of a singly linked-list. The list can be represented as:

```
L0  L1    Ln - 1  Ln
```

_Reorder the list to be on the following form:_

```
L0  Ln  L1  Ln - 1  L2  Ln - 2  
```

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)

```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg)

```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
```

**Constraints:**

*   The number of nodes in the list is in the range `[1, 5 * 10<sup>4</sup>]`.
*   `1 <= Node.val <= 1000`


#### Solution

Language: **Python3**

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def reorderList(self, head):
        """
        :type head: ListNode
        :rtype: None Do not return anything, modify head in-place instead.
        """
        if not head:
            return

        # find the middle of linked list [Problem 876]
        # in 1->2->3->4->5->6 find 4
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # reverse the second part of the list [Problem 206]
        # convert 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4
        # reverse the second half in-place
        prev, curr = None, slow
        while curr:
            curr.next, prev, curr = prev, curr, curr.next       

        # merge two sorted linked lists [Problem 21]
        # merge 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4
        first, second = head, prev
        while second.next and first.next:
            first.next, first = second, first.next
            second.next, second = first, second.next
```

### [146\. LRU Cache :fire:](https://leetcode.com/problems/lru-cache/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Linked List](https://leetcode.com/tag/linked-list/), [Design](https://leetcode.com/tag/design/), [Doubly-Linked List](https://leetcode.com/tag/doubly-linked-list/)


Design a data structure that follows the constraints of a .

Implement the `LRUCache` class:

*   `LRUCache(int capacity)` Initialize the LRU cache with **positive** size `capacity`.
*   `int get(int key)` Return the value of the `key` if the key exists, otherwise return `-1`.
*   `void put(int key, int value)` Update the value of the `key` if the `key` exists. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the `capacity` from this operation, **evict** the least recently used key.

The functions `get` and `put` must each run in `O(1)` average time complexity.

**Example 1:**

```
Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
```

**Constraints:**

*   `1 <= capacity <= 3000`
*   `0 <= key <= 10<sup>4</sup>`
*   `0 <= value <= 10<sup>5</sup>`
*   At most 2` * 10<sup>5</sup>` calls will be made to `get` and `put`.


#### Solution

Language: **Python**

```python
from collections import OrderedDict

class LRUCache(object):
    def __init__(self, capacity):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key):
        if key not in self.cache:
            return -1
        val = self.cache[key]
        del self.cache[key]
        self.cache[key] = val
        return val

    def put(self, key, value):
        if key in self.cache:
            del self.cache[key]
        elif len(self.cache) == self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value

if __name__ == "__main__":
    cache = LRUCache(2)
    cache.put(1, 1)
    cache.put(2, 2)
    cache.get(1)
    cache.put(3,3)
    cache.get(2)
    cache.put(4,4)
    cache.get(1)
    cache.get(3)
    cache.get(4)

# sol2: use double linked list
class Node:
    def __init__(self, key, val):
        self.key, self.val = key, val
        self.prev, self.next = None, None

class LRUCache(object):

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.cap = capacity
        self.cache = {} # map key to value

        # left=LRU, right=most recent
        self.left, self.right = Node(0, 0), Node(0, 0)
        self.left.next, self.right.prev = self.right, self.left

    # remove from the list
    def remove(self, node):
        prev, nxt = node.prev, node.next
        prev.next, nxt.prev = nxt, prev

    # insert node at right
    def insert(self, node):
        prev, nxt = self.right.prev, self.right
        prev.next = nxt.prev = node
        node.next, node.prev = nxt, prev

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key in self.cache:
            self.remove(self.cache[key])
            self.insert(self.cache[key])
            return self.cache[key].val
        return -1

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: None
        """
        if key in self.cache:
            self.remove(self.cache[key])
        self.cache[key] = Node(key, value)
        self.insert(self.cache[key])

        if len(self.cache) > self.cap:
            # remove from the list and delete the LRU from the the hashmap
            lru = self.left.next
            self.remove(lru)
            del self.cache[lru.key]


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

### [138\. Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Linked List](https://leetcode.com/tag/linked-list/)


A linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.

Construct a of the list. The deep copy should consist of exactly `n` **brand new** nodes, where each new node has its value set to the value of its corresponding original node. Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. **None of the pointers in the new list should point to nodes in the original list**.

For example, if there are two nodes `X` and `Y` in the original list, where `X.random --> Y`, then for the corresponding two nodes `x` and `y` in the copied list, `x.random --> y`.

Return _the head of the copied linked list_.

The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]` where:

*   `val`: an integer representing `Node.val`
*   `random_index`: the index of the node (range from `0` to `n-1`) that the `random` pointer points to, or `null` if it does not point to any node.

Your code will **only** be given the `head` of the original linked list.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/12/18/e1.png)

```
Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/12/18/e2.png)

```
Input: head = [[1,1],[2,1]]
Output: [[1,1],[2,1]]
```

**Example 3:**

**![](https://assets.leetcode.com/uploads/2019/12/18/e3.png)**

```
Input: head = [[3,null],[3,0],[3,null]]
Output: [[3,null],[3,0],[3,null]]
```

**Constraints:**

*   `0 <= n <= 1000`
*   `-10<sup>4</sup> <= Node.val <= 10<sup>4</sup>`
*   `Node.random` is `null` or is pointing to some node in the linked list.


#### Solution

Language: **Python3**

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        oldToCopy = {None: None}

        cur = head
        while cur:
            copy = Node(cur.val)
            oldToCopy[cur] = copy
            cur = cur.next

        cur = head
        while cur:
            copy = oldToCopy[cur]
            copy.next = oldToCopy[cur.next]
            copy.random = oldToCopy[cur.random]
            cur = cur.next

        return oldToCopy[head]
```

### [114\. Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)

Difficulty: **Medium**  

Related Topics: [Linked List](https://leetcode.com/tag/linked-list/), [Stack](https://leetcode.com/tag/stack/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, flatten the tree into a "linked list":

*   The "linked list" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.
*   The "linked list" should be in the same order as a of the binary tree.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
Input: root = [1,2,5,3,4,null,6]
Output: [1,null,2,null,3,null,4,null,5,null,6]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Example 3:**

```
Input: root = [0]
Output: [0]
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 2000]`.
*   `-100 <= Node.val <= 100`

**Follow up:** Can you flatten the tree in-place (with `O(1)` extra space)?

#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:

    def flattenTree(self, node):

        # Handle the null scenario
        if not node:
            return None

        # For a leaf node, we simply return the
        # node as is.
        if not node.left and not node.right:
            return node

        # Recursively flatten the left subtree
        leftTail = self.flattenTree(node.left)

        # Recursively flatten the right subtree
        rightTail = self.flattenTree(node.right)

        # If there was a left subtree, we shuffle the connections
        # around so that there is nothing on the left side
        # anymore.
        if leftTail:
            leftTail.right = node.right
            node.right = node.left
            node.left = None

        # We need to return the "rightmost" node after we are
        # done wiring the new connections.
        return rightTail if rightTail else leftTail

    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """

        self.flattenTree(root)
```

### [206\. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)

Difficulty: **Easy**  

Related Topics: [Linked List](https://leetcode.com/tag/linked-list/), [Recursion](https://leetcode.com/tag/recursion/)


Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
Input: head = [1,2]
Output: [2,1]
```

**Example 3:**

```
Input: head = []
Output: []
```

**Constraints:**

*   The number of nodes in the list is the range `[0, 5000]`.
*   `-5000 <= Node.val <= 5000`

**Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?


#### Solution

Language: **Python**

* [Discussion](https://www.youtube.com/watch?v=bOOdi7S5Ar4&list=PLo4Ori3OC75DW0ScujZKViWewqydHESnL&index=32&ab_channel=AHTech)
```python
class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        pre, cur = None, head
        while cur:
            next = cur.next
            cur.next = pre
            pre = cur
            cur = next
        return pre

class Solution(object):
    def reverseList(self, head):
        if not head and not head.next:
            return head
        newhead = self.reverseList(head.next)
        next = head.next
        next.head = head
        head.next = None
```

### [160\. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)

Difficulty: **Easy**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Linked List](https://leetcode.com/tag/linked-list/), [Two Pointers](https://leetcode.com/tag/two-pointers/)


Given the heads of two singly linked-lists `headA` and `headB`, return _the node at which the two lists intersect_. If the two linked lists have no intersection at all, return `null`.

For example, the following two linked lists begin to intersect at node `c1`:

![](https://assets.leetcode.com/uploads/2021/03/05/160_statement.png)

The test cases are generated such that there are no cycles anywhere in the entire linked structure.

**Note** that the linked lists must **retain their original structure** after the function returns.

**Custom Judge:**

The inputs to the **judge** are given as follows (your program is **not** given these inputs):

*   `intersectVal` - The value of the node where the intersection occurs. This is `0` if there is no intersected node.
*   `listA` - The first linked list.
*   `listB` - The second linked list.
*   `skipA` - The number of nodes to skip ahead in `listA` (starting from the head) to get to the intersected node.
*   `skipB` - The number of nodes to skip ahead in `listB` (starting from the head) to get to the intersected node.

The judge will then create the linked structure based on these inputs and pass the two heads, `headA` and `headB` to your program. If you correctly return the intersected node, then your solution will be **accepted**.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)

```
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Intersected at '8'
Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)

```
Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Output: Intersected at '2'
Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png)

```
Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
Output: No intersection
Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.
```

**Constraints:**

*   The number of nodes of `listA` is in the `m`.
*   The number of nodes of `listB` is in the `n`.
*   `0 <= m, n <= 3 * 10<sup>4</sup>`
*   `1 <= Node.val <= 10<sup>5</sup>`
*   `0 <= skipA <= m`
*   `0 <= skipB <= n`
*   `intersectVal` is `0` if `listA` and `listB` do not intersect.
*   `intersectVal == listA[skipA] == listB[skipB]` if `listA` and `listB` intersect.

**Follow up:** Could you write a solution that runs in `O(n)` time and use only `O(1)` memory?

#### Solution

Language: **Python**

```python
class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        lenA = self.getListLen(headA)
        lenB = self.getListLen(headB)
        if lenA > lenB:
            for i in range(lenA - lenB):
                headA = headA.next
        elif lenA < lenB:
            for i in range(lenB - lenA):
                headB = headB.next
        while headA != headB:
            headA, headB = headA.next, headB.next
        return headA

    def getListLen(self, head):
        length = 0
        while head:
            length += 1
            head = head.next
        return length
```


### [61\. Rotate List](https://leetcode.com/problems/rotate-list/)

Difficulty: **Medium**  

Related Topics: [Linked List](https://leetcode.com/tag/linked-list/), [Two Pointers](https://leetcode.com/tag/two-pointers/)


Given the `head` of a linked list, rotate the list to the right by `k` places.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

```
Input: head = [1,2,3,4,5], k = 2
Output: [4,5,1,2,3]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)

```
Input: head = [0,1,2], k = 4
Output: [2,0,1]
```

**Constraints:**

*   The number of nodes in the list is in the range `[0, 500]`.
*   `-100 <= Node.val <= 100`
*   `0 <= k <= 2 * 10<sup>9</sup>`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/rotate-list/solution/)
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:

        # base cases
        if not head:
            return None
        if not head.next:
            return head

        # close the linked list into the ring
        old_tail = head
        n = 1
        while old_tail.next:
            old_tail = old_tail.next
            n += 1
        old_tail.next = head

        # find new tail : (n - k % n - 1)th node
        # and new head : (n - k % n)th node
        new_tail = head
        for i in range(n - k % n - 1):
            new_tail = new_tail.next
        new_head = new_tail.next

        # break the ring
        new_tail.next = None

        return new_head

head = Node(1, Node(2, Node(3, Node(4, Node(5)))))        
k  = 3
```

### [706\. Design HashMap](https://leetcode.com/problems/design-hashmap/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Linked List](https://leetcode.com/tag/linked-list/), [Design](https://leetcode.com/tag/design/), [Hash Function](https://leetcode.com/tag/hash-function/)


Design a HashMap without using any built-in hash table libraries.

Implement the `MyHashMap` class:

*   `MyHashMap()` initializes the object with an empty map.
*   `void put(int key, int value)` inserts a `(key, value)` pair into the HashMap. If the `key` already exists in the map, update the corresponding `value`.
*   `int get(int key)` returns the `value` to which the specified `key` is mapped, or `-1` if this map contains no mapping for the `key`.
*   `void remove(key)` removes the `key` and its corresponding `value` if the map contains the mapping for the `key`.

**Example 1:**

```
Input
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
Output
[null, null, null, 1, -1, null, 1, null, -1]

Explanation
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // The map is now [[1,1]]
myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]
```

**Constraints:**

*   `0 <= key, value <= 10<sup>6</sup>`
*   At most `10<sup>4</sup>` calls will be made to `put`, `get`, and `remove`.


#### Solution

Language: **Python**

```python
class MyHashMap:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.data = [Node() for _ in range(1000)]

    def hashcode(self, key):
        size = len(self.data)
        return key % size

    def put(self, key: int, value: int) -> None:
        """
        value will always be non-negative.
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                head.next.val = value
                return
            head = head.next
        head.next = Node(key, value)



    def get(self, key: int) -> int:
        """
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]
        while head.next:
            if head.next.key == key:
                return head.next.val
            head = head.next
        return -1

    def remove(self, key: int) -> None:
        """
        Removes the mapping of the specified value key if this map contains a mapping for the key
        """
        hashcode = self.hashcode(key)
        head = self.data[hashcode]

        while head.next:
            if head.next.key == key:
                toremove = head.next
                head.next = toremove.next
                toremove.next = None
                return
            head = head.next


class Node:
    def __init__(self, key = -1, val = -1, next = None):
        self.key = key
        self.val = val
        self.next = next
```

### [21\. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)

Difficulty: **Easy**  

Related Topics: [Linked List](https://leetcode.com/tag/linked-list/), [Recursion](https://leetcode.com/tag/recursion/)


You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.

Return _the head of the merged linked list_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

**Example 2:**

```
Input: list1 = [], list2 = []
Output: []
```

**Example 3:**

```
Input: list1 = [], list2 = [0]
Output: [0]
```

**Constraints:**

*   The number of nodes in both lists is in the range `[0, 50]`.
*   `-100 <= Node.val <= 100`
*   Both `list1` and `list2` are sorted in **non-decreasing** order.


#### Solution

Language: **Python**

```python
class Solution:
    def mergeTwoLists(self, l1, l2):
        # maintain an unchanging reference to node ahead of the return node.
        prehead = ListNode(-1)

        prev = prehead
        while l1 and l2:
            if l1.val <= l2.val:
                prev.next = l1
                l1 = l1.next
            else:
                prev.next = l2
                l2 = l2.next            
            prev = prev.next

        # At least one of l1 and l2 can still have nodes at this point, so connect
        # the non-null list to the end of the merged list.
        prev.next = l1 if l1 is not None else l2

        return prehead.next
```

### [237\. Delete Node in a Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list/)

Difficulty: **Easy**  

Related Topics: [Linked List](https://leetcode.com/tag/linked-list/)


Write a function to **delete a node** in a singly-linked list. You will **not** be given access to the `head` of the list, instead you will be given access to **the node to be deleted** directly.

It is **guaranteed** that the node to be deleted is **not a tail node** in the list.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/01/node1.jpg)

```
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/09/01/node2.jpg)

```
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
```

**Example 3:**

```
Input: head = [1,2,3,4], node = 3
Output: [1,2,4]
```

**Example 4:**

```
Input: head = [0,1], node = 0
Output: [1]
```

**Example 5:**

```
Input: head = [-3,5,-99], node = -3
Output: [5,-99]
```

**Constraints:**

*   The number of the nodes in the given list is in the range `[2, 1000]`.
*   `-1000 <= Node.val <= 1000`
*   The value of each node in the list is **unique**.
*   The `node` to be deleted is **in the list** and is **not a tail** node


#### Solution

Language: **Python**





node

`node.val = node.next.valnode.next = node.next.next`

[](https://stackoverflow.com/questions/28863026/deleting-a-specific-node-from-a-linked-list-python)
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        node.val = node.next.val
        node.next = node.next.next
```

### [141\. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

Difficulty: **Easy**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Linked List](https://leetcode.com/tag/linked-list/), [Two Pointers](https://leetcode.com/tag/two-pointers/)


Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.

Return `true` _if there is a cycle in the linked list_. Otherwise, return `false`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

```
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

```
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
```

**Constraints:**

*   The number of the nodes in the list is in the range `[0, 10<sup>4</sup>]`.
*   `-10<sup>5</sup> <= Node.val <= 10<sup>5</sup>`
*   `pos` is `-1` or a **valid index** in the linked-list.

**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?


#### Solution

Language: **Python**

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        slow, fast = head, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if slow == fast:
                return True
        return False
```


### [445\. Add Two Numbers II](https://leetcode.com/problems/add-two-numbers-ii/)

Difficulty: **Medium**  

Related Topics: [Linked List](https://leetcode.com/tag/linked-list/), [Math](https://leetcode.com/tag/math/), [Stack](https://leetcode.com/tag/stack/)


You are given two **non-empty** linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg)

```
Input: l1 = [7,2,4,3], l2 = [5,6,4]
Output: [7,8,0,7]
```

**Example 2:**

```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [8,0,7]
```

**Example 3:**

```
Input: l1 = [0], l2 = [0]
Output: [0]
```

**Constraints:**

*   The number of nodes in each linked list is in the range `[1, 100]`.
*   `0 <= Node.val <= 9`
*   It is guaranteed that the list represents a number that does not have leading zeros.

**Follow up:** Could you solve it without reversing the input lists?


#### Solution

Language: **Python**

```python
class Solution:
    def addTwoNumbers(self, l1, l2):
        st1, st2 = [], []
        while l1:
            st1.append(l1.val)
            l1 = l1.next

        while l2:
            st2.append(l2.val)
            l2 = l2.next

        carry, head = 0, None

        while st1 or st2 or carry:
            d1, d2 = 0, 0
            d1 = st1.pop() if st1 else 0
            d2 = st2.pop() if st2 else 0
            carry, digit = divmod(d1 + d2 + carry, 10)
            head_new = ListNode(digit)
            head_new.next = head
            head = head_new

        return head
```

## Tree
### [297\. Serialize and Deserialize Binary Tree :rainbow:](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)

Difficulty: **Hard**  

Related Topics: [String](https://leetcode.com/tag/string/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Design](https://leetcode.com/tag/design/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

**Clarification:** The input/output format is the same as . You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Example 3:**

```
Input: root = [1]
Output: [1]
```

**Example 4:**

```
Input: root = [1,2]
Output: [1,2]
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 10<sup>4</sup>]`.
*   `-1000 <= Node.val <= 1000`


#### Solution

Language: **Python**

Time/Space Complexity: O(N)
```python
import collections

class Codec:
    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """
        def preOrder(root):
            if not root:
                vals.append('#')
            else:
                vals.append(str(root.val))
                preOrder(root.left)
                preOrder(root.right)

        vals = []
        preOrder(root)

        return ' '.join(vals)

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """
        def build():
            if vals:
                val = vals.popleft()
                if val == '#':
                    return None
                root = Node(int(val))
                root.left = build()
                root.right = build()
                return root

        vals = collections.deque(val for val in data.split())
        return build()
```

### [124\. Binary Tree Maximum Path Sum :fire:](https://leetcode.com/problems/binary-tree-maximum-path-sum/)

Difficulty: **Hard**  

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.

The **path sum** of a path is the sum of the node's values in the path.

Given the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 3 * 10<sup>4</sup>]`.
*   `-1000 <= Node.val <= 1000`


#### Solution

Language: **Python**

```python
class Solution:
    def maxPathSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """

        def dfs(node):
            # the max sum end WITHOUT split
            if not node:
                return 0
            left = dfs(node.left)
            left = max(0, left)
            right = dfs(node.right)
            right = max(0, right)        

            # the max sum end WITH split
            res[0] = max(res[0], node.val + left + right)

            # 
            return node.val + max(left, right, 0)  

        res = [root.val]
        dfs(root)
        return res[0]
```

### [173\. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)

Difficulty: **Medium**  

Related Topics: [Stack](https://leetcode.com/tag/stack/), [Tree](https://leetcode.com/tag/tree/), [Design](https://leetcode.com/tag/design/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/), [Iterator](https://leetcode.com/tag/iterator/)


Implement the `BSTIterator` class that represents an iterator over the of a binary search tree (BST):

*   `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.
*   `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.
*   `int next()` Moves the pointer to the right, then returns the number at the pointer.

Notice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.

You may assume that `next()` calls will always be valid. That is, there will be at least a next number in the in-order traversal when `next()` is called.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png)

```
Input
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
Output
[null, 3, 7, true, 9, true, 15, true, 20, false]

Explanation
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 10<sup>5</sup>]`.
*   `0 <= Node.val <= 10<sup>6</sup>`
*   At most `10<sup>5</sup>` calls will be made to `hasNext`, and `next`.

**Follow up:**

*   Could you implement `next()` and `hasNext()` to run in average `O(1)` time and use `O(h)` memory, where `h` is the height of the tree?


#### Solution

Language: **Python**

```python
class BSTIterator:
    def __init__(self, root):
        self.stack = []
        self.pushleft(root)

    def next(self):
        node = self.stack.pop()
        self.pushleft(node.right)
        return node.val

    def hasNext(self):
        return self.stack

    def pushleft(self, root):
        while root:
            self.stack.append(root)
            root = root.left
```

### [543\. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, return _the length of the **diameter** of the tree_.

The **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.

The **length** of a path between two nodes is represented by the number of edges between them.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
```

**Example 2:**

```
Input: root = [1,2]
Output: 1
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 10<sup>4</sup>]`.
*   `-100 <= Node.val <= 100`


#### Solution

Language: **Python**

```python
class Solution:
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        self.diameter = 0
        self.getDepth(root)
        return self.diameter

    def getDepth(self, root):
        if not root:
            return 0
        left = self.getDepth(root.left)
        right = self.getDepth(root.right)
        self.diameter = max(self.diameter, left + right)
        return 1 + max(left, right)
```

### [235\. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the : The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [2,1], p = 2, q = 1
Output: 2
```

**Constraints:**

*   The number of nodes in the tree is in the range `[2, 10<sup>5</sup>]`.
*   `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`
*   All `Node.val` are **unique**.
*   `p != q`
*   `p` and `q` will exist in the BST.


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        val = root.val
        p_val = p.val
        q_val = q.val
        if p_val < val and q_val < val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p_val > val and q_val > val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
```

### [236\. Lowest Common Ancestor of a Binary Tree :rainbow:](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the : The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [1,2], p = 1, q = 2
Output: 1
```

**Constraints:**

*   The number of nodes in the tree is in the range `[2, 10<sup>5</sup>]`.
*   `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`
*   All `Node.val` are **unique**.
*   `p != q`
*   `p` and `q` will exist in the tree.


#### Solution

Language: **Python**

[236. DFS ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/)
Time/Space Complexity: O(N)
```python
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        if not root or root == p or root == q:
            return root
        # divde
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        # conquer
        if not left and not right: return # 1.
        if not left: return right # 3.
        if not right: return left # 4.
        return root # 2. if left and right:
```    

### [1650\. Lowest Common Ancestor of a Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Tree](https://leetcode.com/tag/tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given two nodes of a binary tree `p` and `q`, return _their lowest common ancestor (LCA)_.

Each node will have a reference to its parent node. The definition for `Node` is below:

```
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
}
```

According to the : "The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow **a node to be a descendant of itself**)."

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [1,2], p = 1, q = 2
Output: 1
```

**Constraints:**

*   The number of nodes in the tree is in the range `[2, 10<sup>5</sup>]`.
*   `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`
*   All `Node.val` are **unique**.
*   `p != q`
*   `p` and `q` exist in the tree.


#### Solution

Language: **Python**

The idea is fairly simple (and the same as finding the convergence point of 2 linked lists). We keep two pointers, `p1` and `p2`. Originally, these pointers point to `q` and `p`, respectively. Then we follow their parent pointers until they point to the same node. When either of the pointers points to `root`, we set it to the other original starting node. For example, when `p1` points to root (i.e `p1.parent is None`), assign `q` to `p1`.

* [](https://www.youtube.com/watch?v=31KtJn5IS9Q&ab_channel=%E5%AE%B0%E7%9B%B8%E5%B0%8F%E7%94%98%E7%BD%97)
```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None
"""

class Solution:
    def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':
        p1, p2 = p, q
        while p1 != p2:
            p1 = p1.parent if p1.parent else q
            p2 = p2.parent if p2.parent else p

        return p1
```


### [98\. Validate Binary Search Tree :rainbow:](https://leetcode.com/problems/validate-binary-search-tree/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.

A **valid BST** is defined as follows:

*   The left subtree of a node contains only nodes with keys **less than** the node's key.
*   The right subtree of a node contains only nodes with keys **greater than** the node's key.
*   Both the left and right subtrees must also be binary search trees.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
Input: root = [2,1,3]
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 10<sup>4</sup>]`.
*   `-2<sup>31</sup> <= Node.val <= 2<sup>31</sup> - 1`


#### Solution

Language: **Python**

```python
def isValidBST(self, root):
    return check_bst(root, float("-inf"), float("inf"))

def check_bst(self, node, left, right):
    if not node:
        return True

    if not left < node.val < right:
        return False

    return check_bst(node.left, left, node.val)
            and check_bst(node.right, node.val, right)

if __name__ == "__main__":
    root = Node(2,
                left = Node(1),
                right = Node(3)
                )

isValidBST(root)
class Solution:
    # @param root, a tree node
    # @return a boolean
    # 7:38
    def isValidBST(self, root):
        output = []
        self.inOrder(root, output)

        for i in range(1, len(output)):
            if output[i-1] >= output[i]:
                return False

        return True

    def inOrder(self, root, output):
        if root is None:
            return

        self.inOrder(root.left, output)
        output.append(root.val)
        self.inOrder(root.right, output)
```

### [958\. Check Completeness of a Binary Tree](https://leetcode.com/problems/check-completeness-of-a-binary-tree/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, determine if it is a _complete binary tree_.

In a , every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between `1` and `2<sup>h</sup>` nodes inclusive at the last level `h`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png)

```
Input: root = [1,2,3,4,5,6]
Output: true
Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png)

```
Input: root = [1,2,3,4,5,null,7]
Output: false
Explanation: The node with value 7 isn't as far left as possible.
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 100]`.
*   `1 <= Node.val <= 1000`


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isCompleteTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        dq = collections.deque()
        dq.append(root)   

        while dq:
            node = dq.popleft()
            if not node:
                return all(item is None for item in dq)
            dq.append(node.left)
            dq.append(node.right)
```

### [270\. Closest Binary Search Tree Value](https://leetcode.com/problems/closest-binary-search-tree-value/)

Difficulty: **Easy**  

Related Topics: [Binary Search](https://leetcode.com/tag/binary-search/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary search tree and a `target` value, return _the value in the BST that is closest to the_ `target`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg)

```
Input: root = [4,2,5,1,3], target = 3.714286
Output: 4
```

**Example 2:**

```
Input: root = [1], target = 4.428571
Output: 1
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 10<sup>4</sup>]`.
*   `0 <= Node.val <= 10<sup>9</sup>`
*   `-10<sup>9</sup> <= target <= 10<sup>9</sup>`


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestValue(self, root: TreeNode, target: float) -> int:
        closest = root.val
        while root:
            closest = min(root.val, closest, key = lambda x: abs(target - x))
            root = root.left if target < root.val else root.right
        return closest
```

### [1026\. Maximum Difference Between Node and Ancestor](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, find the maximum value `v` for which there exist **different** nodes `a` and `b` where `v = |a.val - b.val|` and `a` is an ancestor of `b`.

A node `a` is an ancestor of `b` if either: any child of `a` is equal to `b` or any child of `a` is an ancestor of `b`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg)

```
Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]
Output: 7
Explanation: We have various ancestor-node differences, some of which are given below :
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/09/tmp-tree-1.jpg)

```
Input: root = [1,null,2,null,0,3]
Output: 3
```

**Constraints:**

*   The number of nodes in the tree is in the range `[2, 5000]`.
*   `0 <= Node.val <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
def maxAncestorDiff(root):
    def dfs(root, mn, mx):
        if not root:
            return mx-mn
        mn = min(mn, root.val)
        mx = max(mx, root.val)
        left = dfs(root.left, mn, mx)
        right = dfs(root.right, mn, mx)
        return max(left, right)
    return dfs(root, root.val, root.val)
```

### [449\. Serialize and Deserialize BST](https://leetcode.com/problems/serialize-and-deserialize-bst/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Design](https://leetcode.com/tag/design/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a **binary search tree**. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.

**The encoded string should be as compact as possible.**

**Example 1:**

```
Input: root = [2,1,3]
Output: [2,1,3]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 10<sup>4</sup>]`.
*   `0 <= Node.val <= 10<sup>4</sup>`
*   The input tree is **guaranteed** to be a binary search tree.


#### Solution

Language: **Python**

BST BSTBST

BSTBST

BSTBST

list
```python
class Codec:
    def serialize(self, root):
        vals = []

        def preOrder(node):
            if node:
                vals.append(node.val)
                preOrder(node.left)
                preOrder(node.right)

        preOrder(root)

        return ' '.join(map(str, vals))

    # O( N ) since each val run build once
    def deserialize(self, data):
        vals = collections.deque(int(val) for val in data.split())

        def build(minVal, maxVal):
            if vals and minVal < vals[0] < maxVal:
                val = vals.popleft()
                node = TreeNode(val)
                node.left = build(minVal, val)
                node.right = build(val, maxVal)
                return node

        return build(float('-infinity'), float('infinity'))
```

### [105\. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Tree](https://leetcode.com/tag/tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return _the binary tree_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**Example 2:**

```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

**Constraints:**

*   `1 <= preorder.length <= 3000`
*   `inorder.length == preorder.length`
*   `-3000 <= preorder[i], inorder[i] <= 3000`
*   `preorder` and `inorder` consist of **unique** values.
*   Each value of `inorder` also appears in `preorder`.
*   `preorder` is **guaranteed** to be the preorder traversal of the tree.
*   `inorder` is **guaranteed** to be the inorder traversal of the tree.


#### Solution

Language: **Python**










`buildTree(preorder, inorder`)`root``buildTree(preorder, inorder)``root`

 `root` `buildTree(preorder, inorder)`

* [](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34579/Python-short-recursive-solution.)
```python
def buildTree(self, preorder, inorder):
    if inorder:
        ind = inorder.index(preorder.pop(0))
        root = TreeNode(inorder[ind])
        root.left = self.buildTree(preorder, inorder[0:ind])
        root.right = self.buildTree(preorder, inorder[ind+1:])
        return root
```

### [100\. Same Tree](https://leetcode.com/problems/same-tree/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)

```
Input: p = [1,2], q = [1,null,2]
Output: false
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)

```
Input: p = [1,2,1], q = [1,1,2]
Output: false
```

**Constraints:**

*   The number of nodes in both trees is in the range `[0, 100]`.
*   `-10<sup>4</sup> <= Node.val <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
def isSameTree(p, q):
    if not p and not q:
        return True
    if (not p and q) or (p and not q):
        return False
    return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

### [671\. Second Minimum Node In a Binary Tree :rainbow:](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly `two` or `zero` sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property `root.val = min(root.left.val, root.right.val)` always holds.

Given such a binary tree, you need to output the **second minimum** value in the set made of all the nodes' value in the whole tree.

If no such second minimum value exists, output -1 instead.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg)

```
Input: root = [2,2,5,null,null,5,7]
Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg)

```
Input: root = [2,2,2]
Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 25]`.
*   `1 <= Node.val <= 2<sup>31</sup> - 1`
*   `root.val == min(root.left.val, root.right.val)` for each internal node of the tree.


#### Solution

Language: **Python**

root
```python
class Solution(object):
    def findSecondMinimumValue(self, root):
        def dfs(node):
            if node:
                uniques.add(node.val)
                dfs(node.left)
                dfs(node.right)

        uniques = set()
        dfs(root)

        min1, ans = root.val, float('inf')
        for v in uniques:
            if min1 < v < ans:
                ans = v

        return ans if ans < float('inf') else -1

class Solution(object):
    def findSecondMinimumValue(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root: return -1
        self.res = float("inf")
        self.min = root.val
        self.inOrder(root)
        return self.res if self.res != float("inf") else -1

    def inOrder(self, root):
        if not root:
            return
        self.inOrder(root.left)
        if self.min < root.val < self.res:
            self.res = root.val
        self.inOrder(root.right)
```

### [366\. Find Leaves of Binary Tree :rainbow:](https://leetcode.com/problems/find-leaves-of-binary-tree/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, collect a tree's nodes as if you were doing this:

*   Collect all the leaf nodes.
*   Remove all the leaf nodes.
*   Repeat until the tree is empty.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/16/remleaves-tree.jpg)

```
Input: root = [1,2,3,4,5]
Output: [[4,5,3],[2],[1]]
Explanation:
[[3,5,4],[2],[1]] and [[3,4,5],[2],[1]] are also considered correct answers since per each level it does not matter the order on which elements are returned.
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 100]`.
*   `-100 <= Node.val <= 100`


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def findLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        def height(root):
            if not root:
                return 0
            level = max(height(root.left), height(root.right)) + 1
            d[level].append(root.val)
            return level
        d = collections.defaultdict(list)
        height(root)
        result = []
        for _, ls in d.iteritems():
            result.append(ls)
        return result
```

### [156\. Binary Tree Upside Down](https://leetcode.com/problems/binary-tree-upside-down/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, turn the tree upside down and return _the new root_.

You can turn a binary tree upside down with the following steps:

1.  The original left child becomes the new root.
2.  The original root becomes the new right child.
3.  The original right child becomes the new left child.

![](https://assets.leetcode.com/uploads/2020/08/29/main.jpg)

The mentioned steps are done level by level. It is **guaranteed** that every right node has a sibling (a left node with the same parent) and has no children.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/08/29/updown.jpg)

```
Input: root = [1,2,3,4,5]
Output: [4,5,2,null,null,3,1]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Example 3:**

```
Input: root = [1]
Output: [1]
```

**Constraints:**

*   The number of nodes in the tree will be in the range `[0, 10]`.
*   `1 <= Node.val <= 10`
*   Every right node in the tree has a sibling (a left node that shares the same parent).
*   Every right node in the tree has no children.


#### Solution

Language: **Python**

<p align="center">
  <img src="https://assets.leetcode.com/uploads/2020/08/29/updown.jpg" width="60%" height="60%"/>
</p>

: , , . , ,. , , .

[Solution](https://www.youtube.com/watch?v=6HYaPnjhzjg&ab_channel=M.C%E7%B1%B3%E5%BC%80%E6%9C%97%E5%9F%BA%E7%BD%97)
Complexity: O(N) time and O(1) space, where N is the number of nodes in the input tree.
```python
class Solution(object):
    def upsideDownBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root or (not root.left and not root.right):
            return root
        newroot = self.upsideDownBinaryTree(root.left)
        root.left.left = root.right
        root.left.right = root
        root.left = None
        root.right = None
        return newroot
```

### [298\. Binary Tree Longest Consecutive Sequence](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, return _the length of the longest consecutive sequence path_.

The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path needs to be from parent to child (cannot be the reverse).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg)

```
Input: root = [1,null,3,2,4,null,null,null,5]
Output: 3
Explanation: Longest consecutive sequence path is 3-4-5, so return 3.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg)

```
Input: root = [2,null,3,2,null,1]
Output: 2
Explanation: Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 3 * 10<sup>4</sup>]`.
*   `-3 * 10<sup>4</sup> <= Node.val <= 3 * 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
# dfs
class Solution(object):
    def longestConsecutive(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def preorder(root, size, prev):
            if not root:
                return
            if root.val == prev + 1:
                size += 1
            else:
                size = 1
            if size > self.global_max:
                self.global_max = size
            preorder(root.left, size, root.val)
            preorder(root.right, size, root.val)        
        if not root:
            return 0
        self.global_max = 0
        preorder(root, 0, root.val)            
        return self.global_max

## bfs
def longestConsecutive(root):
    if not root:
        return 0

    ret = 0
    stack = [(root, 1)]
    while stack:
        node, cnt = stack.pop()
        if node.left:
            stack.append((node.left, cnt+1 if node.left.val == node.val + 1 else 1))
        if node.right:
            stack.append((node.right, cnt+1 if node.right.val == node.val + 1 else 1))
        ret = max(ret, cnt)

    return ret
```

### [101\. Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```
Input: root = [1,2,2,3,4,4,3]
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

```
Input: root = [1,2,2,null,3,null,3]
Output: false
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 1000]`.
*   `-100 <= Node.val <= 100`

**Follow up:** Could you solve it both recursively and iteratively?

#### Solution

Language: **Python**

```python
from BinaryTree import Node

def isSymmetric(root):
    if not root:
        return True

    return dfs(root.left, root.right)

def dfs(left, right):
    if not left and not right:
        return True
    if not left or not right:
        return False
    if left.val != right.val:
        return False

    return dfs(left.left, right.right) and dfs(left.right, right.left)

if __name__ == "__main__":
    root = Node(1,
               left = Node(2,
                           left = Node(3),
                           right = None),
               right = Node(2,
                           left = None,
                           right = Node(3))
               )
    root.pretty_print()
    isSymmetric(root)
```

### [951\. Flip Equivalent Binary Trees](https://leetcode.com/problems/flip-equivalent-binary-trees/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


For a binary tree **T**, we can define a **flip operation** as follows: choose any node, and swap the left and right child subtrees.

A binary tree **X** is _flip equivalent_ to a binary tree **Y** if and only if we can make **X** equal to **Y** after some number of flip operations.

Given the roots of two binary trees `root1` and `root2`, return `true` if the two trees are flip equivalent or `false` otherwise.

**Example 1:**

![Flipped Trees Diagram](https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png)

```
Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
Output: true
Explanation: We flipped at nodes with values 1, 3, and 5.
```

**Example 2:**

```
Input: root1 = [], root2 = []
Output: true
```

**Example 3:**

```
Input: root1 = [], root2 = [1]
Output: false
```

**Example 4:**

```
Input: root1 = [0,null,1], root2 = []
Output: false
```

**Example 5:**

```
Input: root1 = [0,null,1], root2 = [0,1]
Output: true
```

**Constraints:**

*   The number of nodes in each tree is in the range `[0, 100]`.
*   Each tree will have **unique node values** in the range `[0, 99]`.


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def flipEquiv(self, root1, root2):
        """
        :type root1: TreeNode
        :type root2: TreeNode
        :rtype: bool
        """

        if not root1 and not root2:
            return True
        if not root1 or not root2:
            return False
        if root1.val != root2.val:
            return False
        return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)) or (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left))
```

### [110\. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

> a binary tree in which the left and right subtrees of _every_ node differ in height by no more than 1.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

```
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
```

**Example 3:**

```
Input: root = []
Output: true
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 5000]`.
*   `-10<sup>4</sup> <= Node.val <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
def height(node):
    if not node:
        return 0
    return 1 + max(height(node.left), height(node.right))

def isBalanced(root):
    if not root:
        return True
    return abs(height(root.left) - height(root.right)) <= 1 and isBalanced(root.left) and isBalanced(root.right)

if __name__ == "__main__":
    root = Node(val = 1,
                left = Node(2),
                right = None)
    root.pretty_print()
    isBalanced(root)
```

### [783\. Minimum Distance Between BST Nodes](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a Binary Search Tree (BST), return _the minimum difference between the values of any two different nodes in the tree_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)

```
Input: root = [4,2,6,1,3]
Output: 1
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)

```
Input: root = [1,0,48,null,null,12,49]
Output: 1
```

**Constraints:**

*   The number of nodes in the tree is in the range `[2, 100]`.
*   `0 <= Node.val <= 10<sup>5</sup>`

**Note:** This question is the same as 530:


#### Solution

Language: **Python**


```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def minDiffInBST(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        vals = []
        def inOrder(root):
            if not root:
                return
            inOrder(root.left)
            vals.append(root.val)
            inOrder(root.right)
        inOrder(root)
        return min([vals[i + 1] - vals[i] for i in xrange(len(vals) - 1)])



# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def minDiffInBST(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = float("inf")
        self.prev = None
        self.inOrder(root)
        return self.res

    def inOrder(self, root):
        if not root: return
        self.inOrder(root.left)
        if self.prev:
            self.res = min(self.res, root.val - self.prev.val)
        self.prev = root
        self.inOrder(root.right)
```

### [450\. Delete Node in a BST :fire:](https://leetcode.com/problems/delete-node-in-a-bst/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:

1.  Search for a node to remove.
2.  If the node is found, delete the node.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

```
Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3\. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.

```

**Example 2:**

```
Input: root = [5,3,6,2,4,null,7], key = 0
Output: [5,3,6,2,4,null,7]
Explanation: The tree does not contain a node with value = 0.
```

**Example 3:**

```
Input: root = [], key = 0
Output: []
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 10<sup>4</sup>]`.
*   `-10<sup>5</sup> <= Node.val <= 10<sup>5</sup>`
*   Each node has a **unique** value.
*   `root` is a valid binary search tree.
*   `-10<sup>5</sup> <= key <= 10<sup>5</sup>`

**Follow up:** Could you solve it with time complexity `O(height of tree)`?


#### Solution

Language: **Python**

```python
def deleteNode(root, key):
    if not root: # if root doesn't exist, just return it
        return root
    if root.val > key: # if key value is less than root value, find the node in the left subtree
        root.left = deleteNode(root.left, key)
    elif root.val < key: # if key value is greater than root value, find the node in right subtree
        root.right  = deleteNode(root.right, key)
    else: #if we found the node (root.value == key), start to delete it
        if not root.right: # if it doesn't have right children, we delete the node then new root would be root.left
            return root.left
        if not root.left: # if it has no left children, we delete the node then new root would be root.right
            return root.right
            # if the node have both left and right children,  we replace its value with the minmimum value in the right subtree and then delete that minimum node in the right subtree
        temp = root.right
        mini = temp.val
        while temp.left:
            temp = temp.left
            mini = temp.val
        root.val = mini # replace value
        root.right = deleteNode(root.right, root.val) # delete the minimum node in right subtree
    return root
```

### [701\. Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


You are given the `root` node of a binary search tree (BST) and a `value` to insert into the tree. Return _the root node of the BST after the insertion_. It is **guaranteed** that the new value does not exist in the original BST.

**Notice** that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return **any of them**.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)

```
Input: root = [4,2,7,1,3], val = 5
Output: [4,2,7,1,3,5]
Explanation: Another accepted tree is:

```

**Example 2:**

```
Input: root = [40,20,60,10,30,50,70], val = 25
Output: [40,20,60,10,30,50,70,null,null,25]
```

**Example 3:**

```
Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
Output: [4,2,7,1,3,5]
```

**Constraints:**

*   The number of nodes in the tree will be in the range `[0, 10<sup>4</sup>]`.
*   `-10<sup>8</sup> <= Node.val <= 10<sup>8</sup>`
*   All the values `Node.val` are **unique**.
*   `-10<sup>8</sup> <= val <= 10<sup>8</sup>`
*   It's **guaranteed** that `val` does not exist in the original BST.


#### Solution

Language: **Python**

```python
class Solution(object):
    def insertIntoBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        if not root:
            return TreeNode(val)
        if val > root.val:
            root.right = self.insertIntoBST(root.right, val)
        if val < root.val:
            root.left = self.insertIntoBST(root.left, val)
        return root
```

### [653\. Two Sum IV - Input is a BST](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/)

Difficulty: **Easy**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Two Pointers](https://leetcode.com/tag/two-pointers/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a Binary Search Tree and a target number `k`, return _`true` if there exist two elements in the BST such that their sum is equal to the given target_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg)

```
Input: root = [5,3,6,2,4,null,7], k = 9
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg)

```
Input: root = [5,3,6,2,4,null,7], k = 28
Output: false
```

**Example 3:**

```
Input: root = [2,1,3], k = 4
Output: true
```

**Example 4:**

```
Input: root = [2,1,3], k = 1
Output: false
```

**Example 5:**

```
Input: root = [2,1,3], k = 3
Output: true
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 10<sup>4</sup>]`.
*   `-10<sup>4</sup> <= Node.val <= 10<sup>4</sup>`
*   `root` is guaranteed to be a **valid** binary search tree.
*   `-10<sup>5</sup> <= k <= 10<sup>5</sup>`


#### Solution

Language: **Python**

* [](https://www.youtube.com/watch?v=M_PzYd59_kk&ab_channel=HuaHua)
```python
def findTarget(self, root: 'TreeNode', k: 'int') -> 'bool':
    s = set()
    def helper(root, k):
        if not root: return False
        if k - root.val in s: return True
        s.add(root.val)
        return(helper(root.left, k) or helper(root.right, k))
    return helper(root, k)
```

### [337\. House Robber III :rainbow:](https://leetcode.com/problems/house-robber-iii/)

Difficulty: **Medium**  

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


The thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.

Besides the `root`, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if **two directly-linked houses were broken into on the same night**.

Given the `root` of the binary tree, return _the maximum amount of money the thief can rob **without alerting the police**_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

```
Input: root = [3,2,3,null,3,null,1]
Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)

```
Input: root = [3,4,5,1,3,null,1]
Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 10<sup>4</sup>]`.
*   `0 <= Node.val <= 10<sup>4</sup>`


#### Solution

Language: **Python**

+vs+

dfsreturnrobcurrrootrobcurr

```python
class Solution(object):
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(root):
            # from bottom to top
            if not root: return [0, 0] # before layer, no robcurr, robcurr
            robleft = dfs(root.left)
            robright = dfs(root.right)
            norobcurr = robleft[1] + robright[1]
            robcurr = max(root.val + robleft[0] + robright[0], norobcurr)
            return [norobcurr, robcurr]
        return dfs(root)[1]
```

### [94\. Binary Tree Inorder Traversal :fire:](https://leetcode.com/problems/binary-tree-inorder-traversal/)

Difficulty: **Easy**  

Related Topics: [Stack](https://leetcode.com/tag/stack/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, return _the inorder traversal of its nodes' values_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
Input: root = [1,null,2,3]
Output: [1,3,2]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Example 3:**

```
Input: root = [1]
Output: [1]
```

**Example 4:**

![](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

```
Input: root = [1,2]
Output: [2,1]
```

**Example 5:**

![](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

```
Input: root = [1,null,2]
Output: [1,2]
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 100]`.
*   `-100 <= Node.val <= 100`

**Follow up:** Recursive solution is trivial, could you do it iteratively?

#### Solution

Language: **Python**

```python
# sol1: recursive
def inorderTraversal(root):
        if root == None:
            return []
        return inorderTraversal(root.left) + [root.val] +  inorderTraversal(root.right)

def inorderTraversal(root):
    result = []
    stack = []
    while root or stack:
        if root:
            stack.append(root)
            root = root.left
        else:
            root = stack.pop()
            result.append(root.val)
            root = root.right
    return result

if __name__ == "__main__":
    root = Node(1,
                left = None,
                right = Node(2, left = Node(3),
                               right = None)
                )
    root.pretty_print()
    inorderTraversal(root)
```

### [95\. Unique Binary Search Trees II :fire:](https://leetcode.com/problems/unique-binary-search-trees-ii/)

Difficulty: **Medium**  

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Backtracking](https://leetcode.com/tag/backtracking/), [Tree](https://leetcode.com/tag/tree/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given an integer `n`, return _all the structurally unique **BST'**s (binary search trees), which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`. Return the answer in **any order**.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
Input: n = 3
Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

**Example 2:**

```
Input: n = 1
Output: [[1]]
```

**Constraints:**

*   `1 <= n <= 8`


#### Solution

Language: **Python**

```python
class Solution:
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """
        def generate_trees(start, end):
            if start > end:
                return [None,]

            all_trees = []
            for i in range(start, end + 1):  # pick up a root
                # all possible left subtrees if i is choosen to be a root
                left_trees = generate_trees(start, i - 1)

                # all possible right subtrees if i is choosen to be a root
                right_trees = generate_trees(i + 1, end)

                # connect left and right subtrees to the root i
                for l in left_trees:
                    for r in right_trees:
                        current_tree = TreeNode(i)
                        current_tree.left = l
                        current_tree.right = r
                        all_trees.append(current_tree)

            return all_trees

        return generate_trees(1, n) if n else []

if __name__ == '__main__':
    trees = generateTrees(3)
    for i in range(len(trees)):
        trees[i].pretty_print()
        print "\n"
```

### [144\. Binary Tree Preorder Traversal :fire:](https://leetcode.com/problems/binary-tree-preorder-traversal/)

Difficulty: **Easy**  

Related Topics: [Stack](https://leetcode.com/tag/stack/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, return _the preorder traversal of its nodes' values_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
Input: root = [1,null,2,3]
Output: [1,2,3]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Example 3:**

```
Input: root = [1]
Output: [1]
```

**Example 4:**

![](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

```
Input: root = [1,2]
Output: [1,2]
```

**Example 5:**

![](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

```
Input: root = [1,null,2]
Output: [1,2]
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 100]`.
*   `-100 <= Node.val <= 100`

**Follow up:** Recursive solution is trivial, could you do it iteratively?


#### Solution

Language: **Python**
```python
# sol1: recursive
def preorderTraversal(root):
        if root == None:
            return []
        return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)

if __name__ == "__main__":
    root = Node(1,
                left = None,
                right = Node(2, left = Node(3),
                               right = None)
                )
    root.pretty_print()
    preorderTraversal(root)

# sol2: non-recursive
def preorderTraversal(root):
    if root is None:
        return []

    result = []
    s = [root]
    while s:
        root = s.pop()
        result.append(root.val)
        if root.right is not None:
            s.append(root.right)
        if root.left is not None:
            s.append(root.left)

    return result

if __name__ == "__main__":
    root = Node(1,
                left = None,
                right = Node(2, left = Node(3),
                               right = None))
    root.pretty_print()
    preorderTraversal(root)
```

### [145\. Binary Tree Postorder Traversal :fire:](https://leetcode.com/problems/binary-tree-postorder-traversal/)

Difficulty: **Easy**  

Related Topics: [Stack](https://leetcode.com/tag/stack/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, return _the postorder traversal of its nodes' values_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)

```
Input: root = [1,null,2,3]
Output: [3,2,1]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Example 3:**

```
Input: root = [1]
Output: [1]
```

**Example 4:**

![](https://assets.leetcode.com/uploads/2020/08/28/pre3.jpg)

```
Input: root = [1,2]
Output: [2,1]
```

**Example 5:**

![](https://assets.leetcode.com/uploads/2020/08/28/pre2.jpg)

```
Input: root = [1,null,2]
Output: [2,1]
```

**Constraints:**

*   The number of the nodes in the tree is in the range `[0, 100]`.
*   `-100 <= Node.val <= 100`

**Follow up:** Recursive solution is trivial, could you do it iteratively?

#### Solution

Language: **Python**




* `->->`
* `->->`



`->()->`

```python
# sol1: recursive
def postorderTraversal(root):
        if root == None:
            return []
        return postorderTraversal(root.left) + postorderTraversal(root.right) + [root.val]


if __name__ == "__main__":
    root = Node(1,
                left = None,
                right = Node(2, left = Node(3),
                               right = None)
                )
    root.pretty_print()
    postorderTraversal(root)

# The first is by postorder using a flag to indicate whether the node has been visited or not.
class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def postorderTraversal(self, root):
        traversal, stack = [], [(root, False)]
        while stack:
            node, visited = stack.pop()
            if node:
                if visited:
                    # add to result if visited
                    traversal.append(node.val)
                else:
                    # post-order
                    stack.append((node, True))
                    stack.append((node.right, False))
                    stack.append((node.left, False))

        return traversal

# The 2nd uses modified preorder (right subtree first). Then reverse the result.
class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def postorderTraversal(self, root):
        traversal, stack = [], [root]
        while stack:
            node = stack.pop()
            if node:
                # similar to pre-order but right first
                traversal.append(node.val)
                stack.append(node.left)
                stack.append(node.right)

        # reverse result
        return traversal[::-1]
```

### [1382\. Balance a Binary Search Tree :rainbow:](https://leetcode.com/problems/balance-a-binary-search-tree/)

Difficulty: **Medium**  

Related Topics: [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Greedy](https://leetcode.com/tag/greedy/), [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary search tree, return _a **balanced** binary search tree with the same node values_. If there is more than one answer, return **any of them**.

A binary search tree is **balanced** if the depth of the two subtrees of every node never differs by more than `1`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg)

```
Input: root = [1,null,2,null,3,null,4,null,null]
Output: [2,1,3,null,null,null,4]
Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg)

```
Input: root = [2,1,3]
Output: [2,1,3]
```

**Constraints:**

*   The number of nodes in the tree is in the range `[1, 10<sup>4</sup>]`.
*   `1 <= Node.val <= 10<sup>5</sup>`


#### Solution

Language: **Python**

* [](https://leetcode-cn.com/problems/balance-a-binary-search-tree/solution/ti-jie-leetcode-1382-jiang-er-cha-sou-suo-shu-bian/)

:
 

  







1.   ans 
2.  ans 
3. 2

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def balanceBST(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        def dfs(node):
            if not node:
                return
            dfs(node.left)
            v.append(node.val)
            dfs(node.right)

        def bst(v):
            if not v:
                return
            mid = len(v) / 2
            root = TreeNode(v[mid])
            root.left = bst(v[:mid])
            root.right = bst(v[mid + 1: ])
            return root

        v = []
        dfs(root)
        return bst(v)
```


### [104\. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary tree, return _its maximum depth_.

A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: 3
```

**Example 2:**

```
Input: root = [1,null,2]
Output: 2
```

**Example 3:**

```
Input: root = []
Output: 0
```

**Example 4:**

```
Input: root = [0]
Output: 1
```

**Constraints:**

*   The number of nodes in the tree is in the range `[0, 10<sup>4</sup>]`.
*   `-100 <= Node.val <= 100`


#### Solution

Language: **Python**

```python
def maxDepth(root):
    if not root:
        return 0
    return max(maxDepth(root.left), maxDepth(root.right)) + 1

if __name__ == "__main__":
    root = Node(1,
                left = None,
                right = Node(2, left = Node(3),
                               right = None)
                )
    root.pretty_print()
    maxDepth(root)
```

### [572\. Subtree of Another Tree :rainbow:](https://leetcode.com/problems/subtree-of-another-tree/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [String Matching](https://leetcode.com/tag/string-matching/), [Binary Tree](https://leetcode.com/tag/binary-tree/), [Hash Function](https://leetcode.com/tag/hash-function/)


Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.

A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg)

```
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg)

```
Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false
```

**Constraints:**

*   The number of nodes in the `root` tree is in the range `[1, 2000]`.
*   The number of nodes in the `subRoot` tree is in the range `[1, 1000]`.
*   `-10<sup>4</sup> <= root.val <= 10<sup>4</sup>`
*   `-10<sup>4</sup> <= subRoot.val <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSubtree(self, s, t):
        """
        :type root: TreeNode
        :type subRoot: TreeNode
        :rtype: bool
        """
        if self.sameTree(s, t):
            return True
        if not s:
            return False
        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)


    def sameTree(self, p, q):
        if not p and not q:
            return True
        if (not p and q) or (p and not q):
            return False
        return p.val == q.val and self.sameTree(p.left, q.left) and self.sameTree(p.right, q.right)
```

### [617\. Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/)

Difficulty: **Easy**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


You are given two binary trees `root1` and `root2`.

Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.

Return _the merged tree_.

**Note:** The merging process must start from the root nodes of both trees.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```
Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]
```

**Example 2:**

```
Input: root1 = [1], root2 = [1,2]
Output: [2,2]
```

**Constraints:**

*   The number of nodes in both trees is in the range `[0, 2000]`.
*   `-10<sup>4</sup> <= Node.val <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def mergeTrees(self, root1, root2):
        """
        :type root1: TreeNode
        :type root2: TreeNode
        :rtype: TreeNode
        """
        if not root1 and not root2:
            return
        elif not root1 and root2:
            root = TreeNode(root2.val)
            root.left = root2.left
            root.right = root2.right
        elif root1 and not root2:
            root = TreeNode(root1.val)
            root.left = root1.left
            root.right = root1.right
        else:
            root = TreeNode(val = root1.val + root2.val)
            root.left = self.mergeTrees(root1.left, root2.left)        
            root.right = self.mergeTrees(root1.right, root2.right)    
        return root
```

### [108\. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Tree](https://leetcode.com/tag/tree/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given an integer array `nums` where the elements are sorted in **ascending order**, convert _it to a **height-balanced** binary search tree_.

A **height-balanced** binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:

```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
Input: nums = [1,3]
Output: [3,1]
Explanation: [1,3] and [3,1] are both a height-balanced BSTs.
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>4</sup>`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
*   `nums` is sorted in a **strictly increasing** order.


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        def helper(l, r):
            if l > r:
                return
            m = (l + r) // 2
            root = TreeNode(nums[m])
            root.left = helper(l, m - 1)
            root.right = helper(m + 1, r)
            return root

        return helper(0, len(nums) - 1)
```

### [669\. Trim a Binary Search Tree](https://leetcode.com/problems/trim-a-binary-search-tree/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Binary Search Tree](https://leetcode.com/tag/binary-search-tree/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given the `root` of a binary search tree and the lowest and highest boundaries as `low` and `high`, trim the tree so that all its elements lies in `[low, high]`. Trimming the tree should **not** change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a **unique answer**.

Return _the root of the trimmed binary search tree_. Note that the root may change depending on the given bounds.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg)

```
Input: root = [1,0,2], low = 1, high = 2
Output: [1,null,2]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg)

```
Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3
Output: [3,2,null,1]
```

**Constraints:**

*   The number of nodes in the tree in the range `[1, 10<sup>4</sup>]`.
*   `0 <= Node.val <= 10<sup>4</sup>`
*   The value of each node in the tree is **unique**.
*   `root` is guaranteed to be a valid binary search tree.
*   `0 <= low <= high <= 10<sup>4</sup>`


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def trimBST(self, root, low, high):
        """
        :type root: TreeNode
        :type low: int
        :type high: int
        :rtype: TreeNode
        """

        def dfs(node):
            if not node:
                return

            if node.val < low:
                return dfs(node.right)
            elif node.val > high:
                return dfs(node.left)
            elif low <= node.val <= high:
                root = TreeNode(node.val)
                root.left = dfs(node.left)
                root.right = dfs(node.right)
                return root
        return dfs(root)
```

### [1448\. Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)

Difficulty: **Medium**  

Related Topics: [Tree](https://leetcode.com/tag/tree/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Binary Tree](https://leetcode.com/tag/binary-tree/)


Given a binary tree `root`, a node _X_ in the tree is named **good** if in the path from root to _X_ there are no nodes with a value _greater than_ X.

Return the number of **good** nodes in the binary tree.

**Example 1:**

**![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)**

```
Input: root = [3,1,4,3,null,1,5]
Output: 4
Explanation: Nodes in blue are good.
Root Node (3) is always a good node.
Node 4 -> (3,4) is the maximum value in the path starting from the root.
Node 5 -> (3,4,5) is the maximum value in the path
Node 3 -> (3,1,3) is the maximum value in the path.
```

**Example 2:**

**![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png)**

```
Input: root = [3,3,null,4,2]
Output: 3
Explanation: Node 2 -> (3, 3, 2) is not good, because "3" is higher than it.
```

**Example 3:**

```
Input: root = [1]
Output: 1
Explanation: Root is considered as good.
```

**Constraints:**

*   The number of nodes in the binary tree is in the range `[1, 10^5]`.
*   Each node's value is between `[-10^4, 10^4]`.


#### Solution

Language: **Python**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def goodNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(node, pre_max):
            if not node:
                return
            if node.val >= pre_max:
                pre_max = node.val
                self.count += 1
            dfs(node.left, pre_max)
            dfs(node.right, pre_max)
        
        self.count = 0
        dfs(root, float('-inf'))
        return self.count


class Solution(object):
    def goodNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(node, pre_max):
            if not node:
                return 0
            res = 1 if node.val >= pre_max else 0
            pre_max = max(node.val, pre_max)
            res += dfs(node.left, pre_max)
            res += dfs(node.right, pre_max)
            return res
        return dfs(root, root.val)
```

## Trie
### [211\. Design Add and Search Words Data Structure :rainbow:](https://leetcode.com/problems/design-add-and-search-words-data-structure/)

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Design](https://leetcode.com/tag/design/), [Trie](https://leetcode.com/tag/trie/)


Design a data structure that supports adding new words and finding if a string matches any previously added string.

Implement the `WordDictionary` class:

*   `WordDictionary()` Initializes the object.
*   `void addWord(word)` Adds `word` to the data structure, it can be matched later.
*   `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `'.'` where dots can be matched with any letter.

**Example:**

```
Input
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
Output
[null,null,null,null,false,true,true,true]

Explanation
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True
```

**Constraints:**

*   `1 <= word.length <= 500`
*   `word` in `addWord` consists lower-case English letters.
*   `word` in `search` consist of  `'.'` or lower-case English letters.
*   At most `50000` calls will be made to `addWord` and `search`.


#### Solution

Language: **Python**

```python
# sol-1
from collections import defaultdict

class TrieNode():
    def __init__(self):
        self.children = collections.defaultdict(TrieNode)
        self.isWord = False

class WordDictionary(object):
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isWord = True

    def search(self, word):
        node = self.root
        self.res = False
        self.dfs(node, word)
        return self.res

    def dfs(self, node, word):
        if not word:
            if node.isWord:
                self.res = True
            return
        if word[0] == ".":
            for n in node.children.values():
                self.dfs(n, word[1:])
        else:
            node = node.children.get(word[0])
            if not node:
                return
            self.dfs(node, word[1:])

wordDictionary = WordDictionary()
wordDictionary.addWord("bad")
wordDictionary.addWord("dad")
wordDictionary.addWord("mad")
wordDictionary.search("pad")
wordDictionary.search("bad")
wordDictionary.search(".ad")
wordDictionary.search("b..")    

# sol-2
class WordDictionary:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.trie = {}


    def addWord(self, word: str) -> None:
        """
        Adds a word into the data structure.
        """
        node = self.trie

        for ch in word:
            if not ch in node:
                node[ch] = {}
            node = node[ch]
        node['$'] = True

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any letter.
        """
        def search_in_node(word, node) -> bool:
            for i, ch in enumerate(word):
                if not ch in node:
                    # if the current character is '.'
                    # check all possible nodes at this level
                    if ch == '.':
                        for x in node:
                            if x != '$' and search_in_node(word[i + 1:], node[x]):
                                return True
                    # if no nodes lead to answer
                    # or the current character != '.'
                    return False
                # if the character is found
                # go down to the next level in trie
                else:
                    node = node[ch]
            return '$' in node

        return search_in_node(word, self.trie)
```

### [208\. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Design](https://leetcode.com/tag/design/), [Trie](https://leetcode.com/tag/trie/)


A (pronounced as "try") or **prefix tree** is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.

Implement the Trie class:

*   `Trie()` Initializes the trie object.
*   `void insert(String word)` Inserts the string `word` into the trie.
*   `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.
*   `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.

**Example 1:**

```
Input
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
Output
[null, null, true, false, true, null, true]

Explanation
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // return True
trie.search("app");     // return False
trie.startsWith("app"); // return True
trie.insert("app");
trie.search("app");     // return True
```

**Constraints:**

*   `1 <= word.length, prefix.length <= 2000`
*   `word` and `prefix` consist only of lowercase English letters.
*   At most `3 * 10<sup>4</sup>` calls **in total** will be made to `insert`, `search`, and `startsWith`.


#### Solution

Language: **Python**

```Python
class TrieNode:
    # Initialize your data structure here.
    def __init__(self):
        self.children = collections.defaultdict(TrieNode)
        self.is_word = False

class Trie:

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        current = self.root
        for letter in word:
            current = current.children[letter]
        current.is_word = True

    def search(self, word):
        current = self.root
        for letter in word:
            current = current.children.get(letter)
            if current is None:
                return False
        return current.is_word

    def startsWith(self, prefix):
        current = self.root
        for letter in prefix:
            current = current.children.get(letter)
            if current is None:
                return False
        return True
```


My implementation
```python
class Trie(object):

    def __init__(self):
        self.dict = {}

    def insert(self, word):
        """
        :type word: str
        :rtype: None
        """
        cur = self.dict
        for c in word:
            if c not in cur:
                cur[c] = {}
            cur = cur[c]
        cur['#'] = True

    def search(self, word):
        """
        :type word: str
        :rtype: bool
        """
        cur = self.dict
        for c in word:
            if c not in cur:
                return False
            cur = cur[c]
        return '#' in cur


    def startsWith(self, prefix):
        """
        :type prefix: str
        :rtype: bool
        """
        cur = self.dict
        for c in prefix:
            if c not in cur:
                return False
            cur = cur[c]
        return True

if __name__ == '__main__':
    obj = Trie()
    obj.insert("apple")
    obj.search("apple")
    obj.search("app")   
    obj.startsWith("app")
    obj.insert("app")   
    obj.search("app")  
```

### [212\. Word Search II :rainbow:](https://leetcode.com/problems/word-search-ii/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/), [Backtracking](https://leetcode.com/tag/backtracking/), [Trie](https://leetcode.com/tag/trie/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `m x n` `board` of characters and a list of strings `words`, return _all words on the board_.

Each word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)

```
Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)

```
Input: board = [["a","b"],["c","d"]], words = ["abcb"]
Output: []
```

**Constraints:**

*   `m == board.length`
*   `n == board[i].length`
*   `1 <= m, n <= 12`
*   `board[i][j]` is a lowercase English letter.
*   `1 <= words.length <= 3 * 10<sup>4</sup>`
*   `1 <= words[i].length <= 10`
*   `words[i]` consists of lowercase English letters.
*   All the strings of `words` are unique.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/word-search-ii/discuss/59790/Python-dfs-solution-(directly-use-Trie-implemented).)
* : m * n * 4 ** L
```python
class TrieNode():
    def __init__(self):
        self.children = collections.defaultdict(TrieNode)
        self.isWord = False

class Trie():
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isWord = True

    def search(self, word):
        node = self.root
        for w in word:
            node = node.children.get(w)
            if not node:
                return False
        return node.isWord

class Solution(object):
    def findWords(self, board, words):
        def dfs(board, node, i, j, path, res):
            if node.isWord:
                res.append(path)
                node.isWord = False
            if i not in range(m) or j not in range(n) or visit[i][j]:
                return
            node = node.children.get(board[i][j])
            if not node:
                return
            visit[i][j] = True
            dfs(board, node, i+1, j, path+board[i][j], res)
            dfs(board, node, i-1, j, path+board[i][j], res)
            dfs(board, node, i, j-1, path+board[i][j], res)
            dfs(board, node, i, j+1, path+board[i][j], res)
            visit[i][j] = False

        m, n = len(board), len(board[0])
        visit = [[False] * n for _ in range(m)]
        res = []
        trie = Trie()
        node = trie.root
        for w in words:
            trie.insert(w)
        for i in xrange(m):
            for j in xrange(n):
                dfs(board, node, i, j, "", res)
        return res
```



### [336\. Palindrome Pairs :fire:](https://leetcode.com/problems/palindrome-pairs/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Trie](https://leetcode.com/tag/trie/)


Given a list of **unique** words, return all the pairs of the **_distinct_** indices `(i, j)` in the given list, so that the concatenation of the two words `words[i] + words[j]` is a palindrome.

**Example 1:**

```
Input: words = ["abcd","dcba","lls","s","sssll"]
Output: [[0,1],[1,0],[3,2],[2,4]]
Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]
```

**Example 2:**

```
Input: words = ["bat","tab","cat"]
Output: [[0,1],[1,0]]
Explanation: The palindromes are ["battab","tabbat"]
```

**Example 3:**

```
Input: words = ["a",""]
Output: [[0,1],[1,0]]
```

**Constraints:**

*   `1 <= words.length <= 5000`
*   `0 <= words[i].length <= 300`
*   `words[i]` consists of lower-case English letters.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/palindrome-pairs/discuss/79209/Accepted-Python-Solution-With-Explanation)
* [trie](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)
```python
def is_palindrome(check):
    return check == check[::-1]

words = {word: i for i, word in enumerate(words)}
valid_pals = []
for word, k in words.iteritems():
    n = len(word)
    for j in range(n+1):
        pref = word[:j]
        suf = word[j:]
        if is_palindrome(pref):
            back = suf[::-1]
            if back != word and back in words:
                valid_pals.append([words[back],  k])
        if j != n and is_palindrome(suf):
            back = pref[::-1]
            if back != word and back in words:
                valid_pals.append([k, words[back]])
return valid_pals

# using trie
class TrieNode:
    def __init__(self):
        self.children = {}
        self.isEnd = False
        self.index = -1

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word, index):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isEnd = True
        node.index = index

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return (False, -1)
            node = node.children[char]
        return (node.isEnd, node.index)

class Solution:
    def palindromePairs(self, words):
        def is_palindrome(check):
            return check == check[::-1]

        trie = Trie()
        for i, word in enumerate(words):
            trie.insert(word, i)
        valid_pals = []
        for i, word in enumerate(words):
            m = len(word)
            for k in range(m+1):
                prefix = word[:k]
                suffix = word[k:]
                if is_palindrome(prefix):
                    search, index = trie.search(suffix[::-1])
                    if search and index != i:
                        valid_pals.append([index,  i])
                if k != m and is_palindrome(suffix):
                    search, index = trie.search(prefix[::-1])
                    if search and index != i:
                        valid_pals.append([i, index])
        return valid_pals
```

### [472\. Concatenated Words :rainbow:](https://leetcode.com/problems/concatenated-words/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Trie](https://leetcode.com/tag/trie/)


Given an array of strings `words` (**without duplicates**), return _all the **concatenated words** in the given list of_ `words`.

A **concatenated word** is defined as a string that is comprised entirely of at least two shorter words in the given array.

**Example 1:**

```
Input: words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]
Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";
"dogcatsdog" can be concatenated by "dog", "cats" and "dog";
"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".
```

**Example 2:**

```
Input: words = ["cat","dog","catdog"]
Output: ["catdog"]
```

**Constraints:**

*   `1 <= words.length <= 10<sup>4</sup>`
*   `0 <= words[i].length <= 1000`
*   `words[i]` consists of only lowercase English letters.
*   `0 <= sum(words[i].length) <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
# using trie
import collections

class TrieNode:
    def __init__(self):
        self.children = collections.defaultdict(TrieNode)
        self.isEnd = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        marker = self.root
        for ch in word:
            marker = marker.children[ch]
        marker.isEnd = True


class Solution:
    def findAllConcatenatedWordsInADict(self, words):

        def dfs(word, start, root, count):
            n = len(word)
            marker = root
            for i in range(start, n):
                marker = marker.children[word[i]]
                if marker.isEnd:           # smaller word encountered
                    if i == n-1:               # leaf node
                        return count>=1
                    elif dfs(word, i+1, root, count+1):     # increment the count and start a new DFS
                        return True
            return False

        res = []
        trie = Trie()
        for word in words:
            trie.insert(word)

        for word in words:
            if dfs(word, 0, trie.root, 0):
                res += word,

        return res

# [140](https://leetcode.com/problems/concatenated-words/discuss/?currentPage=1&orderBy=most_votes&query=)
class Solution(object):
    def findAllConcatenatedWordsInADict(self, words):
        """
        :type words: List[str]
        :rtype: List[str]
        """
        res = []
        preWords = set()

        # asc order of word length, since longer words are formed by shorter words
        words.sort(key = len)

        # for each short word start building preWords
        for word in words:
            if self.wordBreak(word, preWords):
                res.append(word)
            preWords.add(word)

        return res

    # Word Break I template
    def wordBreak(self, string, words):
        if not words:
            return False

        dp = [False] * (len(string) + 1)
        dp[0] = True

        for i in range(len(string)+1):
            for j in range(i):
                if dp[j] and string[j:i] in words:
                    dp[i] = True
                    break

        return dp[-1]
```

### [1268\. Search Suggestions System :rainbow:](https://leetcode.com/problems/search-suggestions-system/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/), [Trie](https://leetcode.com/tag/trie/)


Given an array of strings `products` and a string `searchWord`. We want to design a system that suggests at most three product names from `products` after each character of `searchWord` is typed. Suggested products should have common prefix with the searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.

Return _list of lists_ of the suggested `products` after each character of `searchWord` is typed.

**Example 1:**

```
Input: products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"
Output: [
["mobile","moneypot","monitor"],
["mobile","moneypot","monitor"],
["mouse","mousepad"],
["mouse","mousepad"],
["mouse","mousepad"]
]
Explanation: products sorted lexicographically = ["mobile","moneypot","monitor","mouse","mousepad"]
After typing m and mo all products match and we show user ["mobile","moneypot","monitor"]
After typing mou, mous and mouse the system suggests ["mouse","mousepad"]
```

**Example 2:**

```
Input: products = ["havana"], searchWord = "havana"
Output: [["havana"],["havana"],["havana"],["havana"],["havana"],["havana"]]
```

**Example 3:**

```
Input: products = ["bags","baggage","banner","box","cloths"], searchWord = "bags"
Output: [["baggage","bags","banner"],["baggage","bags","banner"],["baggage","bags"],["bags"]]
```

**Example 4:**

```
Input: products = ["havana"], searchWord = "tatiana"
Output: [[],[],[],[],[],[],[]]
```

**Constraints:**

*   `1 <= products.length <= 1000`
*   There are no repeated elements in `products`.
*   `1 <=  products[i].length <= 2 * 10^4`
*   All characters of `products[i]` are lower-case English letters.
*   `1 <= searchWord.length <= 1000`
*   All characters of `searchWord` are lower-case English letters.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/search-suggestions-system/discuss/508775/Python-Trie-%2B-sort-Trie-%2B-Heap)
* [](https://leetcode.com/problems/search-suggestions-system/discuss/505444/Python-Intuitive-trie-solution-with-detailed-explanation)
```Python
class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        class TrieNode:
            def __init__(self):
                self.children = collections.defaultdict(TrieNode)
                self.suggestion = []

            def add_sugestion(self, product):
                if len(self.suggestion) < 3:
                    self.suggestion.append(product)

        products = sorted(products)
        root = TrieNode()
        for p in products:
            node = root
            for char in p:
                node = node.children[char]
                node.add_sugestion(p)

        result, node = [], root
        for char in searchWord:
            node = node.children[char]
            result.append(node.suggestion)
        return result
```

### [642\. Design Search Autocomplete System :fire:](https://leetcode.com/problems/design-search-autocomplete-system/)

Difficulty: **Hard**  

Related Topics: [String](https://leetcode.com/tag/string/), [Design](https://leetcode.com/tag/design/), [Trie](https://leetcode.com/tag/trie/), [Data Stream](https://leetcode.com/tag/data-stream/)


Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character `'#'`).

You are given a string array `sentences` and an integer array `times` both of length `n` where `sentences[i]` is a previously typed sentence and `times[i]` is the corresponding number of times the sentence was typed. For each input character except `'#'`, return the top `3` historical hot sentences that have the same prefix as the part of the sentence already typed.

Here are the specific rules:

*   The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.
*   The returned top `3` hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first).
*   If less than `3` hot sentences exist, return as many as you can.
*   When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.

Implement the `AutocompleteSystem` class:

*   `AutocompleteSystem(String[] sentences, int[] times)` Initializes the object with the `sentences` and `times` arrays.
*   `List<String> input(char c)` This indicates that the user typed the character `c`.
    *   Returns an empty array `[]` if `c == '#'` and stores the inputted sentence in the system.
    *   Returns the top `3` historical hot sentences that have the same prefix as the part of the sentence already typed. If there are fewer than `3` matches, return them all.

**Example 1:**

```
Input
["AutocompleteSystem", "input", "input", "input", "input"]
[[["i love you", "island", "iroman", "i love leetcode"], [5, 3, 2, 2]], ["i"], [" "], ["a"], ["#"]]
Output
[null, ["i love you", "island", "i love leetcode"], ["i love you", "i love leetcode"], [], []]

Explanation
AutocompleteSystem obj = new AutocompleteSystem(["i love you", "island", "iroman", "i love leetcode"], [5, 3, 2, 2]);
obj.input("i"); // return ["i love you", "island", "i love leetcode"]. There are four sentences that have prefix "i". Among them, "ironman" and "i love leetcode" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, "i love leetcode" should be in front of "ironman". Also we only need to output top 3 hot sentences, so "ironman" will be ignored.
obj.input(" "); // return ["i love you", "i love leetcode"]. There are only two sentences that have prefix "i ".
obj.input("a"); // return []. There are no sentences that have prefix "i a".
obj.input("#"); // return []. The user finished the input, the sentence "i a" should be saved as a historical sentence in system. And the following input will be counted as a new search.
```

**Constraints:**

*   `n == sentences.length`
*   `n == times.length`
*   `1 <= n <= 100`
*   `1 <= sentences[i].length <= 100`
*   `1 <= times[i] <= 50`
*   `c` is a lowercase English letter, a hash `'#'`, or space `' '`.
*   Each tested sentence will be a sequence of characters `c` that end with the character `'#'`.
*   Each tested sentence will have a length in the range `[1, 200]`.
*   The words in each input sentence are separated by single spaces.
*   At most `5000` calls will be made to `input`.


#### Solution

Language: **Python**

* [](https://www.cxyxiaowu.com/1816.html)

```Python
import collections
sentences, times = ["i love you", "island", "iroman", "i love leetcode"], [5, 3, 2, 2]

class TrieNode:
    def __init__(self):
        self.children = dict()
        self.sentences = set()

class AutocompleteSystem(object):

    def __init__(self, sentences, times):
        self.buffer = ''
        self.stimes = collections.defaultdict(int)
        self.trie = TrieNode()
        for s, t in zip(sentences, times):
            self.stimes[s] = t
            self.addSentence(s)
        self.tnode = self.trie

    def input(self, c):
        ans = []
        if c != '#':
            self.buffer += c
            if self.tnode: self.tnode = self.tnode.children.get(c)
            if self.tnode: ans = sorted(self.tnode.sentences, key=lambda x: (-self.stimes[x], x))[:3]
        else:
            self.stimes[self.buffer] += 1
            self.addSentence(self.buffer)
            self.buffer = ''
            self.tnode = self.trie
        return ans

    def addSentence(self, word):
        node = self.trie
        for letter in word:
            child = node.children.get(letter)
            if child is None:
                child = TrieNode()
                node.children[letter] = child
            node = child
            child.sentences.add(word)
```

## Graph
### [323\. Number of Connected Components in an Undirected Graph :rainbow:](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)

Difficulty: **Medium**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Graph](https://leetcode.com/tag/graph/)


You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub>]` indicates that there is an edge between `a<sub style="display: inline;">i</sub>` and `b<sub style="display: inline;">i</sub>` in the graph.

Return _the number of connected components in the graph_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/14/conn1-graph.jpg)

```
Input: n = 5, edges = [[0,1],[1,2],[3,4]]
Output: 2
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/14/conn2-graph.jpg)

```
Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]
Output: 1
```

**Constraints:**

*   `1 <= n <= 2000`
*   `1 <= edges.length <= 5000`
*   `edges[i].length == 2`
*   `0 <= a<sub style="display: inline;">i</sub> <= b<sub style="display: inline;">i</sub> < n`
*   `a<sub style="display: inline;">i</sub> != b<sub style="display: inline;">i</sub>`
*   There are no repeated edges.


#### Solution

Language: **Python**

Here E = Number of edges, V = Number of vertices.

* Time complexity: `O(E+V)`.
* Space complexity: `O(E+V)`.

* [Union Find with Rank?](https://www.youtube.com/watch?v=8f1XPm4WOUc&list=PLot-Xpze53ldVwtstag2TL4HQhAnC8ATf&index=33&ab_channel=NeetCode)
```python
# dfs
def countComponents(n, edges):
    """
    :type n: int
    :type edges: List[List[int]]
    :rtype: int
    """
    graph = collections.defaultdict(list)
    visited = set()
    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])
    ans = 0
    for vertex in range(n):
        if not vertex in visited:
            dfs(graph, vertex, visited)
            ans += 1
    return ans

def dfs(graph, vertex, visited):
    'this helps to record all the neighbors it visits'
    if vertex in visited:
        return
    visited.add(vertex)
    for point in graph[vertex]:
        dfs(graph, point, visited)

n = 5; edges = [[0, 1], [1, 2], [3, 4]]   

# union find
class Solution(object):
    def countComponents(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        parent = list(range(n))
        self.count = n
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(x, y):
            rx, ry = find(x), find(y)
            if rx != ry:
                parent[rx] = ry
                self.count -= 1

        for x, y in edges:
            union(x, y)

        return self.count

n = 5; edges = [[0, 1], [1, 2], [3, 4]]

# union find with rank
class Solution(object):
    def countComponents(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        parent = list(range(n))
        rank = [1] * n
        self.count = n
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(x, y):
            rx, ry = find(x), find(y)
            print x, y, parent, rank
            if rx != ry:
                if rank[ry] > rank[rx]:
                    parent[rx] = ry
                    rank[ry] += rank[rx]
                else:
                    parent[ry] = rx
                    rank[rx] += rank[ry]
                self.count -= 1

        for x, y in edges:
            union(x, y)
        print x, y, parent, rank
        return self.count
```

### [399\. Evaluate Division](https://leetcode.com/problems/evaluate-division/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Graph](https://leetcode.com/tag/graph/), [Shortest Path](https://leetcode.com/tag/shortest-path/)


You are given an array of variable pairs `equations` and an array of real numbers `values`, where `equations[i] = [A<sub style="display: inline;">i</sub>, B<sub style="display: inline;">i</sub>]` and `values[i]` represent the equation `A<sub style="display: inline;">i</sub> / B<sub style="display: inline;">i</sub> = values[i]`. Each `A<sub style="display: inline;">i</sub>` or `B<sub style="display: inline;">i</sub>` is a string that represents a single variable.

You are also given some `queries`, where `queries[j] = [C<sub style="display: inline;">j</sub>, D<sub style="display: inline;">j</sub>]` represents the `j<sup>th</sup>` query where you must find the answer for `C<sub style="display: inline;">j</sub> / D<sub style="display: inline;">j</sub> = ?`.

Return _the answers to all queries_. If a single answer cannot be determined, return `-1.0`.

**Note:** The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.

**Example 1:**

```
Input: equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]
Explanation:
Given: a / b = 2.0, b / c = 3.0
queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
```

**Example 2:**

```
Input: equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
Output: [3.75000,0.40000,5.00000,0.20000]
```

**Example 3:**

```
Input: equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
Output: [0.50000,2.00000,-1.00000,-1.00000]
```

**Constraints:**

*   `1 <= equations.length <= 20`
*   `equations[i].length == 2`
*   `1 <= A<sub style="display: inline;">i</sub>.length, B<sub style="display: inline;">i</sub>.length <= 5`
*   `values.length == equations.length`
*   `0.0 < values[i] <= 20.0`
*   `1 <= queries.length <= 20`
*   `queries[i].length == 2`
*   `1 <= C<sub style="display: inline;">j</sub>.length, D<sub style="display: inline;">j</sub>.length <= 5`
*   `A<sub style="display: inline;">i</sub>, B<sub style="display: inline;">i</sub>, C<sub style="display: inline;">j</sub>, D<sub style="display: inline;">j</sub>` consist of lower case English letters and digits.


#### Solution

Language: **Python**

* Let N be the number of input equations and M be the number of queries. For each query, we need to traverse the graph. In the worst case, we might need to traverse the entire graph, which could take O(N). Hence, in total, the evaluation of queries could take MO(N)=O(MN).
* Space: O(N)

```python
def calcEquation(equations, values, queries):
    def dfs(graph, start, end, visited):
        if start == end and graph[start]:
            return 1.0

        visited.add(start)
        for neigh, val in graph[start]:
            if neigh in visited:
                continue

            tmp = dfs(graph, neigh, end, visited)
            if tmp > 0:
                return val * tmp

        return -1.0

    graph = collections.defaultdict(set)
    for items, v in zip(equations, values):
        x, y = items
        graph[x].add((y, v))
        graph[y].add((x, 1.0 / v))

    res = []
    for q in queries:
        res.append(dfs(graph, q[0], q[1], set()))

    return res


equations = [["a","b"],["b","c"]]; values = [2.0,3.0]; queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
```

### [1514\. Path with Maximum Probability :rainbow:](https://leetcode.com/problems/path-with-maximum-probability/)

Difficulty: **Medium**  

Related Topics: [Graph](https://leetcode.com/tag/graph/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Shortest Path](https://leetcode.com/tag/shortest-path/)


You are given an undirected weighted graph of `n` nodes (0-indexed), represented by an edge list where `edges[i] = [a, b]` is an undirected edge connecting the nodes `a` and `b` with a probability of success of traversing that edge `succProb[i]`.

Given two nodes `start` and `end`, find the path with the maximum probability of success to go from `start` to `end` and return its success probability.

If there is no path from `start` to `end`, **return 0**. Your answer will be accepted if it differs from the correct answer by at most **1e-5**.

**Example 1:**

**![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png)**

```
Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
Output: 0.25000
Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.
```

**Example 2:**

**![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png)**

```
Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
Output: 0.30000
```

**Example 3:**

**![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png)**

```
Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
Output: 0.00000
Explanation: There is no path between 0 and 2.
```

**Constraints:**

*   `2 <= n <= 10^4`
*   `0 <= start, end < n`
*   `start != end`
*   `0 <= a, b < n`
*   `a != b`
*   `0 <= succProb.length == edges.length <= 2*10^4`
*   `0 <= succProb[i] <= 1`
*   There is at most one edge between every two nodes.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/path-with-maximum-probability/discuss/731767/JavaPython-3-2-codes%3A-Bellman-Ford-and-Dijkstra's-algorithm-w-brief-explanation-and-analysis.)
* [](https://zxi.mytechroad.com/blog/graph/leetcode-1514-path-with-maximum-probability/)

V is the number of vertices; E is the total number of edges.
* Time complexity: O(ElogV)
* Space complexity: O(E+V)
```Python
import collections
import heapq

def maxProbability(n, edges, succProb, start, end):
    prob = [0] * n; prob[start] = 1
    graph = collections.defaultdict(list)
    for (a, b), sp in zip(edges, succProb):
        graph[a].append((b, sp))
        graph[b].append((a, sp))
    heap = []; heapq.heappush(heap, (-prob[start], start))
    while heap:
        p, cur = heapq.heappop(heap)
        if cur == end:
            return -p
        for nei, sp in graph[cur]:
            if prob[nei] < -p * sp:
                 prob[nei] = -p * sp
                 heapq.heappush(heap, (-prob[nei], nei))
    return 0

n = 3; edges = [[0,1],[1,2],[0,2]]; succProb = [0.5,0.5,0.2]; start = 0; end = 2
```

### [631\. Design Excel Sum Formula](https://leetcode.com/problems/design-excel-sum-formula/)

Difficulty: **Hard**  

Related Topics: [Graph](https://leetcode.com/tag/graph/), [Design](https://leetcode.com/tag/design/), [Topological Sort](https://leetcode.com/tag/topological-sort/)


Design the basic function of **Excel** and implement the function of the sum formula.

Implement the `Excel` class:

*   `Excel(int height, char width)` Initializes the object with the `height` and the `width` of the sheet. The sheet is an integer matrix `mat` of size `height x width` with the row index in the range `[1, height]` and the column index in the range `['A', width]`. All the values should be **zero** initially.
*   `void set(int row, char column, int val)` Changes the value at `mat[row][column]` to be `val`.
*   `int get(int row, char column)` Returns the value at `mat[row][column]`.
*   `int sum(int row, char column, List<String> numbers)` Sets the value at `mat[row][column]` to be the sum of cells represented by `numbers` and returns the value at `mat[row][column]`. This sum formula **should exist** until this cell is overlapped by another value or another sum formula. `numbers[i]` could be on the format:
    *   `"ColRow"` that represents a single cell.
        *   For example, `"F7"` represents the cell `mat[7]['F']`.
    *   `"ColRow1:ColRow2"` that represents a range of cells. The range will always be a rectangle where `"ColRow1"` represent the position of the top-left cell, and `"ColRow2"` represents the position of the bottom-right cell.
        *   For example, `"B3:F7"` represents the cells `mat[i][j]` for `3 <= i <= 7` and `'B' <= j <= 'F'`.

**Note:** You could assume that there will not be any circular sum reference.

*   For example, `mat[1]['A'] == sum(1, "B")` and `mat[1]['B'] == sum(1, "A")`.

**Example 1:**

```
Input
["Excel", "set", "sum", "set", "get"]
[[3, "C"], [1, "A", 2], [3, "C", ["A1", "A1:B2"]], [2, "B", 2], [3, "C"]]
Output
[null, null, 4, null, 6]

Explanation
Excel excel = new Excel(3, "C");
 // construct a 3*3 2D array with all zero.
 //   A B C
 // 1 0 0 0
 // 2 0 0 0
 // 3 0 0 0
excel.set(1, "A", 2);
 // set mat[1]["A"] to be 2.
 //   A B C
 // 1 2 0 0
 // 2 0 0 0
 // 3 0 0 0
excel.sum(3, "C", ["A1", "A1:B2"]); // return 4
 // set mat[3]["C"] to be the sum of value at mat[1]["A"] and the values sum of the rectangle range whose top-left cell is mat[1]["A"] and bottom-right cell is mat[2]["B"].
 //   A B C
 // 1 2 0 0
 // 2 0 0 0
 // 3 0 0 4
excel.set(2, "B", 2);
 // set mat[2]["B"] to be 2\. Note mat[3]["C"] should also be changed.
 //   A B C
 // 1 2 0 0
 // 2 0 2 0
 // 3 0 0 6
excel.get(3, "C"); // return 6
```

**Constraints:**

*   `1 <= height <= 26`
*   `'A' <= width <= 'Z'`
*   `1 <= row <= height`
*   `'A' <= column <= width`
*   `-100 <= val <= 100`
*   `1 <= numbers.length <= 5`
*   `numbers[i]` has the format `"ColRow"` or `"ColRow1:ColRow2"`.
*   At most `100` calls will be made to `set`, `get`, and `sum`.


#### Solution

Language: **Python**


* [](https://leetcode.com/problems/design-excel-sum-formula/discuss/104884/Simple-elegant-Python-solution)
They key here is to store a dictionary of cells to formulas, and as you parse the formula, recursively look up the dictionary to determine whether the cell contains a formula or a raw value. The bulk of the logic is within the `process` function which I added.
```python
class Excel(object):

    def __init__(self, H, W):
        """
        :type H: int
        :type W: str
        """
        self.height = H
        self.width = ord(W) - ord('A') + 2
        self.grid = [[0] * self.width for i in range(self.height+1)]
        self.formulas = {}

    def set(self, r, c, v):
        """
        :type r: int
        :type c: str
        :type v: int
        :rtype: void
        """
        char = ord(c) - ord('A') + 1
        self.grid[r][char] = v
        if (r, char) in self.formulas:
            del self.formulas[(r, char)]

    def get(self, r, c):
        """
        :type r: int
        :type c: str
        :rtype: int
        """
        return self.process(r, c)


    def sum(self, r, c, strs):
        """
        :type r: int
        :type c: str
        :type strs: List[str]
        :rtype: int
        """
        char = ord(c) - ord('A') + 1
        self.formulas[(r, char)] = strs
        return self.get(r, c)

    def process(self, r, c):
        """
        :type r: int
        :type c: str
        :rtype: void
        """
        total = 0
        c = ord(c) - ord('A') + 1
        if (r, c) not in self.formulas:
            return self.grid[r][c]

        formula = self.formulas[(r, c)]
        for fragment in formula:
            if ':' in fragment:
                start, end = fragment.split(':')
                start_row, start_col = int(start[1:]), ord(start[0])
                end_row, end_col = int(end[1:]), ord(end[0])
                for i in range(start_row, end_row+1):
                    for j in range(start_col, end_col+1):
                        total += self.get(i, chr(j))
            else:
                total += self.get(int(fragment[1]), fragment[0])
        return total
```

### [787\. Cheapest Flights Within K](https://leetcode.com/problems/cheapest-flights-within-k-stops/)

Difficulty: **Medium**  

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Graph](https://leetcode.com/tag/graph/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Shortest Path](https://leetcode.com/tag/shortest-path/)


There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [from<sub style="display: inline;">i</sub>, to<sub style="display: inline;">i</sub>, price<sub style="display: inline;">i</sub>]` indicates that there is a flight from city `from<sub style="display: inline;">i</sub>` to city `to<sub style="display: inline;">i</sub>` with cost `price<sub style="display: inline;">i</sub>`.

You are also given three integers `src`, `dst`, and `k`, return _**the cheapest price** from_ `src` _to_ `dst` _with at most_ `k` _stops._ If there is no such route, return`-1`.

**Example 1:**

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png)

```
Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
Output: 200
Explanation: The graph is shown.
The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.
```

**Example 2:**

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png)

```
Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
Output: 500
Explanation: The graph is shown.
The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.
```

**Constraints:**

*   `1 <= n <= 100`
*   `0 <= flights.length <= (n * (n - 1) / 2)`
*   `flights[i].length == 3`
*   `0 <= from<sub style="display: inline;">i</sub>, to<sub style="display: inline;">i</sub> < n`
*   `from<sub style="display: inline;">i</sub> != to<sub style="display: inline;">i</sub>`
*   `1 <= price<sub style="display: inline;">i</sub> <= 10<sup>4</sup>`
*   There will not be any multiple flights between two cities.
*   `0 <= src, dst, k < n`
*   `src != dst`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/267200/Python-Dijkstra)

```python
class Solution(object):
    def findCheapestPrice(self, n, flights, src, dst, k):
        """
        :type n: int
        :type flights: List[List[int]]
        :type src: int
        :type dst: int
        :type k: int
        :rtype: int
        """
        graph = collections.defaultdict(list)
        for s, e, p in flights:
            graph[s].append([e, p])

        heap = []
        heapq.heappush(heap, [0, src, k + 1]) # price, end, quota
        print graph
        while heap:
            p_cur, cur, quota = heapq.heappop(heap)
            print p_cur, cur, quota
            if cur == dst:
                return p_cur

            for nei, p_nei in graph[cur]:
                if quota - 1 >= 0:
                    heapq.heappush(heap, [p_nei + p_cur, nei, quota - 1])
        return -1
```

### [1466\. Reorder Routes to Make All Paths Lead to the City Zero](https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/)

Difficulty: **Medium**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Graph](https://leetcode.com/tag/graph/)


There are `n` cities numbered from `0` to `n - 1` and `n - 1` roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.

Roads are represented by `connections` where `connections[i] = [a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub>]` represents a road from city `a<sub style="display: inline;">i</sub>` to city `b<sub style="display: inline;">i</sub>`.

This year, there will be a big event in the capital (city `0`), and many people want to travel to this city.

Your task consists of reorienting some roads such that each city can visit the city `0`. Return the **minimum** number of edges changed.

It's **guaranteed** that each city can reach city `0` after reorder.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png)

```
Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
Output: 3
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/05/13/sample_2_1819.png)

```
Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
Output: 2
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
```

**Example 3:**

```
Input: n = 3, connections = [[1,0],[2,0]]
Output: 0
```

**Constraints:**

*   `2 <= n <= 5 * 10<sup>4</sup>`
*   `connections.length == n - 1`
*   `connections[i].length == 2`
*   `0 <= a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub> <= n - 1`
*   `a<sub style="display: inline;">i</sub> != b<sub style="display: inline;">i</sub>`


#### Solution

Language: **Python**

```python
# Solution 1: BFS
from collections import defaultdict
from collections import deque

class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        graph = defaultdict(list)

        for u, v in connections:
            graph[u].append((v, 1))
            graph[v].append((u, 0))

        q = deque([0])
        visited = {0}
        res = 0

        while q:
            city = q.popleft()

            for neighbor, cost in graph[city]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    res += cost
                    q.append(neighbor)

        return res


# Solution 2: DFS
from collections import defaultdict

class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        graph = defaultdict(list)

        for u, v in connections:
            graph[u].append((v, 1))
            graph[v].append((u, 0))

        visited = {0}
        res = [0]
        self.dfs(0, graph, visited, res)

        return res[0]

    def dfs(self, city: int, graph: dict, visited: set, res: List[int]) -> None:
        visited.add(city)

        for neighbor, cost in graph[city]:
            if neighbor not in visited:
                visited.add(neighbor)
                res[0] += cost
                self.dfs(neighbor, graph, visited, res)
```

### [1786\. Number of Restricted Paths From First to Last Node](https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/)

Difficulty: **Medium**  

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/), [Graph](https://leetcode.com/tag/graph/), [Topological Sort](https://leetcode.com/tag/topological-sort/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Shortest Path](https://leetcode.com/tag/shortest-path/)


There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [u<sub style="display: inline;">i</sub>, v<sub style="display: inline;">i</sub>, weight<sub style="display: inline;">i</sub>]` denotes that there is an edge between nodes `u<sub style="display: inline;">i</sub>` and `v<sub style="display: inline;">i</sub>` with weight equal to `weight<sub style="display: inline;">i</sub>`.

A path from node `start` to node `end` is a sequence of nodes `[z<sub style="display: inline;">0</sub>, z<sub style="display: inline;">1</sub>,z<sub style="display: inline;">2</sub>, ..., z<sub style="display: inline;">k</sub>]` such that `z<sub style="display: inline;">0</sub> = start` and `z<sub style="display: inline;">k</sub> = end` and there is an edge between `z<sub style="display: inline;">i</sub>` and `z<sub style="display: inline;">i+1</sub>` where `0 <= i <= k-1`.

The distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A **restricted path** is a path that also satisfies that `distanceToLastNode(z<sub style="display: inline;">i</sub>) > distanceToLastNode(z<sub style="display: inline;">i+1</sub>)` where `0 <= i <= k-1`.

Return _the number of restricted paths from node_ `1` _to node_ `n`. Since that number may be too large, return it **modulo** `10<sup>9</sup> + 7`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/17/restricted_paths_ex1.png)

```
Input: n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
Output: 3
Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The three restricted paths are:
1) 1 --> 2 --> 5
2) 1 --> 2 --> 3 --> 5
3) 1 --> 3 --> 5
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/17/restricted_paths_ex22.png)

```
Input: n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
Output: 1
Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The only restricted path is 1 --> 3 --> 7.
```

**Constraints:**

*   `1 <= n <= 2 * 10<sup>4</sup>`
*   `n - 1 <= edges.length <= 4 * 10<sup>4</sup>`
*   `edges[i].length == 3`
*   `1 <= u<sub style="display: inline;">i</sub>, v<sub style="display: inline;">i</sub> <= n`
*   `u<sub style="display: inline;">i</sub> != v<sub style="display: inline;">i</sub>`
*   `1 <= weight<sub style="display: inline;">i</sub> <= 10<sup>5</sup>`
*   There is at most one edge between any two nodes.
*   There is at least one path between any two nodes.


#### Solution

Language: **Python3**

```python
class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        if n == 1: return 0
        graph = defaultdict(list)
        for u, v, w in edges:
            graph[u].append((w, v))
            graph[v].append((w, u))

        def dijkstra():  # Dijkstra to find shortest distance of paths from node `n` to any other nodes
            minHeap = [(0, n)]  # dist, node
            dist = [float('inf')] * (n + 1)
            dist[n] = 0
            while minHeap:
                d, u = heappop(minHeap)
                if d != dist[u]: continue
                for w, v in graph[u]:
                    if dist[v] > dist[u] + w:
                        dist[v] = dist[u] + w
                        heappush(minHeap, (dist[v], v))
            return dist

        @lru_cache(None)
        def dfs(src):
            if src == n: return 1  # Found a path to reach to destination
            ans = 0
            for _, nei in graph[src]:
                if dist[src] > dist[nei]:
                    ans = (ans + dfs(nei)) % 1000000007
            return ans

        dist = dijkstra()
        return dfs(1)
```

### [133\. Clone Graph](https://leetcode.com/problems/clone-graph/)

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Graph](https://leetcode.com/tag/graph/)


Given a reference of a node in a undirected graph.

Return a (clone) of the graph.

Each node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.

```
class Node {
    public int val;
    public List <node>neighbors;
}</node>
```

**Test case format:**

For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with `val == 1`, the second node with `val == 2`, and so on. The graph is represented in the test case using an adjacency list.

**An adjacency list** is a collection of unordered **lists** used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.

The given node will always be the first node with `val = 1`. You must return the **copy of the given node** as a reference to the cloned graph.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png)

```
Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]
Explanation: There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/01/07/graph.png)

```
Input: adjList = [[]]
Output: [[]]
Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
```

**Example 3:**

```
Input: adjList = []
Output: []
Explanation: This an empty graph, it does not have any nodes.
```

**Constraints:**

*   The number of nodes in the graph is in the range `[0, 100]`.
*   `1 <= Node.val <= 100`
*   `Node.val` is unique for each node.
*   There are no repeated edges and no self-loops in the graph.
*   The Graph is connected and all nodes can be visited starting from the given node.


#### Solution

Language: **Python**

```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution(object):
    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        d = {}
        def dfs(node):
            if node in d:
                return d[node]
            if not node:
                return

            copy = Node(node.val)
            d[node] = copy
            for nei in node.neighbors:
                copy.neighbors.append(dfs(nei))

            return copy
        return dfs(node)
```

### [417\. Pacific Atlantic Water Flow :rainbow:](https://leetcode.com/problems/pacific-atlantic-water-flow/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Matrix](https://leetcode.com/tag/matrix/)


There is an `m x n` rectangular island that borders both the **Pacific Ocean** and **Atlantic Ocean**. The **Pacific Ocean** touches the island's left and top edges, and the **Atlantic Ocean** touches the island's right and bottom edges.

The island is partitioned into a grid of square cells. You are given an `m x n` integer matrix `heights` where `heights[r][c]` represents the **height above sea level** of the cell at coordinate `(r, c)`.

The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.

Return _a **2D list** of grid coordinates_ `result` _where_ `result[i] = [r<sub style="display: inline;">i</sub>, c<sub style="display: inline;">i</sub>]` _denotes that rain water can flow from cell_ `(r<sub style="display: inline;">i</sub>, c<sub style="display: inline;">i</sub>)` _to **both** the Pacific and Atlantic oceans_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)

```
Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

**Example 2:**

```
Input: heights = [[2,1],[1,2]]
Output: [[0,0],[0,1],[1,0],[1,1]]
```

**Constraints:**

*   `m == heights.length`
*   `n == heights[r].length`
*   `1 <= m, n <= 200`
*   `0 <= heights[r][c] <= 10<sup>5</sup>`


#### Solution

Language: **Python**

```python
class Solution(object):
    def pacificAtlantic(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: List[List[int]]
        """
        m, n = len(heights), len(heights[0])
        p_set, a_set = set(), set()

        def dfs(r, c, prev, visit):
            if 0 <= r < m and 0 <= c < n and heights[r][c] >= prev and (r, c) not in visit:    
                visit.add((r, c))
                dfs(r - 1, c, heights[r][c], visit)
                dfs(r + 1, c, heights[r][c], visit)
                dfs(r, c - 1, heights[r][c], visit)
                dfs(r, c + 1, heights[r][c], visit)

        for j in range(n):
            dfs(0, j, heights[0][j], p_set)
            dfs(m - 1, j, heights[m - 1][j], a_set)

        for i in range(m):
            dfs(i, 0, heights[i][0], p_set)
            dfs(i, n - 1, heights[i][n - 1], a_set)

        res = []
        for i in range(m):
            for j in range(n):
                cell = (i, j)
                if cell in p_set and cell in a_set:
                    res.append([i, j])
        return res
```

### [261\. Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/)

Difficulty: **Medium**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Graph](https://leetcode.com/tag/graph/)


You have a graph of `n` nodes labeled from `0` to `n - 1`. You are given an integer n and a list of `edges` where `edges[i] = [a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub>]` indicates that there is an undirected edge between nodes `a<sub style="display: inline;">i</sub>` and `b<sub style="display: inline;">i</sub>` in the graph.

Return `true` _if the edges of the given graph make up a valid tree, and_ `false` _otherwise_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/12/tree1-graph.jpg)

```
Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/12/tree2-graph.jpg)

```
Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]
Output: false
```

**Constraints:**

*   `1 <= n <= 2000`
*   `0 <= edges.length <= 5000`
*   `edges[i].length == 2`
*   `0 <= a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub> < n`
*   `a<sub style="display: inline;">i</sub> != b<sub style="display: inline;">i</sub>`
*   There are no self-loops or repeated edges.


#### Solution

Language: **Python**

```python
class Solution(object):
    def validTree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """
        graph = collections.defaultdict(list)
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)

        def dfs(node, prev):
            if node in visit:
                return False
            visit.add(node)
            for nei in graph[node]:
                if nei == prev:
                    continue
                if not dfs(nei, node):
                    return False
            return True

        visit = set()
        return len(visit) == n and dfs(0, None)

class Solution(object):
    def validTree(self, n, edges):
        if len(edges) != n - 1:
            return False
        parent = range(n)
        def find(x):
            return x if parent[x] == x else find(parent[x])
        def union(xy):
            x, y = map(find, xy)
            parent[x] = y
            return x != y
        return all(map(union, edges))      
```

### [463\. Island Perimeter :rainbow:](https://leetcode.com/problems/island-perimeter/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Matrix](https://leetcode.com/tag/matrix/)


You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.

Grid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).

The island doesn't have "lakes", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1\. The grid is rectangular, width and height don't exceed 100\. Determine the perimeter of the island.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/10/12/island.png)

```
Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
Output: 16
Explanation: The perimeter is the 16 yellow stripes in the image above.
```

**Example 2:**

```
Input: grid = [[1]]
Output: 4
```

**Example 3:**

```
Input: grid = [[1,0]]
Output: 4
```

**Constraints:**

*   `row == grid.length`
*   `col == grid[i].length`
*   `1 <= row, col <= 100`
*   `grid[i][j]` is `0` or `1`.
*   There is exactly one island in `grid`.


#### Solution

Language: **Python**


```python
class Solution(object):
    def islandPerimeter(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        def dfs(i, j):
            if (i, j) in visit:
                return 0
            if not (i in range(m) and j in range(n) and grid[i][j] == 1):
                return 1
            visit.add((i, j))
            perimeter = dfs(i, j + 1)
            perimeter += dfs(i + 1, j)
            perimeter += dfs(i, j - 1)
            perimeter += dfs(i - 1, j)
            return perimeter


        m, n = len(grid), len(grid[0])
        visit = set()

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    return dfs(i, j)


class Solution(object):
    def islandPerimeter(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        def dfs(i, j):
            for x, y in [[1, 0], [0, 1], [-1, 0], [0, -1]]:
                ni, nj = i + x, j + y
                if (ni, nj) in visit:
                    continue
                if not (ni in range(m) and nj in range(n) and grid[ni][nj] == 1):
                    self.count += 1
                    continue
                visit.add((ni, nj))
                dfs(ni, nj)


        m, n = len(grid), len(grid[0])
        visit = set()
        self.count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and (i, j) not in visit:
                    visit.add((i, j))
                    dfs(i, j)
        return self.count
```

### [743\. Network Delay Time](https://leetcode.com/problems/network-delay-time/)

Difficulty: **Medium**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Graph](https://leetcode.com/tag/graph/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Shortest Path](https://leetcode.com/tag/shortest-path/)


You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (u<sub style="display: inline;">i</sub>, v<sub style="display: inline;">i</sub>, w<sub style="display: inline;">i</sub>)`, where `u<sub style="display: inline;">i</sub>` is the source node, `v<sub style="display: inline;">i</sub>` is the target node, and `w<sub style="display: inline;">i</sub>` is the time it takes for a signal to travel from source to target.

We will send a signal from a given node `k`. Return the time it takes for all the `n` nodes to receive the signal. If it is impossible for all the `n` nodes to receive the signal, return `-1`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)

```
Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2
```

**Example 2:**

```
Input: times = [[1,2,1]], n = 2, k = 1
Output: 1
```

**Example 3:**

```
Input: times = [[1,2,1]], n = 2, k = 2
Output: -1
```

**Constraints:**

*   `1 <= k <= n <= 100`
*   `1 <= times.length <= 6000`
*   `times[i].length == 3`
*   `1 <= u<sub style="display: inline;">i</sub>, v<sub style="display: inline;">i</sub> <= n`
*   `u<sub style="display: inline;">i</sub> != v<sub style="display: inline;">i</sub>`
*   `0 <= w<sub style="display: inline;">i</sub> <= 100`
*   All the pairs `(u<sub style="display: inline;">i</sub>, v<sub style="display: inline;">i</sub>)` are **unique**. (i.e., no multiple edges.)


#### Solution

Language: **Python**

```python
class Solution(object):
    def networkDelayTime(self, times, n, k):
        """
        :type times: List[List[int]]
        :type n: int
        :type k: int
        :rtype: int
        """
        graph = collections.defaultdict(list)

        for source, dest, weight in times:
            graph[source].append((dest,weight))


        # empiezas con un priority queue con 0 y K porque ya estas
        # en la posicion k y no te cuesta nada llegar a k
        # entonces tu priority queue guarda la distancia y el nodo en el que estas  
        pq = [(0, k)]
        visited_dist = {}

        while pq:
            d, node = heapq.heappop(pq)

            # si ya tienes el node en dist significa que ya llegaste a el
            # entonces no tienes que regresar
            if node in visited_dist: continue
            visited_dist[node] = d

            for destination_node, weight in graph[node]:
                if destination_node not in visited_dist:
                    heapq.heappush(pq, (d+weight, destination_node))


        # el tiempo mas grande es el que te va a tomar llegar a todos los nodos
        # nsi la distance de dist es igual a los nodos y si no no puedes llegar
        return max(visited_dist.values()) if len(visited_dist) == n else -1
```


### [1905\. Count Sub Islands :rainbow:](https://leetcode.com/problems/count-sub-islands/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Matrix](https://leetcode.com/tag/matrix/)


You are given two `m x n` binary matrices `grid1` and `grid2` containing only `0`'s (representing water) and `1`'s (representing land). An **island** is a group of `1`'s connected **4-directionally** (horizontal or vertical). Any cells outside of the grid are considered water cells.

An island in `grid2` is considered a **sub-island** if there is an island in `grid1` that contains **all** the cells that make up **this** island in `grid2`.

Return the _**number** of islands in_ `grid2` _that are considered **sub-islands**_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/06/10/test1.png)

```
Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
Output: 3
Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png)

```
Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
Output: 2
Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.
```

**Constraints:**

*   `m == grid1.length == grid2.length`
*   `n == grid1[i].length == grid2[i].length`
*   `1 <= m, n <= 500`
*   `grid1[i][j]` and `grid2[i][j]` are either `0` or `1`.


#### Solution

Language: **Python**

```python
class Solution(object):
    def countSubIslands(self, grid1, grid2):
        """
        :type grid1: List[List[int]]
        :type grid2: List[List[int]]
        :rtype: int
        """
        def dfs(grid, r, c):
            grid[r][c] = 0
            for x, y in [[1, 0], [0, 1], [-1, 0], [0, -1]]:
                nr, nc = r + x, c + y
                if nr in range(m) and nc in range(n) and grid[nr][nc] == 1:
                    dfs(grid, nr, nc)

        m, n = len(grid1), len(grid1[0])
        for i in range(m):
            for j in range(m):
                if grid1[i][j] == 0 and grid2[i][j] == 1:
                    dfs(grid2, i, j)

        print grid2
        count = 0
        for i in range(m):
            for j in range(m):
                if grid1[i][j] == 1 and grid2[i][j] == 1:
                    dfs(grid2, i, j)
                    count += 1
        return count
```

### [778\. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Matrix](https://leetcode.com/tag/matrix/)


You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`.

The rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.

Return _the least time until you can reach the bottom right square_ `(n - 1, n - 1)` _if you start at the top left square_ `(0, 0)`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg)

```
Input: grid = [[0,2],[1,3]]
Output: 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.
You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)

```
Input: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation: The final route is shown.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.
```

**Constraints:**

*   `n == grid.length`
*   `n == grid[i].length`
*   `1 <= n <= 50`
*   `0 <= grid[i][j] < n<sup>2</sup>`
*   Each value `grid[i][j]` is **unique**.


#### Solution

Language: **Python**

```python
class Solution(object):
    def swimInWater(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        N = len(grid)
        visit = set()
        minH = [[grid[0][0], 0, 0]] # (time/max-height, r, c)
        directions = [[0, 1], [0, -1], [1, 0], [-1 ,0]]
        
        visit.add((0, 0))
        while minH:
            t, r, c = heapq.heappop(minH)
            if r == N - 1 and c == N - 1:
                return t
            for dr, dc in directions:
                neiR, neiC = r + dr, c + dc
                if (neiR < 0 or neiC < 0 or
                    neiR == N or neiC == N or
                    (neiR, neiC) in visit):
                    continue
                visit.add((neiR, neiC))
                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])
```

## Topological Sort
### [269\. Alien Dictionary :rainbow:](https://leetcode.com/problems/alien-dictionary/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Graph](https://leetcode.com/tag/graph/), [Topological Sort](https://leetcode.com/tag/topological-sort/)


There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.

You are given a list of strings `words` from the alien language's dictionary, where the strings in `words` are **sorted lexicographically** by the rules of this new language.

Return _a string of the unique letters in the new alien language sorted in **lexicographically increasing order** by the new language's rules. If there is no solution, return_ `""`_. If there are multiple solutions, return **any of them**_.

A string `s` is **lexicographically smaller** than a string `t` if at the first letter where they differ, the letter in `s` comes before the letter in `t` in the alien language. If the first `min(s.length, t.length)` letters are the same, then `s` is smaller if and only if `s.length < t.length`.

**Example 1:**

```
Input: words = ["wrt","wrf","er","ett","rftt"]
Output: "wertf"
```

**Example 2:**

```
Input: words = ["z","x"]
Output: "zx"
```

**Example 3:**

```
Input: words = ["z","x","z"]
Output: ""
Explanation: The order is invalid, so return "".
```

**Constraints:**

*   `1 <= words.length <= 100`
*   `1 <= words[i].length <= 100`
*   `words[i]` consists of only lowercase English letters.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/alien-dictionary/discuss/208057/Python-solution)
```Python
import collections
words = ["wrt","wrf","er","ett","rftt"]

class Solution(object):
    def alienOrder(self, words):
        """
        :type words: List[str]
        :rtype: str
        """
        # records all characters appeared in words
        nodes = set()
        for word in words:
            nodes |= set(word)

        # construct the graph
        graph = collections.defaultdict(set)
        for i in range(len(words)-1):
            k = 0
            while k < len(words[i]) and k < len(words[i+1]):
                if words[i][k] != words[i+1][k]:
                    graph[words[i][k]].add(words[i+1][k])
                    break
                else:
                    k += 1

        def dfs(node): #  cycle
            seen[node] = 0 # 0: visiting
            for nei in graph[node]:
                if nei in seen:
                    if seen[nei] == 0:
                        return False
                else:
                    if not dfs(nei):
                        return False
            seen[node] = 1 # 1: visited
            res.appendleft(node)
            return True

        # topologically sort the characters
        res = collections.deque()
        seen = {}
        for node in nodes:
            if node not in seen:
                if not dfs(node):
                    return ""
        return "".join(res)
```

### [207\. Course Schedule](https://leetcode.com/problems/course-schedule/)

Difficulty: **Medium**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Graph](https://leetcode.com/tag/graph/), [Topological Sort](https://leetcode.com/tag/topological-sort/)


There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub>]` indicates that you **must** take course `b<sub style="display: inline;">i</sub>` first if you want to take course `a<sub style="display: inline;">i</sub>`.

*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return `true` if you can finish all courses. Otherwise, return `false`.

**Example 1:**

```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take.
To take course 1 you should have finished course 0\. So it is possible.
```

**Example 2:**

```
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take.
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1\. So it is impossible.
```

**Constraints:**

*   `1 <= numCourses <= 10<sup>5</sup>`
*   `0 <= prerequisites.length <= 5000`
*   `prerequisites[i].length == 2`
*   `0 <= a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub> < numCourses`
*   All the pairs prerequisites[i] are **unique**.


#### Solution

Language: **Python**

DAGDAG

DFS

visitedvisited[i]0visited[i]1visited[i]2



O(N)O(N)

* [](https://www.youtube.com/watch?v=71YnLt1c4kw&list=PLo4Ori3OC75DW0ScujZKViWewqydHESnL&index=34&ab_channel=AHTech)
```python
def canFinish(N, prerequisites):
    """
    :type N,: int
    :type prerequisites: List[List[int]]
    :rtype: bool
    """
    graph = collections.defaultdict(list)
    for u, v in prerequisites:
        graph[u].append(v)
    # 0 = Unknown, 1 = visiting, 2 = visited
    visited = [0] * N
    for i in range(N):
        if not dfs(graph, visited, i):
            return False
    return True

# Can we add node i to visited successfully?
def dfs(graph, visited, i):
    if visited[i] == 1: return False
    if visited[i] == 2: return True
    visited[i] = 1
    for j in graph[i]:
        if not dfs(graph, visited, j):
            return False
    visited[i] = 2
    return True

numCourses = 4
prerequisites = [[1, 0], [0, 2], [3, 1]]

canFinish(numCourses, prerequisites)
```


```python
import collections
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        edges = [[] for i in range(numCourses)]
        degrees = [0] * numCourses
        for course, pre_course in prerequisites:
            edges[pre_course].append(course)
            degrees[course] += 1

        queue = collections.deque(course for course, degree in enumerate(degrees) if not degree)
        while queue:
            course = queue.popleft()
            for next_course in edges[course]:
                degrees[next_course] -= 1
                if not degrees[next_course]:
                    queue.append(next_course)

        return not sum(degrees)

numCourses = 4
prerequisites = [[1, 0], [0, 2], [3, 1]]
```

### [210\. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/)

Difficulty: **Medium**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Graph](https://leetcode.com/tag/graph/), [Topological Sort](https://leetcode.com/tag/topological-sort/)


There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub>]` indicates that you **must** take course `b<sub style="display: inline;">i</sub>` first if you want to take course `a<sub style="display: inline;">i</sub>`.

*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return _the ordering of courses you should take to finish all courses_. If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array**.

**Example 1:**

```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0\. So the correct course order is [0,1].
```

**Example 2:**

```
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2\. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
```

**Example 3:**

```
Input: numCourses = 1, prerequisites = []
Output: [0]
```

**Constraints:**

*   `1 <= numCourses <= 2000`
*   `0 <= prerequisites.length <= numCourses * (numCourses - 1)`
*   `prerequisites[i].length == 2`
*   `0 <= a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub> < numCourses`
*   `a<sub style="display: inline;">i</sub> != b<sub style="display: inline;">i</sub>`
*   All the pairs `[a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub>]` are **distinct**.


#### Solution

Language: **Python**

```python
def findOrder(numCourses, prerequisites):
    """
    :type numCourses: int
    :type prerequisites: List[List[int]]
    :rtype: List[int]
    """
    graph = collections.defaultdict(list)
    for u, v in prerequisites:
        graph[u].append(v)
    # 0 = Unknown, 1 = visiting, 2 = visited
    visited = [0] * numCourses
    path = collections.deque([])
    for i in range(numCourses):
        if not dfs(graph, visited, i, path):
            return []
    return path

def dfs(graph, visited, i, path):
    if visited[i] == 1: return False
    if visited[i] == 2: return True
    visited[i] = 1
    for j in graph[i]:
        if not dfs(graph, visited, j, path):
            return False
    visited[i] = 2
    path.appendleft(i)
    return True

numCourses = 4
prerequisites = [[1, 0], [2, 0], [3, 1], [3, 2]]

findOrder(numCourses, prerequisites)
```

```python
import collections
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        edges = [[] for i in range(numCourses)]
        degrees = [0] * numCourses
        for course, pre_course in prerequisites:
            edges[pre_course].append(course)
            degrees[course] += 1

        queue = collections.deque(course for course, degree in enumerate(degrees) if not degree)
        while queue:
            course = queue.popleft()
            for next_course in edges[course]:
                degrees[next_course] -= 1
                if not degrees[next_course]:
                    queue.append(next_course)

        return not sum(degrees)


def findOrder(n, prerequisites):
    graph = [[] for i in range(n)]
    degree = [0] * n
    for course, pre_course in prerequisites:
        graph[pre_course].append(course)
        degree[course] += 1
    queue = [course for course in range(n) if degree[course] == 0]
    for course in queue:
        for next_course in graph[course]:
            degree[next_course] -= 1
            if degree[next_course] == 0:
                queue.append(next_course)
    return queue if len(queue) == n else []

n = numCourses = 4
prerequisites = [[1, 0], [2, 0], [3, 1], [3, 2]]
findOrder(n, prerequisites)

# 0n-1
def allPathsSourceTarget(self, graph):
    """
    :type graph: List[List[int]]
    :rtype: List[List[int]]
    """
    n = len(graph)
    res = []
    paths = [[0]]
    while paths:
        next_level = []
        for path in paths:
            if path[-1] == n - 1:
                res.append(path)
                continue
            for node in graph[path[-1]]:
                next_level.append(path + [node])
        paths = next_level
    return res
```


## Union Find
### [721\. Accounts Merge](https://leetcode.com/problems/accounts-merge/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [String](https://leetcode.com/tag/string/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/)


Given a list of `accounts` where each element `accounts[i]` is a list of strings, where the first element `accounts[i][0]` is a name, and the rest of the elements are **emails** representing emails of the account.

Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.

After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails **in sorted order**. The accounts themselves can be returned in **any order**.

**Example 1:**

```
Input: accounts = [["John","johnsmith@mail.com","john_newyork@mail.com"],["John","johnsmith@mail.com","john00@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]
Output: [["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]
Explanation:
The first and second John's are the same person as they have the common email "johnsmith@mail.com".
The third John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
```

**Example 2:**

```
Input: accounts = [["Gabe","Gabe0@m.co","Gabe3@m.co","Gabe1@m.co"],["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]
Output: [["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]
```

**Constraints:**

*   `1 <= accounts.length <= 1000`
*   `2 <= accounts[i].length <= 10`
*   `1 <= accounts[i][j] <= 30`
*   `accounts[i][0]` consists of English letters.
*   `accounts[i][j] (for j > 0)` is a valid email.


#### Solution

Language: **Python**

```Python
from collections import defaultdict

def accountsMerge(accounts):
    visited_accounts = [False] * len(accounts)
    emails_accounts_map = defaultdict(list)
    res = []
    # Build up the graph.
    for i, account in enumerate(accounts):
        for j in range(1, len(account)):
            email = account[j]
            emails_accounts_map[email].append(i)
    # DFS code for traversing accounts.
    def dfs(i, emails):
        if visited_accounts[i]:
            return
        visited_accounts[i] = True
        for j in range(1, len(accounts[i])):
            email = accounts[i][j]
            emails.add(email)
            for neighbor in emails_accounts_map[email]:
                dfs(neighbor, emails)
    # Perform DFS for accounts and add to results.
    for i, account in enumerate(accounts):
        if visited_accounts[i]:
            continue
        name, emails = account[0], set()
        dfs(i, emails)
        res.append([name] + sorted(emails))
    return res

accounts = [["John","johnsmith@mail.com","john_newyork@mail.com"],["John","johnsmith@mail.com","john00@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]
```

### [200\. Number of Islands :rainbow:](https://leetcode.com/problems/number-of-islands/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Matrix](https://leetcode.com/tag/matrix/)


Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

**Example 2:**

```
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

**Constraints:**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 300`
*   `grid[i][j]` is `'0'` or `'1'`.


#### Solution

Language: **Python**

```python
def numIslands(grid):
    n = len(grid)
    m = len(grid[0])
    result = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '1':
                dfs(i, j, m, n)
                result += 1
    return result

def dfs(i, j, m, n):
    dirs = [[-1, 0], [0, 1], [0, -1], [1, 0]]
    grid[i][j] = "0"
    for dir in dirs:
        next_i, next_j = i + dir[0], j + dir[1]
        if 0 <= next_i < n and 0 <= next_j < m and grid[next_i][next_j] == '1':
            dfs(next_i, next_j, m, n)

from collections import deque
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    #print(i,j,grid)
                    grid[i][j] = '0'
                    self.helper(grid,i,j)
                    count += 1
        return count
    # use a helper function to flip connected '1's to 0
    def helper(self,grid,i,j):
        queue = deque([(i,j)])
        while queue:
            I,J = queue.popleft()
            for i,j in [I+1,J],[I,J+1],[I-1,J],[I,J-1]:
                if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == '1':
                    #print(i,j, queue)
                    grid[i][j] = '0'
                    queue.append((i,j))
```

Follow up
```Python
def numIslands(grid):
    n = len(grid)
    m = len(grid[0])
    nextColor = 2
    componentSize = collections.defaultdict(int)
    # 1st travese to count size
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '1':
                dfs(i, j, m, n, nextColor)
                nextColor += 1
    # 2nd traverse to fill size            
    for i in range(n):
        for j in range(m):
            if grid[i][j] in componentSize:
                grid[i][j] = str(componentSize[grid[i][j]])
    return

def dfs(i, j, m, n, color):
    dirs = [[-1, 0], [0, 1], [0, -1], [1, 0]]
    grid[i][j] = str(nextColor)
    componentSize[str(color)] += 1
    for dir in dirs:
        next_i, next_j = i + dir[0], j + dir[1]
        if 0 <= next_i < n and 0 <= next_j < m and grid[next_i][next_j] == '1':
                dfs(next_i, next_j, m, n, nextColor)

grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
```

```Python
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(x, y):
            print x, y
            rx, ry = find(x), find(y)
            if rx != ry:
                parent[rx] = ry
                self.size -= 1

        m, n = len(grid), len(grid[0])
        self.size = 0
        parent = {}
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    self.size += 1
                    parent[(i, j)] = (i, j)

        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    for di, dj in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                        ni, nj = i + di, j + dj
                        if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == '1':
                            union((i, j), (ni, nj))

        return self.size               
```

### [128\. Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Union Find](https://leetcode.com/tag/union-find/)


Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Example 2:**

```
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9
```

**Constraints:**

*   `0 <= nums.length <= 10<sup>5</sup>`
*   `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`


#### Solution

Language: **Python**

```python
def longestConsecutive(nums):
    unions = {};
    maxlen = 0;
    for num in nums:
        if unions.has_key(num): # duplicate n, skip
            continue;
        start = end = num;
        if unions.has_key(num+1): # update end if has bigger neighbouring section
            end = unions[num+1][1];
        if unions.has_key(num-1): # update start if has smaller neighbouring section
            start = unions[num-1][0];
        unions[start] = unions[end] = unions[num]=(start,end);
        maxlen = max(end-start+1, maxlen);
    return maxlen;

longestConsecutive(nums = [1,2,4,3])

# scan nums and see if num is the start of a sequence and count its length
class Solution(object):
    def longestConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        num_set = set(nums)
        ans = 0
        for num in nums:
            size = 1
            if num - 1 not in num_set:
                next = num + 1
                while next in num_set:
                    size += 1
                    next += 1
            ans = max(size, ans)
        return ans
```

### [305\. Number of Islands II :fire:](https://leetcode.com/problems/number-of-islands-ii/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Union Find](https://leetcode.com/tag/union-find/)


You are given an empty 2D binary grid `grid` of size `m x n`. The grid represents a map where `0`'s represent water and `1`'s represent land. Initially, all the cells of `grid` are water cells (i.e., all the cells are `0`'s).

We may perform an add land operation which turns the water at position into a land. You are given an array `positions` where `positions[i] = [r<sub style="display: inline;">i</sub>, c<sub style="display: inline;">i</sub>]` is the position `(r<sub style="display: inline;">i</sub>, c<sub style="display: inline;">i</sub>)` at which we should operate the `i<sup>th</sup>` operation.

Return _an array of integers_ `answer` _where_ `answer[i]` _is the number of islands after turning the cell_ `(r<sub style="display: inline;">i</sub>, c<sub style="display: inline;">i</sub>)` _into a land_.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/10/tmp-grid.jpg)

```
Input: m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
Output: [1,1,2,3]
Explanation:
Initially, the 2d grid is filled with water.
- Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land. We have 1 island.
- Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land. We still have 1 island.
- Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land. We have 2 islands.
- Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land. We have 3 islands.
```

**Example 2:**

```
Input: m = 1, n = 1, positions = [[0,0]]
Output: [1]
```

**Constraints:**

*   `1 <= m, n, positions.length <= 10<sup>4</sup>`
*   `1 <= m * n <= 10<sup>4</sup>`
*   `positions[i].length == 2`
*   `0 <= r<sub style="display: inline;">i</sub> < m`
*   `0 <= c<sub style="display: inline;">i</sub> < n`

**Follow up:** Could you solve it in time complexity `O(k log(mn))`, where `k == positions.length`?


#### Solution

Language: **Python**

* Time complexity : O(mn+L) where LL is the number of operations, m is the number of rows and n is the number of columns. it takes O(mn) to initialize UnionFind, and O(L) to process positions. Note that Union operation takes essentially constant time[1] when UnionFind is implemented with both path compression and union by rank.
* Space complexity : O(mn) as required by UnionFind data structure.

```python
class Solution(object):
    def numIslands2(self, m, n, positions):
        """
        :type m: int
        :type n: int
        :type positions: List[List[int]]
        :rtype: List[int]
        """
        parent = {}
        count[0] = 0
        result = []
        def find(x):
            if parent[x] != x:
                return find(parent[x])
            else:
                return x

        def union(x, y):
            x, y = find(x), find(y)
            if x!=y:
                parent[y] = x
                count[0] -= 1

        for pos in positions:
            i, j = pos
            pos = (i, j)
            parent[pos] = pos
            count[0] += 1
            for neighbor in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:
                if neighbor in parent:
                    union(pos, neighbor)
            result.append(count[0])
        return result

numIslands2(m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]])
```

### [827\. Making A Large Island :fire:](https://leetcode.com/problems/making-a-large-island/)

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Matrix](https://leetcode.com/tag/matrix/)


You are given an `n x n` binary matrix `grid`. You are allowed to change **at most one** `0` to be `1`.

Return _the size of the largest **island** in_ `grid` _after applying this operation_.

An **island** is a 4-directionally connected group of `1`s.

**Example 1:**

```
Input: grid = [[1,0],[0,1]]
Output: 3
Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.
```

**Example 2:**

```
Input: grid = [[1,1],[1,0]]
Output: 4
Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.
```

**Example 3:**

```
Input: grid = [[1,1],[1,1]]
Output: 4
Explanation: Can't change any 0 to 1, only one island with area = 4.
```

**Constraints:**

*   `n == grid.length`
*   `n == grid[i].length`
*   `1 <= n <= 500`
*   `grid[i][j]` is either `0` or `1`.


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/making-a-large-island/discuss/1375992/C%2B%2BPython-DFS-paint-different-colors-Union-Find-Solutions-with-Picture-Clean-and-Concise)
```Python
from collections import defaultdict
grid = [[1,0],[0,1]]
class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        DIR = [0, 1, 0, -1, 0]
        m, n, nextColor = len(grid), len(grid[0]), 2
        componentSize = defaultdict(int)

        def paint(r, c, color):
            if r < 0 or r == m or c < 0 or c == n or grid[r][c] != 1: return
            grid[r][c] = color
            componentSize[color] += 1
            for i in range(4):
                paint(r + DIR[i], c + DIR[i + 1], color)

        for r in range(m):
            for c in range(n):
                if grid[r][c] != 1: continue  # Only paint when it's an island cell
                paint(r, c, nextColor)
                nextColor += 1

        ans = max(componentSize.values() or [0])
        for r in range(m):
            for c in range(n):
                if grid[r][c] != 0: continue
                neiColors = set()
                for i in range(4):
                    nr, nc = r + DIR[i], c + DIR[i + 1]
                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == 0: continue
                    neiColors.add(grid[nr][nc])
                sizeFormed = 1  # Start with 1, which is matrix[r][c] when turning from 0 into 1
                for color in neiColors:
                    sizeFormed += componentSize[color]
                ans = max(ans, sizeFormed)
        return ans
```

### [1584\. Min Cost to Connect All Points :rainbow:](https://leetcode.com/problems/min-cost-to-connect-all-points/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Union Find](https://leetcode.com/tag/union-find/), [Minimum Spanning Tree](https://leetcode.com/tag/minimum-spanning-tree/)


You are given an array `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [x<sub style="display: inline;">i</sub>, y<sub style="display: inline;">i</sub>]`.

The cost of connecting two points `[x<sub style="display: inline;">i</sub>, y<sub style="display: inline;">i</sub>]` and `[x<sub style="display: inline;">j</sub>, y<sub style="display: inline;">j</sub>]` is the **manhattan distance** between them: `|x<sub style="display: inline;">i</sub> - x<sub style="display: inline;">j</sub>| + |y<sub style="display: inline;">i</sub> - y<sub style="display: inline;">j</sub>|`, where `|val|` denotes the absolute value of `val`.

Return _the minimum cost to make all points connected._ All points are connected if there is **exactly one** simple path between any two points.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/08/26/d.png)

```
Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20
Explanation:

We can connect the points as shown above to get the minimum cost of 20.
Notice that there is a unique path between every pair of points.
```

**Example 2:**

```
Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18
```

**Example 3:**

```
Input: points = [[0,0],[1,1],[1,0],[-1,1]]
Output: 4
```

**Example 4:**

```
Input: points = [[-1000000,-1000000],[1000000,1000000]]
Output: 4000000
```

**Example 5:**

```
Input: points = [[0,0]]
Output: 0
```

**Constraints:**

*   `1 <= points.length <= 1000`
*   `-10<sup>6</sup> <= x<sub style="display: inline;">i</sub>, y<sub style="display: inline;">i</sub> <= 10<sup>6</sup>`
*   All pairs `(x<sub style="display: inline;">i</sub>, y<sub style="display: inline;">i</sub>)` are distinct.


#### Solution

Language: **Python**

* [](https://www.youtube.com/watch?v=E8cDVhmkKSQ&ab_channel=AHTech)
* Time Complexity: `O(ElogE)`
* Space Complexity: `O(E+V)`
```python
class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        edges = []

        for i in range(n):
            for j in range(i+1, n):
                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])
                edges.append((d, i, j))

        edges.sort()

        roots = [i for i in range(n)]

        def find(v):
            if roots[v] != v:
                roots[v] = find(roots[v])
            return roots[v]

        def union(u, v):
            p1 = find(u); p2 = find(v)
            if p1 != p2:
                roots[p2] = roots[p1]
                return True
            return False

        res = 0
        for d, u, v in edges:
            if union(u, v):
                res += d
        return res
```

### [547\. Number of Provinces](https://leetcode.com/problems/number-of-provinces/)

Difficulty: **Medium**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Graph](https://leetcode.com/tag/graph/)


There are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.

A **province** is a group of directly or indirectly connected cities and no other cities outside of the group.

You are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `i<sup>th</sup>` city and the `j<sup>th</sup>` city are directly connected, and `isConnected[i][j] = 0` otherwise.

Return _the total number of **provinces**_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg)

```
Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
Output: 2
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg)

```
Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3
```

**Constraints:**

*   `1 <= n <= 200`
*   `n == isConnected.length`
*   `n == isConnected[i].length`
*   `isConnected[i][j]` is `1` or `0`.
*   `isConnected[i][i] == 1`
*   `isConnected[i][j] == isConnected[j][i]`


#### Solution

Language: **Python**

* [](https://leetcode.com/problems/number-of-provinces/discuss/101349/Python-Simple-Explanation)
```python
def findCircleNum(self, A):
    N = len(A)
    seen = set()
    def dfs(node):
        for nei, adj in enumerate(A[node]):
            if adj and nei not in seen:
                seen.add(nei)
                dfs(nei)

    ans = 0
    for i in xrange(N):
        if i not in seen:
            dfs(i)
            ans += 1
    return ans
```

### [684\. Redundant Connection](https://leetcode.com/problems/redundant-connection/)

Difficulty: **Medium**  

Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Graph](https://leetcode.com/tag/graph/)


In this problem, a tree is an **undirected graph** that is connected and has no cycles.

You are given a graph that started as a tree with `n` nodes labeled from `1` to `n`, with one additional edge added. The added edge has two **different** vertices chosen from `1` to `n`, and was not an edge that already existed. The graph is represented as an array `edges` of length `n` where `edges[i] = [a<sub style="display: inline;">i</sub>, b<sub style="display: inline;">i</sub>]` indicates that there is an edge between nodes `a<sub style="display: inline;">i</sub>` and `b<sub style="display: inline;">i</sub>` in the graph.

Return _an edge that can be removed so that the resulting graph is a tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the input.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg)

```
Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg)

```
Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
Output: [1,4]
```

**Constraints:**

*   `n == edges.length`
*   `3 <= n <= 1000`
*   `edges[i].length == 2`
*   `1 <= a<sub style="display: inline;">i</sub> < b<sub style="display: inline;">i</sub> <= edges.length`
*   `a<sub style="display: inline;">i</sub> != b<sub style="display: inline;">i</sub>`
*   There are no repeated edges.
*   The given graph is connected.


#### Solution

Language: **Python**

```python
class Solution(object):
    def findRedundantConnection(self, edges):
        """
        :type edges: List[List[int]]
        :rtype: List[int]
        """
        n = len(edges)
        parent = [i for i in range(n + 1)]
        rank = [1] * (n + 1)

        def find(x):
            if x != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]

        def union(x, y):
            px, py = find(x), find(y)
            if px == py:
                return True
            if rank[px] > rank[py]:
                rank[px] += rank[py]
                parent[py] = px
            else:
                rank[py] += rank[px]
                parent[px] = py
            return False

        for x, y in edges:
            if union(x, y):
                return [x, y]
```

## Machine Learning Coding
###  Linear regression
```python
from random import random
from __future__ import division

def dot(A, B):
    return sum([a * b for a, b in zip(A, B)])

def compute_MSE(Y, Beta, X):
    Y_hat = [dot(x, Beta) for x in X]
    sum_err = sum([(y - y_hat) ** 2 for y, y_hat in zip(Y, Y_hat)])
    return sum_err / len(Y)

# time complexity: O(n * d)
def gradient_descent_ridge(X, Y, n_iter=1000, lr=0.01, tol=0.01, lambd=0.5):
    n, p = len(X), len(X[0])
    Theta = [random() for _ in range(p)]
    for _ in range(n_iter):
        for j in range(p):
            # calculate gradient
            if j == 0:
                gradient_j = -2 / n * sum([y - dot(x, Theta) for x, y in zip(X, Y)]) + lambd * Theta[j]
            else:
                gradient_j = -2 / n * sum([x[j] * (y - dot(x, Theta)) for x, y in zip(X, Y)]) + lambd * Theta[j]
            # update theta
            Theta[j] = Theta[j] - lr * gradient_j
        if compute_MSE(Y, Theta, X) < tol:
            break
    return Theta

def grid_search(X, Y, num_trial=10):
    p = len(X[0])
    param_grid = [[random() for _ in range(p)] for _ in range(num_trial)]
    result = []
    for _, params in enumerate(param_grid):
        mse = compute_MSE(Y, params, X)
        result.append([mse, params])
    result.sort(key = lambda x: x[0])
    return result[0][1]

if __name__ == "__main__":
    n, p = 100, 4  
    Beta = [1] * p
    X = [[1] + [random() for _ in range(p - 1)]  for _ in range(n)]
    Y = [dot(x, Beta) for x in X]
    gradient_descent_ridge(X, Y)
    grid_search(X, Y)
```

###  Logistic Regression
```python
from math import exp
from random import random, sample
from __future__ import division

def dot(A, B):
    return sum([a * b for a, b in zip(A, B)])

def sigmoid(x):
    return (1 + exp(-x)) ** (-1)

def compute_MSE(Y, Beta, X):
    Y_hat = [dot(x, Beta) for x in X]
    sum_err = sum([(y - y_hat) ** 2 for y, y_hat in zip(Y, Y_hat)])
    return sum_err / len(Y)

def gradient_descent_logit(X, Y, n_iter=1000, lr=0.01, tol=0.01, lambd=0.5):
    n, p = len(X), len(X[0])
    Theta = [random() for _ in range(p)]
    for _ in range(n_iter):
        for j in range(p):
            # calculate gradient
            if j == 0:
                gradient_j = -2 / n * sum([y - sigmoid(dot(x, Theta)) for x, y in zip(X, Y)])
            else:
                gradient_j = -2 / n * sum([x[j] * (y - sigmoid(dot(x, Theta))) for x, y in zip(X, Y)])
            # update theta
            Theta[j] = Theta[j] - lr * gradient_j
        if compute_MSE(Y, Theta, X) < tol:
            break
    return Theta

if __name__ == "__main__":
    n, p = 100, 5
    Beta = [1] * p
    X = [[1] + [random() for _ in range(p - 1)]  for _ in range(n)]
    Y = [sample([0, 1,], 1)[0] for _ in range(n)]
    gradient_descent_logit(X, Y)
```

###  KNN
```python
from collections import Counter
from random import random, choice, randint
from heapq import heappush, heappop

def euclidean(A, B):
    return sum([(a - b) ** 2 for a, b in zip(A, B)])

###  Time Complexity: T(d * n + n * log(n))
###  Space Complexity: T(d * n)

def knn(X, Y, k, query):
    pairs = [(x, y) for x, y in zip(X, Y)]
    sorted_pairs = sorted(pairs, key = lambda x: euclidean(x[0], query))
    labels = [label for _, label in sorted_pairs[: k]]
    votes = Counter(labels)
    winner, _ = votes.most_common(1)[0]
    return winner

def sort_by_heap(pairs, query, k):
    heap = []
    for pair in pairs:
        distance = euclidean(pair[0], query)
        heappush(heap, (-distance, pair))
        if len(heap) > k:
            heappop(heap)
    knn_pairs = [pair for _, pair in heap]
    return [label for _, label in knn_pairs]

def knn_heap(X, Y, k, query):
    pairs = [(x, y) for x, y in zip(X, Y)]
    labels = sort_by_heap(pairs, query, k)
    votes = Counter(labels)
    winner, _ = votes.most_common(1)[0]
    return winner

def find_kth_largest(nums, k):
    if not nums:
        return
    pivot = choice(nums)
    left =  [x for x in nums if x > pivot]
    mid  =  [x for x in nums if x == pivot]
    right = [x for x in nums if x < pivot]

    L, M = len(left), len(mid)

    if k <= L:
        return find_kth_largest(left, k)
    elif k > L + M:
        return find_kth_largest(right, k - L - M)
    else:
        return mid[0]

def knn_quick_select(X, Y, k, query):
    pairs = [(x, y) for x, y in zip(X, Y)]
    distances, labels = [], []
    for pair in pairs:
        distances.append(-euclidean(pair[0], query))
        labels.append(pair[1])
    selected_labels = []
    for i in range(k):
        idx = distances.index(find_kth_largest(distances, k))
        selected_labels.append(labels[idx])

    votes = Counter(selected_labels)
    winner, _ = votes.most_common(1)[0]
    return winner

if __name__ == "__main__":
    k = 3
    n, p = 100, 3
    X = [[random() for _ in range(p)]  for _ in range(n)]
    Y = [randint(1, k) for _ in range(n)]
    for x, y in zip(X, Y):
        assert(knn(X, Y, 1, x) == y)
        assert(knn_heap(X, Y, 1, x) == y)
        assert(knn_quick_select(X, Y, 1, x) == y)
```

###  Kmeans
Time Complexity: `O(t*k*n*d)`
Space Complexity: `O((k + n)*d)`
```python
from random import random, sample, randint
from __future__ import division

def euclidean(A, B):
    return sum([(a - b) ** 2 for a, b in zip(A, B)])

def compute_means(points):
    points = [list(ls) for ls in zip(*points)]
    return [sum(point) / len(point) for point in points]

def classify(x, means):
    return min(range(k), key=lambda k_: euclidean(means[k_], x))

def kmeans(X, k):
    means = sample(X, k) # get_means_plus(X, k)
    assignments = None
    while True:
        # Find new assignments
        new_assignments = [classify(x, means) for x in X]
        # If no assignments have changed, we're done.
        if assignments == new_assignments:
            return assignments
        # Otherwise keep the new assignments,
        assignments = new_assignments
        # Recompute means

        for i in range(k):
            points = [point for point, group in zip(X, assignments) if group == i]
            if points:
                means[i] = compute_means(points)

def get_means_plus(X, k):
    n, p = len(X), len(X[0])
    # 1
    means = [[0] * p for _ in range(k)]
    means[0] = X[randint(0, n - 1)]
    # 2
    d = [0 for _ in range(n)]

    for j in range(1, k):
        sum_all = 0
        for i in range(n):
            # 3
            d[i] = euclidean(means[classify(X[i])], X[i])
            # 4
            sum_all += d[i]            
        # 5sum_all
        sum_all *= random()

        for i, di in enumerate(d):  
            sum_all -= di
            if sum_all > 0:
                continue
            means[j] = X[i]
            break
    return means

if __name__ == "__main__":
    k = 5
    n, p = 100, 2
    X = [[random() for _ in range(p)]  for _ in range(n)]
    kmeans(X, k)
    get_means_plus(X, k)
```

#### kmeans with loss
```Python
import random

# initialize
def kmeans(X, k):
    means = random.sample(X, k)
    iter = 0
    iterations = []
    loss_vector = []
    assignments = None
    while True:
      losses = [0] * k

      # step 1: find new assignments
      new_assignments = [classify(x, means) for x in X]

      # step 2: reccomput means for given cluster
      assignments = new_assignments
      new_means = [0] * k
      for j in range(k):
        points = [point for point, group in zip(X, assignments) if group == j]
        if points:
          new_means[j] = compute_means(points)
          for point in points:
            losses[j] += euclidean(point, new_means[j])

      iter += 1
      iterations.append(iter)
      loss_vector.append(sum(losses))
      print(losses, sum(losses))

      if new_means == means:
        return iterations, loss_vector, means, new_assignments
      means = new_means



k = 5
n, p = 1000, 2
X = [[random.random()  for _ in range(p)] for _ in range(n)]
kmeans(X, k)

# viz
#x, y, means, new_assignments = np.array(kmeans(X, k))
#import matplotlib.pyplot as plt
#plt.plot(x, y)
````

The intuition behind this approach is that spreading out the k initial cluster centers is a good thing: the first cluster center is chosen uniformly at random from the data points that are being clustered, after which each subsequent cluster center is chosen from the remaining data points with probability proportional to its squared distance from the point's closest existing cluster center.

#### Mapreduce
k-means3
* Map
* Combinemapreduce
* reduce


1. 
2. combinereduce
3. 

#### 
* [](https://stanford.edu/~rezab/classes/cme323/S16/projects_reports/bodoia.pdf)
1. Choose k initial means 1, . . . , k uniformly at random from the set X.
2. Apply the MapReduce given by k-meansMap and k-meansReduce to X.
3. Compute the new means 1, . . . , k from the results of the MapReduce.
4. Broadcast the new means to each machine on the cluster.
5. Repeat steps 2 through 4 until the means have converged.

#### Stopping Condition for K-Means clustering:
1. Centroids of the newly formed cluster remains the same as in the previous step.
2. Data points in the cluster does not change.
3. The maximum number of iterations is reached.

#### Assumption of Kmeans
* k-means assume the variance of the distribution of each attribute (variable) is spherical;
* all variables have the same variance;
* the prior probability for all k clusters are the same, i.e. each cluster has roughly equal number of observations;

If any one of these 3 assumptions is violated, then k-means will fail.

#### The optimal number of clusters can be defined as follow:
* Compute clustering algorithm (e.g., k-means clustering) for different values of k. For instance, by varying k from 1 to 10 clusters.
* For each k, calculate the total within-cluster sum of square (wss).
* Plot the curve of wss according to the number of clusters k.
* The location of a bend (knee) in the plot is generally considered as an indicator of the appropriate number of clusters.

###  Rejection Sampling
```python
from random import randint

def rand7():
    return randint(1, 7)

def rand10():
    c = (rand7() - 1)*7 + rand7() - 1
    return rand10() if c >= 40 else (c % 10) + 1    
```

###  Weighted Sampling
```python
from __future__ import division
from random import uniform

def weight_sampling(nums):
    total = sum(nums)
    nums = [num / total for num in nums]
    weights = []
    cum_sum = 0
    for num in nums:
        cum_sum += num
        weights.append(cum_sum)     
    return sum([uniform(0, 1) > weight for weight in weights])

if __name__ == "__main__":
    nums = [1, 3]
    weight_sampling(nums)
    trials = [weight_sampling(nums) for _ in range(1000)]
```

###  Reservoir sampling
```python
from random import randint

def reservoir_sampling(nums, k):
    result = []
    for i, num in enumerate(nums):
        if i < k:
            result.append(num)
        else:
            j = randint(0, i)
            if j < k:
                result[j] = num
    return result

if __name__ == "__main__":
    nums = [1, 2, 3]
    k = 2
    reservoir_sampling(nums, k)
```
Proof:
* For `k+i`, the probability that it is selected and will replace a number in the reservoir is `k/(k+i)`
* For a number in the reservoir before (let's say `X`), the probability that it keeps staying in the reservoir is
    * `P(X was in the reservoir last time)`  `P(X is not replaced by k+i)`
    * = `P(X was in the reservoir last time)`  (`1` - `P(k+i is selected and replaces X)`)
    * = `k/(k+i-1)`  `1 - k/(k+i)  1/k`
    * = `k/(k+i)`
* When `k+i` reaches n, the probability of each number staying in the reservoir is `k/n`

Example
* Choose `3` numbers from `[111, 222, 333, 444]`. Make sure each number is selected with a probability of `3/4`
* First, choose `[111, 222, 333]` as the initial reservior
* Then choose `444` with a probability of `3/4`
* For `111`, it stays with a probability of
    * P(`444` is not selected) + P(`444` is selected but it replaces `222` or `333`)
    * = `1/4` + `3/4`*`2/3`
    * = `3/4`
* The same case with `222` and `333`
* Now all the numbers have the probability of `3/4` to be picked

###  Biased Coin
```python
import random

def biased(p):
    # create a biased coin
    return 1 if random.random() < p else 0

def unbiased_from_biased(p):
    n1, n2 = biased(p), biased(p)
    while n1 == n2:
        n1, n2 = biased(p), biased(p)
    return n1

if __name__ == "__main__":
    p = random.random()
    print p

    tosses = [unbiased_from_biased(p) for i in xrange(1000)]
    n_1 = sum(tosses)
    n_2 = len(tosses) - n_1
    print n_1, n_2
```


###  Decision Tree
Find the best feature to split dataset in a decision tree?

```python
from collections import defaultdict, Counter
from __future__ import division
from math import log

def entropy(class_probabilities):
    """given a list of class probabilities, compute the entropy"""
    return sum(-p * log(p, 2) for p in class_probabilities if p)

def class_probabilities(labels):
    total_count = len(labels)
    return [count / total_count
            for count in Counter(labels).values()]

def data_entropy(labeled_data):        
    labels = [label for _, label in labeled_data]
    probabilities = class_probabilities(labels)
    return entropy(probabilities)

def partition_entropy(subsets):
    """
    find the entropy from this partition of data into subsets

    H = q_1 * H(S_1) +...+ q_m * H(S_m), where q is proportion and H() is entropy
    """

    total_count = sum(len(subset) for subset in subsets)
    return sum(data_entropy(subset) * len(subset) / total_count for subset in subsets)

def partition_by(inputs, attribute):
    """each input is a pair (attribute_dict, label). returns a dict : attribute_value -> inputs"""
    groups = defaultdict(list)
    for input in inputs:
        key = input[0][attribute]
        groups[key].append(input)
    return groups

def partition_entropy_by(inputs,attribute):
    """computes the entropy corresponding to the given partition"""        
    partitions = partition_by(inputs, attribute)
    return partition_entropy(partitions.values())  

if __name__ == "__main__":
    inputs = [
            ({'level':'Senior','lang':'Java','tweets':'no','phd':'no'},   False),
            ({'level':'Senior','lang':'Java','tweets':'no','phd':'yes'},  False),
            ({'level':'Mid','lang':'Python','tweets':'no','phd':'no'},     True),
            ({'level':'Junior','lang':'Python','tweets':'no','phd':'no'},  True),
            ({'level':'Junior','lang':'R','tweets':'yes','phd':'no'},      True),
            ({'level':'Junior','lang':'R','tweets':'yes','phd':'yes'},    False),
            ({'level':'Mid','lang':'R','tweets':'yes','phd':'yes'},        True),
            ({'level':'Senior','lang':'Python','tweets':'no','phd':'no'}, False),
            ({'level':'Senior','lang':'R','tweets':'yes','phd':'no'},      True),
            ({'level':'Junior','lang':'Python','tweets':'yes','phd':'no'}, True),
            ({'level':'Senior','lang':'Python','tweets':'yes','phd':'yes'},True),
            ({'level':'Mid','lang':'Python','tweets':'no','phd':'yes'},    True),
            ({'level':'Mid','lang':'Java','tweets':'yes','phd':'no'},      True),
            ({'level':'Junior','lang':'Python','tweets':'no','phd':'yes'},False)
        ]

    # Then we just need to find the minimum-entropy partition for the whole data set.  max g(D, A) =  H(D) - H(D|A) is equivalent to min H(D|A) which is partition_entropy_by(inputs, key)
    for key in ['level','lang','tweets','phd']:
        print key, partition_entropy_by(inputs, key)
```

### AUC
```python
# ml
## ,precision, recall, ml:
```python
from __future__ import division
import random
n = 1000
ys = [random.randint(0, 1) for _ in range(n)]
y_preds = [random.random() for _ in range(n)]

def pr(ys, y_preds, threshold):
    y_hats = [1 if y_pred > threshold else 0 for y_pred in y_preds]
    tp, fp, tn, fn = 0, 0, 0, 0
    for y_hat, y in zip(y_hats, ys):
        if y_hat == 1 and y == 1:
            tp += 1
        elif y_hat == 1 and y == 0:
            fp += 1
        elif y_hat == 0 and y == 0:
            tn += 1
        elif y_hat == 0 and y == 1:
            fn += 1
    #print tp, fp, tn, fn
    precision = 0 if tp + fp == 0 else tp / (tp + fp)
    recall = 0 if fp + tn == 0 else tp / (tp + fn)
    return precision, recall

xaxis, yaxis = [], []

for y_pred in y_preds:
    precision, recall  = pr(ys, y_preds, y_pred)
    xaxis.append(recall)
    yaxis.append(precision)

pr_curve = [(x, y) for x, y in zip(xaxis, yaxis)]
pr_curve.sort()
pr_curve[0] = (0,1)
pr_curve.append((1, 0))
auc = 0
for i in range(1, len(pr_curve)):
    point_a = pr_curve[i - 1]
    point_b = pr_curve[i]
    auc += (point_a[1] + point_b[1]) * abs(point_a[0] - point_b[0]) * 0.5
auc
```
